{
2017-5-2,
//------
C++STL,
(http://www.cnblogs.com/lfsblack/archive/2012/11/10/2764334.html)
6214830172152976
dsbzsfzx@163.com
08162049北京市海淀区上地街道树村社区卫生服务站
shebao.bj@qunar.com
17640154865
去哪儿网报销,（http://baoxiao.corp.qunar.com/qvampire/expenseVoucherMain/view/myApplications）;
qunar打印机,(http://qunar.it/it/show/7196),(http://qunar.it/it/show/7201);
王锦涛日报,(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=156798015&moved=true);
王锦涛作业文件夹,(/home/linux2014/linux2014/Projects/Java_Maven/dev_training2);
Qunar CM,(http://cm.corp.qunar.com/),(http://nexus.corp.qunar.com/nexus/index.html#welcome);
Qunar,2017-2,gitlab,(http://gitlab.corp.qunar.com/campus2017/dev_training2);
Qunar,2017项目开发群,(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=157371588);
Qunar,科学上网,(http://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=152797231);
Qunar,qschedule,(http://qschedule.corp.qunar.com/jobs.do);
Qunar,scm_gitlab,(http://gitlab.corp.qunar.com/scm/permissions);
qunar,gitlab,(http://gitlab.corp.qunar.com/);
//------
{
待下载的电子资料专区：
《lua设计与实现》，
《》，
}
//------
{
发信人: xgamma (HummingBird), 信区: PieBridge 
标  题: 征婚 
发信站: 瀚海星云 (2017年08月02日14:56:02 星期三), 站内信件 WWWPOST 

女，未婚，1984年生，国企行政管理人员，研究生学历。性格好沟通，形象好气质佳， 
身高160体重48公斤。寻觅1973后出生的单身男士，品貌端正。 

请联系QQ 529445074
//---------
标  题: 替亲姐姐征友 
发信站: 瀚海星云 (2017年08月01日19:36:24 星期二), 站内信件 WWWPOST 

    替亲姐姐征友 
    姐姐身高165CM，91年，籍贯安徽阜阳，学历985硕士，打算后期在合肥或杭州发展 
。  
    性格开朗大方，随和，皮肤白皙。 
     
    要求：身高175以上，85-90年，三观正，本科及以上学历均可（USTC科大校友加分 
），无婚史，后期在杭州或者合肥发展，成熟稳重。  
     
    因姐姐白天上班，比较忙，有意者晚上联系。 
   
QQ号:2292482102 (非诚勿扰) 验证消息：ustc 
//----------
发信人: hellosunweia (樱花残月), 信区: PieBridge 
标  题: 主题：愿得一人，琴瑟和鸣。(替友发帖） 
发信站: 瀚海星云 (2017年07月31日22:28:24 星期一), 站内信件 WWWPOST 

    缘分会迟到，我坚信不会缺席！所以，一直期待一场美好的相遇…… 
    本人身高165CM，88年，籍贯安徽肥东，学历本科，职业公办小学教师，未婚，成长 
于和睦的四口之家。 
    性格开朗大方，随和，不拘小节，也有点慢热，爱好旅游，看电影，读书，逗逗猫 
猫狗狗。 
    对对方的要求：身高170以上，83-90年，本科及以上学历均可，无婚史，最好是合 
肥的（异地也不介意，我可以来到你的城市），有稳定工作，成熟稳重。 
微信号:syl18555887036 (非诚勿扰)
//--------
标  题: 代一姐姐征男友 
发信站: 瀚海星云 (2017年07月21日04:29:40 星期五), 站内信件 WWWPOST 

征男友，姐姐江南人，谈了一场恋爱后空窗很久，身边也不乏追求者也相亲过几次，一 
直未遇到想要的感情。硕士毕业，在一省直事业单位工作，工作之余健身运动旅游看看 
书养养花简单生活。喜欢内涵沉稳一点男士，最好也硕士，爱运动。身高170以上，80～ 
85之间，有点点眼缘吧。不在乎你有没有房子车子，我们一起奋斗，没有什么比一颗真 
诚和温暖的心更珍贵。(不好意思，不太能接受离异)，qq  2429805935.用一句 歌词表 
达下心思，在此祝福每个有爱的人。 

也许 千帆过了还在等 
也许 笑眼泪光盼到那个人也  
动了我的情 乱了你的心 
蓦然回首是谁的人生 
//----------
发信人: youzai (aj), 信区: PieBridge 
标  题: 帮妹子征男友 
发信站: 瀚海星云 (2017年05月30日14:52:23 星期二), 站内信件 WWWPOST 

   妹子89年的，160cm，长相甜美，从事运营管理类工作，月薪1w+，毕业于合肥某一本 
工科院校，暂定居合肥。喜欢旅游、跑步、美食、阅读、音乐，想找一人一起短途自驾/ 
出境自由行、晨跑/夜跑、探索美食/钻研食谱、研读财经法规/科研论文，欣赏古典乐/ 
欧美流行乐。希望男方89-84为佳，身高172+，学历一本+（最好科大毕业），成熟稳重 
有上进心。工作虽然重要，但也要顾家的男人。微信：violet3violet，非诚勿扰！ 
//---------
}
//---------
{
学习网站和论坛,
//---
廖雪峰资料,(https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000);
,(https://github.com/michaelliao);
//-----
}
//------
{
2017-07-18补充:
Qunar,目的地技术组，wiki空间,
(http://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=55527617);
(http://wiki.corp.qunar.com/confluence/pages/resumedraft.action?draftId=164998251&draftShareId=e28d068c-797c-45b4-bd59-55947a61c205);
//-----
Qunar,目的地技术组，代码规范,
(http://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=57337072);
//------
Qunar,jira,
(http://pmo.corp.qunar.com/login.jsp?permissionViolation=true&os_destination=%2Fbrowse%2FDZS-15792&page_caps=&user_role=);
//-------
Qunar,目的地事业部,watchdog--gitlab,
(http://gitlab.corp.qunar.com/scm/watchdog);
//-----------
}
{
2017-2应届生项目组,
bugfree,(http://bugfree.corp.qunar.com/index.php/bug/list/54?productmodule_id=14669);
}
//--------
maven中央仓库,(http://search.maven.org/);
maven中央仓库2,(http://maven.outofmemory.cn/);
//----
maven仓库,(https://mvnrepository.com/);
//-----
美餐网,(https://meican.com/index#/dish/recommendations/c08fa0b1-76aa-4981-8d2c-82d962a554a9/2017-05-31%2016:30/)
Email:Q138370@qunar.com
Pwd:123456
//-----
}
{
由于蚂蚁宝卡是支付宝和中国联通联合开发的，
大家如果遇到了任何问题可以拨打联通人工客服电话：10010或支付宝官方客服电话:95188.进行人工客服人员注销。
}
{
cache,(http://www.cnblogs.com/lzrabbit/p/3734850.html);
guava API,(http://tool.oschina.net/apidocs/apidoc?api=guava);
guava阅读计划,（http://wiki.corp.qunar.com/pages/viewpage.action?pageId=155285478）；
}
{
2017-5-3,
//--------
正像上帝的仆人王明道说（做）的:“遇到危险的时候要往前冲，受益的时候要往后退。”
//--------
往届优秀学长、导师的的采访记录；
//-------
}
//--------------
{
骆驼帮，(http://qunar.it/),(http://bbs.corp.qunar.com/forum.php);
去哪儿网公司，东升科技园地址，(北京市海淀区西小口路66号中关村东升科技园北领地B-2号楼四层);
}
//--------
{
wjt_Qunar,
//---------
{
user:jintao.wang
Email:jintao.wang@qunar.com
Pwd:Qunar.4832
}
{
2017-07-17,
Qunar重置密码,
userName:jintao.wang
Pwd:Qunar.201351
}
//-------------
日报，
wiki,(http://wiki.corp.qunar.com/display/~jintao.wang/Home);
gitlab,(http://gitlab.corp.qunar.com/campus2017/dev_training2);
//-----------
ubuntu14.04(X64),开发环境的使用:
JDK，可在terminal下直接使用;
idea，在terminal下执行idea的bin文件夹下idea.sh文件可以启动idea,已经将idea.sh的路径加入PATH环境变量，可以在任意目录下启动idea;
git，直接在terminal下执行;
kdiff3,配合git使用;
maven;
vpn;
qtalk，在terminal下执行qtalk命令即可启动qtalk;
邮箱用thunderbird;
//--------------------
}
//-----------
{
看准网：
Email:15236286736@163.com
Pwd:linux2014
}
{
//-------
Gitlab,(http://gitlab.corp.qunar.com/);
谢文泉 16:32:49
应届生培训须知&常见问题   http://wiki.corp.qunar.com/pages/viewpage.action?pageId=69168586
16:35:40
 	谢文泉 16:35:40
Quick Start   http://wiki.corp.qunar.com/display/campus/Quick+Start   
以下是未读消息	
 	谢文泉 16:36:21
2017-2期 课表  http://wiki.corp.qunar.com/pages/viewpage.action?pageId=155285204
16:44:46
 	谢文泉 16:44:46
这几个链接地址培训期间用的比较多  大家可以保存一下   
//---------
应届生培训须知&常见问题http://wiki.corp.qunar.com/pages/viewpage.action?pageId=69168586  
2017-2期 课表  http://wiki.corp.qunar.com/pages/viewpage.action?pageId=155285204 
Quick Start   http://wiki.corp.qunar.com/display/campus/Quick+Start     
//------------	
去哪儿网的开发规范,(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=5548886);
}
{
在去哪儿网培训，需要谨记的问题：
1、通信工具保持开放：手机、微信、公司邮箱Foxmail、Qtalk；
2、每天都要有计划，每晚都要有总结，每天都要有日报；
3、当日事、当日毕；
}
//----------
{
JAVA_HOME	/home/q/java/jdk1.7.x	JDK 根目录
CLASSPATH	.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar	Java 类库路径
PATH	%JAVA_HOME%\\bin	Java 可执行程序路径， 如 java， javac 等
}
//-------
D:\\WJT_work\\Soft_Install\\kDiff3
//------------
ssh-keygen -t rsa -C "jintao.wang@qunar.com"
//------------
D:\\WJT_work\\Soft\\apache-maven-3.0.5-bin\\apache-maven-3.0.5\\bin
{
git clone git@gitlab.corp.qunar.com:brian.yang/gittest.git
D:\\WJT_work\\Projetcs\\git_repository1
ssh-keygen -t rsa -C "jintao.wang@qunar.com"
C:\Users\jintao.wang\.ssh

ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDQTIi+XuWOZduFmqt6/BXx9muABL1BSRzdzhYJ7OAEFxgdCq2YiDej0LV/01SB29f0v02uoOd+1JyfAlsTWG+X36QmRogfk/Fl8DRdIqYrQQwgFRQAoskBmn2DGNysBWM1IRJ0DPypttoQh8roOQFdsBkXkH13w3ZeYeZ1qvQLktdzp5KaUJWWuhLYBZtsPXeRPd9YnWmetnUg+ar7Qvk8aOvY/eR+QSohV3k3vKhLzfuwrPpgdZPSLcaHLYbeOfLumDg11QPFyf4loJgbo6B9CJSUA89JK/2Ze/Z1K0/RHe9PDW0xNUdetWdg05sEfMTGfBEfFsAEqiDAimb6VCp7 jintao.wang@qunar.com

GitLab
发给 王锦涛
详细信息2017-05-05 14:41
Hi 王锦涛!

A new public key was added to your account:

title: jintao.wang@qunar.com

If this key was added in error, you can remove it here: SSH Keys
git clone git@gitlab.corp.qunar.com:bin.qiao/java-guava-collection-homework.git
{
自留地，你的地盘你做主----
上面说的都是正式的project们。如果你只是想练练手，试试看，那可以在自己的自留地新建个project，搞一搞。
具体地说，是从http://gitlab.corp.qunar.com/projects/new开始，新建一个project。注意：
新建的时候，Namespace一项一定要是自己的名字。不然可能会建到正式的组里面哦。
提示：如果在创建project时，没有看到Namespace选项，那么Namespace的默认值就是你的名字。
可以选择点击“Import existing repository?”，然后填上“https://github.com/dongyue/q_exercise.git”这样一来，新建的版本库里，就会有“\\192.168.100.112\技术部\技术培训视频\Git培训视频”里刚开始时服务器端版本库里的内容。
不要去点“Create a group”那个按钮，那会新建一个Git组的……
假如孙悟空同志新建了一个叫peach的project，那么project的URL是http://gitlab.corp.qunar.com/wukong.sun/peach。如果刚才没有选“Import existing repository?”的话，那么孙悟空同志初始化这个版本库要执行的几个命令，现在就显示在这个网页里。而如果刚才是从“https://github.com/dongyue/q_exercise.git”导入的话，这个网页就会显示这个库的新近发生的事情。Git路径是git@gitlab.corp.qunar.com:wukong.sun/peach.git，也显示在这个网页里。
孙悟空同志是peach这个project的owner，他可以把任何人加入到这个project里，赋予任意权限。所以师徒四人可以配合做Git练习哦。
}
}
//-------
{
七月在线,(https://www.julyedu.com/);
}
//---------
commit 8ca5ea11789ada8dc3e6aac60e08dc82aa7b4f70
Author: jintao.wang <jintao.wang@qunar.com>
Date:   Fri May 5 19:27:48 2017 +0800

    add caffe

commit 46fb22b32ea0557b006c7fb9534fd4a12513bbf3
Author: jintao.wang <jintao.wang@qunar.com>
Date:   Fri May 5 19:12:42 2017 +0800

    ***

commit aeeeac4685138b04c341d857c2f87aba41a3531d
Author: jintao.wang <jintao.wang@qunar.com>
Date:   Fri May 5 19:08:24 2017 +0800

    blank

commit 60757007a80a5e0f225d8b86b9c5f53cc06da33c
Author: jintao.wang <jintao.wang@qunar.com>
Date:   Fri May 5 18:33:50 2017 +0800

    删除new
//---------------
qunar_common.pcf
//--------------
2017-05-08,
{
C/C++中extern变量不能同时初始化;extern变量是是声明，而非定义，可编译，但不可链接;
}
{
linux下后台运行一个进程的方法:
$nohup <process_cmd> <args_list>
//--------
//------------
在 Linux 上，/dev/null 是一个特殊的文件设备，它会忽略所有的写在它上面的数据。
//------
在linux上
//------------
红黑树、trie树、Hashhttp://gitlab.corp.qunar.com/campus2017/dev_training2表、排序算法,(http://blog.csdn.net/chenhuajie123/article/details/11951777);
//--------
@all   今天的安排：完成 摸底考试 
考试题
http://wiki.corp.qunar.com/pages/viewpage.action?pageId=155964591

考试作业提交&评分标准
http://wiki.corp.qunar.com/pages/viewpage.action?pageId=155285466
//--------
//java判断是否为汉字
public static boolean isChinese(String str) {
		String regEx = "[\u4e00-\u9fa5]";
		Pattern pat = Pattern.compile(regEx);
		Matcher matcher = pat.matcher(str);
		boolean flg = false;
		if (matcher.find())
			flg = true;

		return flg;
}
//-----
Java判断一个字符串是否有中文一般情况是利用Unicode编码(CJK统一汉字的编码区间：0x4e00–0x9fbb)的正则来做判断;
//-----
[\u4e00-\u9fa5]是中文的Unicode编码范围;
//-----
}
{
代码规范;
}
//-----------------
提交作业,(git@gitlab.corp.qunar.com:campus2017/dev_training2.git);
//-----------------
git 
git branch 
//-----------
http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang
//-----------------
{
编程之法：面试和算法心得
程序员面试宝典 笔试金典 CSDN访问量过千万的博客结构之法算法之道博主July著作
}
//------------
{
作业要求必须严格执行
    项目结构和包目录按照导师要求建
    作业中涉及的文件(除题目要求从网络读取外)必须放在本地 resources 文件夹, 不能写绝对路径
    作业中涉及到生成文件的部分, 必须生成到编译目录, 不能写绝对路径
    作业必须在别的机器上 checkout 下来也能跑通, 跑不通的直接 0 分
    包名小写, 类名首字母大写, 方法及变量名首字母小写, 除静态变量外, 都使用驼峰命名
    代码必须格式化
    功能没完成的, 0 分
    文件/网络 IO 流必须使用 try {} finally {} 关闭
    学习了 Logger 以后, 必须使用 Logger, 而不能使用 e.printStackTrace()
    项目结构要能被 idea 识别, 不能 idea 打开项目后看不到代码
}
{
idea开发环境配置:
maven,pom.xml
<parent>
        <groupId>qunar.common</groupId>
        <artifactId>qunar-supom-generic</artifactId>
        <version>1.3.2</version>
    </parent>
}
{
idea2017激活:
进入ide主页面，help-register-license server,然后输入 http://idea.iteblog.com/key.php
在线激活IntelliJ IDEA 15.0,(http://idea.iteblog.com/);
}
{
IntelliJ IDEA 工具的安装非常简单，这里就不再赘述了。安装完以后，须要输入注册码，大家可以移步这里找到注册码。
http://blog.csdn.net/henren555/article/details/43406479
idea 15.0.3 破解码，先选择 License server，将下面复制到输入框。
http://idea.lanyus.com 

如果您下载的是 ideaIU-2016.1.1.exe 
破解码是：
http://www.iteblog.com/idea/key.php
（参考自 
IntelliJ IDEA 2016.1怎么能激活啊！-CSDN论坛-CSDN.NET-中国最大的IT技术社区 http://bbs.csdn.net/topics/391919498）
}
//---------------
{
ubuntu下的<fname>~文件;
idea的使用java的包、访问控制权限;
}
//----------
{
2017-5-9,
//-----------
@all 所有同学今天下午的安排：
完成在线课程《Linux基础与应用》的学习：http://qtown.corp.qunar.com/online/detail.html?courseId=314
完成线上课程课后练习题内容：http://wiki.corp.qunar.com/pages/viewpage.action?pageId=148897254
剩下的时间可以做线下课程内容里面的题目，能做多少是多少~
}
{
ubuntu google浏览器，
//------------
一、通过直接下载安装Google Chrome浏览器deb包。
打开Ubuntu终端，以下为32位版本，使用下面的命令。
wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb
以下为64位版本，使用下面的命令。
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
下载好后
32 位安装命令:
sudo dpkg -i google-chrome-stable_current_i386.deb
64 位安装命令:
sudo dpkg -i google-chrome-stable_current_amd64.deb 
安装好后，命令行启动：
$google-chrome-stable
//-----------
}
//-------------
取餐时，您可以从东升科技园北领地B-6-4的 J221 架位直接取到您的餐点。
//--------
{
linux系统下的文件可以使偏移位置超出文件长度，这时文件内会出现一些空洞，可以在空洞之后写入数据。
空洞区不占外存空间。读取该文件时，在空洞处read()函数读取0。
//------
$ls -ls <以空格间隔的文件名列表>
可以查看文件占用的盘块数;
//--------
硬链接，文件名指向目标文件的索引节点，只有指向一个索引节点的所有链接都被删除后，该文件的存储区才会被释放;
软链接，实际上是一个文本文件，包含另一文件的位置信息。
}
//--------
http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html
100.81.136.85
http:100.81.136.85/home/linux2014/linux2014/Projects/http_html/关于HTTP协议，一篇就够了 - ranyonsue - 博客园.html
//-----
HTTP协议;
主机域名与IP地址;
gethostbyname();
struct hostent;
inet_ntop();
inet_pton();
//---------
在计算机网络中，物理地址有时又是MAC地址的同义词。这个地址实际上是用于数据链路层，而不是如它名字所指的物理层上的。
//--------
yisong.su@qunar.com
campus2017-tech@qunar.com
//-------------
{
linux作业，
//-----
1、文件检测和目录创建;
2、文件行统计;
3、文件查找和处理;find,xargs;
4、日志分析;crontab；
//-------
}
//----------
{
//--------
最佳实践，保证少犯错:
先备份，再修改;
定时备份;
//-------------
长时间运行任务用nohup命令;
//----
检查操作状态：
#!/bin/sh
dir=$1
cd $dir
rm -rf *
//------
cd $dir || exit -1
//-----------
尽量不使用root、sudo、将文件权限改为777;
//--------
}
{
awk;
}
{
/etc/sudoers
shell中反引号和单引号;
双引号和单引号的区别;
}
//------------
{
ctrl+h，可以显示或隐藏那些隐藏的文件。
code->Auto-indent-lines;
}
{
与粟老师对话，讲程序代码;
//--------
可以用idea提交到gitlab。
我明白了。你只是提交了 .gitignore文件，这个东西最开始的时候就要有。
你现在提交.gitignore，并不会帮你删除已经存在的class文件。
你可以把class 手动删了，再push。
//--------
21，属性注释应该放在属性上方。
56，logger应该是静态私有类变量。
没必要放在构造函数里面
118，以后异常都要输出堆栈，而且是error级别，类似这样
logger.error（“xxxException happen ”, ioe）
129，同上。。。
146，代码风格不太好，空行太多。
公司有规范，格式化代码一下。
//---
你的代码问题是有不必要的空行。
你自己弄得好看一点吧。
private static final Logger logger=Logger.getLogger("charCountLog");
logger.error(ioe.toString(),ioe);
用slf4j。
//-----
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {
  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info("Hello World");
  }
//-------
5月15日作业，(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=156644084)
粟老师点评：
王锦涛_作业题2/wangjintao_guava_2_title1/src/AccessLog.java
46行，不要在程序中使用 System.exit，应该抛出异常，留给上层进行处理。
System.exit是程序直接退出，会导致没有任何记录。不能排查问题。
线上系统，没有用System.exit的应该执行throw new xxxException();
54行，为了节约内存，最好使用流式读取，不要一下子读取全部文件。
可以用BufferedReader调用readLine()函数逐行读取文本。
56，行打印堆栈。
}
//--------
{
实质上，主机名的含义是机器本身的名字，域名是方便记录IP地址才做的一种IP映射；通过上述介绍可以看到，
二者有共性：都能对应到一个唯一的IP上，从应用场景上可以这么简单理解二者的区别：主机名用于局域网中；域名用于公网中。
//---------
主机名代表一台主机,
域名:代表一个区域的名称,
举个例子吧 www.sina.com.cn
www是一台提供网页的机器 sina.com.cn是域名   
再举一个sports.sina.com.cn
sports是一台提供体育新闹的主机,sina.com.cn是新浪的域名。
//---------

}
//------------
{
ping,hostname,host,ifconfig,nc,telnet,netstat,tcpdump;
ps,free,top,kill;
//-----
linux默认的shell解释器是/bin/bash;
<Tab>键的补全功能;
反斜杠(\)紧接<Enter>的续行作用;
$<var_name>和${<var_name>}都表示变量的内容;
例如$PATH和${PATH};
可用双引号或单引号将变量值结合起来;
双引号内的特殊字符仍保留其特性;
单引号内的特殊字符仅为一般字符;
例如：var="lang is $LANG"
var2='lang is $LANG'
在双引号内可用转移字符"\"使特殊字符变成一般字符;
例如:var3="lang is \$LANG"
`<cmd_name>`、$(cmd_name)表示命令的执行结果，
例如：`ls -ail`,$(ls -ail);
取消变量用unset;
export <var_namr>，可将自定义变量转成环境变量，自定义变量不能被子进程继承，而环境变量可被继承;
export，可列出所有的环境变量;
可用declare将环境变量转成自定义变量;
env可以查看所有的环境变量;
set,decalare，不带参数时会列出所有的变量;
读取数组元素值,${<arr_name>[<idx>]},例如：${arr[1]};
数组元素赋值，<arr_name>[<idx>]=<value>;
//-------------
}
{
LinuxC,
setenv(),unsetenv(),putenv(),getenv();
}
{
vim,
//---------
<num><space>
/word,?word,n,N;
nx,nX;
ndd;
nyy;
p,P;
}
//-------------
{
问题：
//----------
$nc -t www.baidu.com 80
GET / HTTP/1.0
//---------
tcpdump
}
//----------
curl -X POST -c '/home/linux2014/linux2014/Projects/wjt_cookie' -d 'username=graduate&password=graduate_password' l-live1.support.wap.dev.cn0.qunar.com:7070/graduate/api/login
curl -X POST -b '/home/linux2014/linux2014/Projects/wjt_cookie' -H 'Content-Type:application/json' -d '{"username":"graduate","password":"graduate_password","name":"WJT","mobile":"17640154865","people_num":"10"}' l-live1.support.wap.dev.cn0.qunar.com:7070/graduate/api/submit 
//-----------
{
2017-5-11,作业评讲:
//-----------
抽象能力很重要;
高层次的分解;
先有大体思路，再考虑实现;
Qunar，代码清晰度比性能更重要;
dev,80%的工作都是维护代码;
多线程要尤其注意线程安全;有竞争，多个线程都有写操作;
写public接口时要防止使用者用错;尽量不要修改入参作为返回值;类尽量不要状态属性，因为难以维护;
严格按照maven项目规范组织代码;
检测入参，如果不合理，应立即失败,fail fast;
可复用性比硬套设计模式更重要;
读取文本的方法、输出统计结果的方法、检测计数的方法都可以抽象;
不要写死换行符，要通过系统变量获取换行符，保证跨平台性;
项目内不要用System.out,System.err，这样容易造成阻塞;
对每一个值都应给出变量名;
路径的分隔符通过环境变量获取;
变量、方法等的自说明比注释更好，只在讲业务时才用注释;
countCharsFromFile();
if-else，要加花括号;
for(File file:fileList)
{...}

用index，而非i;

代码格式化;

声明时只考虑其功能，而不要考虑实现细节;

判断字符类别可用类库;

只有过度设计了，才明白什么是恰当的设计;
}
{
下面的命令来给root账号设置密码：
$sudo passwd root
接下来按提示操作即可;
}
//-------------
{
//-----------
idea报错，程序包不存在，解决办法：
File–>Project Structure–>左侧 Libraries，中间新建一个 lib 的project Library，选择 Java，然后在选择项目中的 jar 所在的文件夹，
我的是 WebContent–>WEB-INF–>lib，最后点击 OK，重新编译即可。
idea添加异常处理的快捷方式：将光标放在需要异常处理的表达式内，点击快捷键<Alt>+<Enter>，会弹出菜单，选择异常处理即可;
idea实现接口的快捷键:alt+Enter;
idea,ctrl+shift+enter,补全if,do...while,try-catch,return;
ctrl+shift+I,review;
ctrl+<space>,查看属性等;
ctrl+shift+<箭头>,移动代码块;
Alt+Shift+F10,access the Run/Debug dropdown on the main toolbar;
idea水平方向移动代码块的方法：先选中代码块，再tab右移或shift_tab左移;
光标指向某一个类，同时按下CTRL+F12，可看到该类的全部成员；
idea内，ctrl+d，复制当前行到下一行;
//-----
chrome浏览器，强制刷新页面代码的快捷键是ctrl+F5。
//---------
}
}
//--------
    sdxl_prop.txt(https://owncloud.corp.qunar.com/index.php/s/2pvS0d2Zs5onsF2/download)
    sdxl_template.txt(https://owncloud.corp.qunar.com/index.php/s/2mElvSWUJgppSBx/download)
//-------
public InputStream getInputStream()
                           throws IOException

InputStreamReader(InputStream in, Charset cs)
Creates an InputStreamReader that uses the given charset.

BufferedReader(Reader in)
Creates a buffering character-input stream that uses a default-sized input buffer.

String	readLine()
Reads a line of text.
//----------------
1) natureOrder 自然排序，即文本中排列顺序
2) indexOrder 索引排序，文本中每行第一个数字为索引
3) charOrder 文本排序，java的字符排序
4) charOrderDESC 
//-------------
/home/linux2014/linux2014/Projects/java_projects/170511_Dev_2/out/production/170511_Dev_2/sdxl.txt
//-----------
<object class="com.qunar.fresh.Student">
<property name="name">
<value>${name}</value>
</property>
<property name="age">
<value>${age}</value>
</property>
<property name="birth">
<value>${birth}</value>
</property>
</object>
//-------------
{
2017-05-12,
//----------
讲题：
统计源文件的有效行;
可复用，需要分清可变的和不变的;
正则表达式;模式匹配;
interface LineProcessor;
API为什么这样设计？多想想原因。
if ... else...,这种结构不应加入程序主流程内，可用迭代法代替，需要定位接口;
java的枚举;
熟悉常用的类库;
可读性、复用性、尽量应用成熟的类库;
//----
文本替换，
有效沟通：先讲大体每一步的作用，再说每一步的具体实现;
多线程，一个负责读取文本、一个负责替换、一个负责写结果;
LinkedHashMap,
String pattern = "\\$\\";
缓冲、缓存;
屏蔽差异，统一接口;
不确定的，不可瞎猜，找相关人员确认;
//---------
根据XML生成对象，并设置对象的值、输出对象的值，
能满足需要，抽象程度最高，才是最好的;
尽量不要修改主逻辑;
查找解决问题办法的方法：哈希表、二分法、顺序查找、随机查找;
//-------------
}
//----------
{
反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；
对于任意一个对象，都能够调用它的任意一个方法和属性；
这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
}
//---------
{
Java中的原生数据类型（Primitive DataType）共有8种：
1）整型：     使用int表示（32位）。
2）字节型： 使用byte表示（从-128到127之间的256个整数）。
3）短整型： 使用short表示（16位）。
4）长整型： 使用long表示（64位）。
5）单精度浮点型：使用float表示。所谓浮点型，指的是小数，也叫实数，例如：1.2。
6）双精度浮点型：使用double表示。双精度浮点型表示的数据范围比单精度数据类型大很多。
7）字符型：          使用char表示。所谓字符，就是单个的字符表示，例如字母a，或者中文张，外面用单引号包围，比如 char a = 'B'; char b = '王';
8）布尔类型： 使用boolean表示，布尔类型只有两种可能，分别为true或false。
}
//-------------------------
2017-05-13,
{
public final class Class<T>
extends Object
implements Serializable, GenericDeclaration, Type, AnnotatedElement

Instances of the class Class represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a Class object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types (boolean, byte, char, short, int, long, float, and double), and the keyword void are also represented as Class objects.
Class has no public constructor. Instead Class objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the defineClass method in the class loader.
//-----
public static Class<?> forName(String className)
                        throws ClassNotFoundException
Returns the Class object associated with the class or interface with the given string name. 
//---
public T newInstance()
              throws InstantiationException,
                     IllegalAccessException
Creates a new instance of the class represented by this Class object. The class is instantiated as if by a new expression with an empty argument list. The class is initialized if it has not already been initialized.
returns a newly allocated instance of the class represented by this object.
//-----
public Constructor<?>[] getConstructors()
                                 throws SecurityException
Returns an array containing Constructor objects reflecting all the public constructors of the class represented by this Class object. An array of length 0 is returned if the class has no public constructors, or if the class is an array class, or if the class reflects a primitive type or void. Note that while this method returns an array of Constructor<T> objects (that is an array of constructors from this class), the return type of this method is Constructor<?>[] and not Constructor<T>[] as might be expected. This less informative return type is necessary since after being returned from this method, the array could be modified to hold Constructor objects for different classes, which would violate the type guarantees of Constructor<T>[].
Returns:
the array of Constructor objects representing the public constructors of this class
//----
public Field getField(String name)
               throws NoSuchFieldException,
                      SecurityException
Returns a Field object that reflects the specified public member field of the class or interface represented by this Class object. The name parameter is a String specifying the simple name of the desired field.
The field to be reflected is determined by the algorithm that follows. Let C be the class represented by this object:
1、If C declares a public field with the name specified, that is the field to be reflected.
2、If no field was found in step 1 above, this algorithm is applied recursively to each direct superinterface of C. The direct superinterfaces are searched in the order they were declared.
3、If no field was found in steps 1 and 2 above, and C has a superclass S, then this algorithm is invoked recursively upon S. If C has no superclass, then a NoSuchFieldException is thrown.
//-----
public Field[] getDeclaredFields()
                          throws SecurityException
Returns an array of Field objects reflecting all the fields declared by the class or interface represented by this Class object. This includes public, protected, default (package) access, and private fields, but excludes inherited fields. The elements in the array returned are not sorted and are not in any particular order. This method returns an array of length 0 if the class or interface declares no fields, or if this Class object represents a primitive type, an array class, or void.
//----
public Method[] getDeclaredMethods()
                            throws SecurityException
Returns an array of Method objects reflecting all the methods declared by the class or interface represented by this Class object. This includes public, protected, default (package) access, and private methods, but excludes inherited methods. The elements in the array returned are not sorted and are not in any particular order. This method returns an array of length 0 if the class or interface declares no methods, or if this Class object represents a primitive type, an array class, or void. The class initialization method <clinit> is not included in the returned array. If the class declares multiple public member methods with the same parameter types, they are all included in the returned array.
//-----
getDeclared..()和get...()的一个显著区别是：前者是针对所有成员，不限制访问权限，后者仅针对public成员;
}
{
java动态代理：
//--------
java.lang.Object
java.lang.reflect.AccessibleObject
java.lang.reflect.Method
//------
public interface InvocationHandler
InvocationHandler is the interface implemented by the invocation handler of a proxy instance. 
Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler. 
Object invoke(Object proxy,
            Method method,
            Object[] args)
              throws Throwable

Processes a method invocation on a proxy instance and returns the result. This method will be invoked on an invocation handler when a method is invoked on a proxy instance 
that it is associated with. 
Parameters:
proxy - the proxy instance that the method was invoked on
method - the Method instance corresponding to the interface method invoked on the proxy instance. The declaring class of the Method object will be the interface 
that the method was declared in, which may be a superinterface of the proxy interface that the proxy class inherits the method through.
args - an array of objects containing the values of the arguments passed in the method invocation on the proxy instance, or null if interface method takes no arguments.
Arguments of primitive types are wrapped in instances of the appropriate primitive wrapper class, such as java.lang.Integer or java.lang.Boolean. 
Returns:
the value to return from the method invocation on the proxy instance. If the declared return type of the interface method is a primitive type,
 then the value returned by this method must be an instance of the corresponding primitive wrapper class; otherwise, it must be a type assignable to the declared return type. 
 If the value returned by this method is null and the interface method's return type is primitive, then a NullPointerException will be thrown by the method invocation on the proxy instance. 
 If the value returned by this method is otherwise not compatible with the interface method's declared return type as described above, 
 a ClassCastException will be thrown by the method invocation on the proxy instance. 
Throws: 
Throwable - the exception to throw from the method invocation on the proxy instance. The exception's type must be assignable either to any of the exception types declared in the throws clause of the interface method or to the unchecked exception types java.lang.RuntimeException or java.lang.Error. If a checked exception is thrown by this method that is not assignable to any of the exception types declared in the throws clause of the interface method, then an UndeclaredThrowableException containing the exception that was thrown by this method will be thrown by the method invocation on the proxy instance.
//----------
Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. 
To create a proxy for some interface Foo: 
     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
                                          new Class[] { Foo.class },
                                          handler);
 

A dynamic proxy class (simply referred to as a proxy class below) is a class that implements a list of interfaces specified at runtime when the class is created, with behavior as described below. A proxy interface is such an interface that is implemented by a proxy class. A proxy instance is an instance of a proxy class. Each proxy instance has an associated invocation handler object, which implements the interface InvocationHandler. A method invocation on a proxy instance through one of its proxy interfaces will be dispatched to the invoke method of the instance's invocation handler, passing the proxy instance, a java.lang.reflect.Method object identifying the method that was invoked, and an array of type Object containing the arguments. The invocation handler processes the encoded method invocation as appropriate and the result that it returns will be returned as the result of the method invocation on the proxy instance. 

static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) ;
Returns an instance of a proxy class for the specified interfaces that dispatches method invocations to the specified invocation handler. 
//------------
}
{
java中日期的用法：
//------------------
        String dateFormat = "yyyy-MM-dd HH:mm:ss";
        SimpleDateFormat slf = new SimpleDateFormat(dateFormat);
        String strDate = "2003-11-04 17:13:45";
        try {
            date = slf.parse(strDate);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        System.out.println("date=" + date);

        strDate = "2003-11-04";
        dateFormat = "yyyy-MM-dd";
        slf = new SimpleDateFormat(dateFormat);
        try {
            date = slf.parse(strDate);
        } catch (ParseException e) {
            e.printStackTrace();
        }
//-----------
}
//------------
{
java,正则表达式：
//---------
public final class Matcher
extends Object
implements MatchResult
An engine that performs match operations on a character sequence by interpreting a Pattern.
A matcher is created from a pattern by invoking the pattern's matcher method. Once created, a matcher can be used to perform three different kinds of match operations:

The matches method attempts to match the entire input sequence against the pattern.

The lookingAt method attempts to match the input sequence, starting at the beginning, against the pattern.

The find method scans the input sequence looking for the next subsequence that matches the pattern.

Each of these methods returns a boolean indicating success or failure. More information about a successful match can be obtained by querying the state of the matcher.
//------------------
}
//---------
{
//-------------
public class Object,该类有很多有意思的成员方法，记得研究;
public final Class<?> getClass()
Returns the runtime class of this Object. The returned Class object is the object that is locked by static synchronized methods of the represented class.
Returns:
The Class object that represents the runtime class of this object.
//----------
获取一种类型的Class<?>对象的方法：
1、调用该类型某个对象的getClass()方法;
2、<类型>.class;
3、Class.forName("<类型>");
//---------------
}
//---------
{
(伯乐在线 > 首页 > 所有文章 > 官方新闻 > 伯乐在线高薪招募兼职讲师，这是一个桃李满天下的讲台);
(伯乐在线 > 首页 > 所有文章 > C/C++ > 模板显式、隐式实例化和（偏）特化、具体化的详细分析);
CJSON,(http://blog.csdn.net/dawn_sf/article/details/70225382);
C++智能指针和循环引用,(http://blog.csdn.net/dawn_sf/article/details/70168930);
JSON,(http://www.json.org/);
}
//---------
gitlab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang
cr:http://cr.corp.qunar.com/D96457
//--------------------
2017-05-15,
{
java8和guava重复的东西用java8的;
BigDecimal;
为了保证数据计算的精度，可以应用专门的类或转换为整型;
Java8的SimpleDateFormat,Date是线程安全的;
}
{
设计自己的异常类，尽量不要作为RuntimeException的子类;
异步logger的性能比同步的性能好;
日志查看，集合kibana，凌镜系统;
结合qtrace使用;
}
{
Function,Predicate被lambda表达式取代;
高效的stream;
}
{
阅读JDK源码;
ArrayList,LinkedList,扩容;
HashMap,扩容;
}
{
WeakReference
常量池
System.gc();
安装JDK1.8;发邮件;
}
{
源码阅读：
1、搞清楚自己读源码的动机;
2、优秀框架或库的设计文档、架构图;
3、从自己感兴趣的点切入;
}
{
讲师建议：
多研读源码;
设计模式;
提高对自己的要求;
}
//-----------
{
问卷返利，（http://m.fanli.com/invite/markregyyg?acadid=11975&utm_source=sem_4ovm2tcs14）
//---------
}
//--------
在线API工具,包含多种API,（http://tool.oschina.net/apidocs/）;
//----------
{
注意：java中一个整型值默认是int，即使是溢出，也不会自动转换成long，需要在常量后加L才会转换成long。
例如
        long msOfYears1 = 5000L * 365 * 24 * 60 * 60 * 1000;
        long msOfYears2 = 5000 * 365 * 24 * 60 * 60 * 1000L;
        long msOfYears3 = 5000 * 365 * 24 * 60 * 60 * 1000;
        System.out.println("\tmsOfYear:" + msOfYears);
}
{
BigDecimal主要是为了解决数据值较大，浮点数精度丢失的问题;该类型的对象不仅保存数值，还保存精度;
        BigDecimal bigDecimal1 = BigDecimal.valueOf(0.58);
        BigDecimal bigDecimal2 = new BigDecimal("0.580");
        boolean bret1 = (bigDecimal1 == bigDecimal2);
        boolean bret2 = bigDecimal1.equals(bigDecimal2);
        int iret3 = bigDecimal1.compareTo(bigDecimal2);
        System.out.println("\tbigDecimal1=" + bigDecimal1 + ";bigDecimal2=" + bigDecimal2);
        System.out.println("bret1=" + bret1 +";bret2=" + bret2 + ";iret3=" + iret3);
BigDecimal无法保存无限浮点数，只有限定了位数后才能保存;
        bigDecimal1 = BigDecimal.valueOf(1L);
        bigDecimal2 = BigDecimal.valueOf(3L);
        bigDecimal = bigDecimal1.divide(bigDecimal2, MathContext.DECIMAL64);
        System.out.println("\tbigDecimal1=" + bigDecimal1 + ";bigDecimal2=" + bigDecimal2 + ";bigDecimal=" + bigDecimal);
}
//----------
加班报销;

//-------------------------
2017-5-16,
{
创建ArrayList时，最好指定预估的容量，降低扩容造成的性能开销;
List--ArrayList,LinkedList;
Set--HashSet,LinkedHashSet,TreeHashMap;
Map--HashMap,LinkedHashMap,TreeHashMap,线程安全的ConcurrentHashMap;
//-------
过滤器filter，测试的友好性，健壮性;
发生异常了，需要根据业务需要来指定处理方法;Runnable的run()方法不可抛出异常，只能自己处理，因为可能会影响线程池;
参数检验，能及时精准地报错;
发布第三方程序包时，尽可能地应用java原生数据结构;
//-------
Collection,明白各种集合的原理、优缺点、复杂度、适用场景;
不要盲目崇拜guava;
guava常用知识点：字符串、集合、函数式编程、cache;
}
//--------
C.2017-2期 Guava源码阅读计划,(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=155285478);
//-----------
guava内广泛应用的隐式类型推断;
Lists为何不提供filter方法;
//------------------
2017-05-17,
{
面授guava：
guava是一个工具包;
缓存的定义、设计，设计时的常见问题，如过期策略;
日志的功能：记录程序执行过程中的运行状态，避免后期纠纷，查找错误;
slf4j比System.out的优点：;
日志的级别;
缓冲和缓存有什么区别：都是为了平衡两个组件，缓冲;
阅读源码的方法：先看一个函数的功能，再看该函数分为那些功能模块，再看每个模块的实现细节;
//------
}
{
粟老师指示：
ArrayList，HashMap都有一个指定容量作为入参的构造函数。可以扩展了解一下。
guava cache还是比较常用的。总结一下几张过期方式，都适合用在什么场景。
//---
以后你把需要我批的作业地址给我。
否则容易漏掉
好吧，以后cr仅仅提交你做的代码，无关的就不用给我cr了。
}
//-----------
粟老师，5月10日的作业在这里：
http://cr.corp.qunar.com/D95757#71b75bed
这是截图：
是有两个作业，有点忙不过来，所以就做了一个。
//--------------------
设计模式是什么?它是一套理论,由软件界的先辈们(The Gang of Four:包括Erich
Gamma、Richard Helm、Ralph Johnson、John Vlissides)总结出的一套可以反复使用的经验,它可以提高代码的可重用性,增强系统的可维护性,以及解决一系列的复杂问题。做软件的
人都知道需求是最难把握的,我们可以分析现有的需求,预测可能发生的变更,但是我们不
能控制需求的变更。问题来了,既然需求的变更是不可控的,那如何拥抱变化呢?幸运的
是,设计模式给了我们指导,专家们首先提出了6大设计原则,但这6大设计原则仅仅是一系
列“口号”,真正付诸实施还需要有详尽的指导方法,于是23种设计模式出现了。

所有引用基类的地方必须能透明地使用其子类的对象。
原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。

//-----------
{
内部类，
内部类是定义在另一个类中的类;
内部类可以访问该类所在作用域内的一切数据;
内部类可以对同一个包中的其他类隐藏;
非static内部类实例对象有一个隐式引用用于引用实例化它的外围类的实例对象，用<OuterClass>.this表示;
定义非static内部类对象的表达式：<OuterClass>.<InnerClass> <InnerClass>=<OuterClassObject>.new <InnerClass>(...);
这时<OuterClass>.this引用<OuterClassObject>;
而static内部类没有;
}
//----------
cache,(http://www.cnblogs.com/lzrabbit/p/3734850.html);
guava API,(http://tool.oschina.net/apidocs/apidoc?api=guava);
//--------------------------

wangjintao_guava_2_title1
//---------


http://cr.corp.qunar.com/D97550
http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang
170517_王锦涛_作业
//----------

http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/%E7%8E%8B%E9%94%A6%E6%B6%9B_guava1

http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/%E7%8E%8B%E9%94%A6%E6%B6%9B_%E4%BD%9C%E4%B8%9A%E9%A2%982/
http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/%E7%8E%8B%E9%94%A6%E6%B6%9B_%E4%BD%9C%E4%B8%9A%E9%A2%982/

//-------
http://cr.corp.qunar.com/D97554
//------------
guava1作业CR地址:http://cr.corp.qunar.com/D97555

guava1作业Gitlab地址:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/%E7%8E%8B%E9%94%A6%E6%B6%9B_guava1

guava2作业CR地址:http://cr.corp.qunar.com/D97556

guava2作业Gitlab地址:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/%E7%8E%8B%E9%94%A6%E6%B6%9B_%E4%BD%9C%E4%B8%9A%E9%A2%982/

本日工作：

1、上午听韩聪聪老师讲解cache的设计方法、guava IO和guava cache的细节问题。

2、下午学习了工厂模式，做技术分享ppt。

3、完成java & guava三道作业题。
心得体会：

1、上午听课发现了自己对cache不明白，老师讲的cache相关的问题都不会。

2、作业题1的CityClient类内嵌套内部类Builder，一下子懵了，很久才明白过来。

3、看了 Iterator<E>和其他一些容器的源码之后对迭代器忽然恍然大悟了。
问题：
1、缓存系统很重要，但是还不明白它的设计、实现，分析方法，需要加强。
2、对http的相关知识不熟悉，作业题2的第一小题花了很长时间才明白。
明日计划：
1、在线学习mysql。
2、研究一下缓存系统的相关知识点。
wiki:http://wiki.corp.qunar.com/pages/viewpage.action?pageId=156649689
//-------------

{
mysql的远程访问：
//-----
在MySQL Server端设置远程访问功能： 
例如：
执行mysql 命令进入mysql 命令模式:
mysql> use mysql;   
mysql> GRANT ALL ON *.* TO admin@'%' IDENTIFIED BY 'admin' WITH GRANT OPTION;   
#这句话的意思 ，允许任何IP地址(上面的 % 就是这个意思，但不包含localhost)的电脑 用admin帐户  和密码（admin）来访问这个MySQL Server   
#必须加类似这样的帐户，才可以远程登陆。 root帐户是无法远程登陆的，只可以本地登陆。
//------
在mysql客户端执行远程访问：
例如：
$mysql -h 172.21.5.29 -u admin -p admin
}
{
//-------------------
mysqlshow -u root -p
//--------
可以跳过安全检查：
$mysqld_safe --user=linux2014 --skip-grant-tables --skip-networking
//-----
/tmp/mysql.sock
//------
cp /home/linux2014/linux2014/soft/mysql-5.1.72/support-files/my-small.cnf /etc/my.cnf
//--------------
}
{
mysql,提示Warning: World-writable config file '/etc/my.cnf' is ignored ，
大概意思是权限全局可写，任何一个用户都可以写。
mysql担心这种文件被其他用户恶意修改，所以忽略掉这个配置文件。这样mysql无法关闭。
修改/etc/my.cnf的权限即可：
#chmod 644 /etc/my.cnf
}
{
mysql启动提示mysql.host 不存在，启动失败的解决方法
解决办法 在运行初始化权限表的时候使用增加参数--datadir ，命令格式为： 
shell> scripts/mysql_install_db --user=mysql --datadir=/u01/mysql/data 
}
{
解决sudo: no valid sudoers sources found, quitting
设置普通用户可以使用sudo
chmod u+w /etc/sudoers
vim /etc/sudoers
找到这行 root ALL=(ALL) ALL,在他下面添加
username ALL=(ALL) ALL
但是返回后使用sudo时出现错误：sudo: no valid sudoers sources found, quittin
解决方法是需要将/etc/sudoers的权限恢复成440,就切换到普通用户下去执行
$chmod 440 /etc/sudoers
}
{
对所有用户有效在/etc/profile增加以下内容。只对当前用户有效在Home目录下的
.bashrc或.bash_profile里增加下面的内容：
(注意：等号前面不要加空格,否则可能出现 command not found)
#在PATH中找到可执行文件程序的路径。
export PATH =$PATH:$HOME/bin
#gcc找到头文件的路径
C_INCLUDE_PATH=/usr/include/libxml2:/MyLib
export C_INCLUDE_PATH
#g++找到头文件的路径
CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/include/libxml2:/MyLib
export CPLUS_INCLUDE_PATH
#找到动态链接库的路径
LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/MyLib
export LD_LIBRARY_PATH
#找到静态库的路径
LIBRARY_PATH=$LIBRARY_PATH:/MyLib
export LIBRARY_PATH
}
{
linux,gcc,动态库的搜索路径搜索的先后顺序是：
1.编译目标代码时指定的动态库搜索路径；
2.环境变量LD_LIBRARY_PATH指定的动态库搜索路径；
3.配置文件/etc/ld.so.conf中指定的动态库搜索路径；
4.默认的动态库搜索路径/lib；
5.默认的动态库搜索路径/usr/lib。
}
{
doxygen,源码分析工具;
}
//------------
{
2017-5-18,面授mysql,
//------------
SQL，字符串需要用引号，
where username = 'bob';
order by一定在最后;
SQL的书写次序和逻辑执行次序;
(
5,select
6,distinct
1,from
2,where
3,group by
4,having
5,order by
)
join查询怎么处理;
执行order by在select之后;
数据的逻辑存储，以页为单位;
外连接和内连接;
truncate <table_name>;直接清空，快捷;
drop <table_name>;直接清空，快捷;
ln,drop,rm;比较好的删除操作，避免mysql挂起;
delete from a4 where id;commit之后才会执行删除操作;
update a2 set order_id=405 and date='2017-02-17' where id=700;
合并插入(insert into)效率较高，要控制好规模;
load,insert select,锁等待;
AI,S,X,三种锁;
mysql5.6起提供将一个表迁移到另一个库内;
Email,账户权限、密码查看;
精确的浮点数用decimal;
(
text/blob使用建议：
预期长度varchar满足，应避免text;
应压缩后存入DB;
列值很长请考虑用单独拆表存放;
多个长列建议组合成一个字段使用;
)
}
{
2017-5-19面授课程:
//-----------
索引;
join on,where,添加索引;
尽量用简单的SQL语句;
mysql不支持函数索引;
select * from table_a;根据table_a的大小可知是否有性能瓶颈;
尽量不要让SQL计算;
in,not in都会使索引失效;
全表扫描不一定比索引慢;
子查询会加锁，影响效率;
order by,索引的最后一个;
左前缀;
索引扫描;
覆盖索引优化：seclect count(*);
前缀索引的可用价值不大;
//---------------
库表设计，
//--------
NULL的问题：
... is null;
... is not null;
//----------
控制事物规模大小;
//----------
数据恢复的条件：备份，日志;
//--------
推荐用书：
《mysql必知必会》
《高性能mysql》
《SQL反模式》
}
//----------
{
要在 Ubuntu 中启用root 帐号的话，那么不妨执行下面的操作：
重新设置 root 的密码：
$sudo passwd root #按照提示输入两次新的密码，并加以确认。
//----
修改口令(password)的方法：
$passwd <选项> <用户名>
//-------
查看passwd文件和shadow文件信息的方法：
$man 5 passwd
$man 5 shadow
//--------
/etc/passwd,用户账户信息。
/etc/shadow,可选的加密后的密码文件
 /etc/passwd-,/etc/passwd 的备份文件。
}
{
 <用户名>不在 sudoers 文件中。此事将被报告。
//--------
sudo命令可以让你以root身份执行命令，来完成一些我们这个帐号完成不了的任务。
其实并非所有用户都能够执行sudo，因为有权限的用户都在/etc/sudoers中呢。
我们可以通过编辑器来打开/etc/sudoers，或者直接使用命令visudo来搞定这件事情。
打开sudoers后，像如下那样加上自己的帐号保存后就可以了。
[plain] view plain copy 在CODE上查看代码片派生到我的代码片
//----
# User privilege specification  
root    ALL=(ALL:ALL) ALL  
linc    ALL=(ALL:ALL) ALL  
//----
sudoers的权限是0440，即只有root才能读。在你用root或sudo后强行保存（wq!）即可。
}
{
linux终端命令提示符：
<user_name>@<host_name>:<current_work_dir>$
}
{
查看用户信息：
$id [<user_name>]
查看当前用户信息：
$who
$whoami
}
{
linux用户管理:
常用配置文件
用户信息文件：  /etc/password
密码文件：      /etc/shadow
用户组文件：    /etc/group
用户组密码文件：/etc/gshadow
}
//------------
ln -s -T /home/linux2014/linux2014/soft_Install/mysql5172/libexec/mysqld mysqld
ln -s -T /home/linux2014/linux2014/soft_Install/mysql5172/libexec/mysqlmanager mysqlmanager
//------
{
SQL分为四类：
DCL,(grant,revoke,commit,commit,rollback);
DDL,(create,drop,alter),
DML,(insert,update,delete),
DQL,(select);
//------
规范化理论：
候选码、主码、外码、主属性、非主属性；
完全依赖、传递依赖；
范式；
完整性约束；
}
//---------
create table 图书表
(
id int unsigned auto_increment primary key,
book_id varchar(50) unique key,
author_id varchar(50),
book_name varchar(50),
pages int unsigned,
price decimal,
press varchar(50)
);

create table 作者表
(id int unsigned auto_increment primary key,
author_id varchar(50) unique key,
author_name varchar(50),
content text
);
//------------
2017-05-22,
{
(http://blog.csdn.net/v_july_v/article/details/6543438);
KMP,B-tree,
B+tree，定义，增删查改,增删边界关键字的处理。将节点读入内存，折半查找。在MySQL索引中的应用。
数据库索引，词法解析器，cJSON;
倒排索引,单词到文档的映射，大量存储问题；
Trie-tree,(应用案例：寻找热门查询，300万个查询字符串中统计最热门的10个查询。);
成组链接法；
外排序；
Bitmap;
KMP,BM;
}
{
strstr(),strcasestr();
statfs();
}
{
编译原理,(http://download.csdn.net/search?keywords=%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86);
}
{
MySQL编码,(http://cenalulu.github.io/mysql/mysql-mojibake/);
}
{
王锦涛,exam2程序：
GitLab: http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/exam2
CR: http://cr.corp.qunar.com/D98611
}
//--------------------
{
B-tree与数据库索引,
(http://blog.csdn.net/yang_yulei/article/details/26104921)
(http://blog.csdn.net/hijiankang/article/details/9166451)
}
//---------------------
2017-05-24,
{
nginx,
看过的视频知识要记录；
curl,dhc;
tcpdump,wireshark;
同步和异步；
QunarHttpclient;
Jackson;
}
//------------
{
tcpdump安装配置：
./configure --prefix=/home/linux2014/linux2014/soft_Install/tcpdump CFLAGS=-g3 CXXFLAGS=-g3
./configure --prefix=/home/linux2014/linux2014/soft_Install/libpcap CFLAGS=-g3 CXXFLAGS=-g3
/home/linux2014/linux2014/soft_Install/libpcap/lib
/home/linux2014/linux2014/soft_Install/libpcap/include
./configure --prefix=/home/linux2014/linux2014/soft_Install/bison
//-----
wireshark安装配置；
}
//-----------------
{
坚持目标，不可受干扰，一定要把STL、redis、nginx的源码搞明白，对于其他的大规模开源项目(三万行代码以上)，会用即可。
epoll;
http协议的C语言实现;
}
//--------------------
{
你好：
我的招商银行卡的信息如下：
银行卡号：6214830172152976
开户城市：北京
开户行：招商银行北京清河支行
}
//------------------
{
java&guava作业点评：
代码的隔离性，一个模块发生异常了，对其他模块的影响应尽可能小；
先搭建程序代码框架，再充实细节；
程序的并发安全；
}
明白。
//----------
{
王锦涛，http作业：
作业地址：http://wiki.corp.qunar.com/pages/viewpage.action?pageId=146885655
GitLab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/http
CR:http://cr.corp.qunar.com/D99301
}
//----------------
2017-05-25,
{
你的wiki就分为两部分，一部分是你记录你自己的日报，另一部分是你真正学了后，体会到的东西。
好的，我明白了，心得体会要写学习感悟，将学会的技术总结在wiki上。
明白，以后每次作业给您发三个地址：题目地址、gitlab地址、CR地址。
老师，我的mysql又出问题了，在客户端执行mysql命令会出现“段错误（核心已转移）”，您看看是怎么回事啊？
//-------
1.没学过没关心，以后会有人教你
2.我先将项目帮你改了，你按照这个方式去做以后的作业。
}
//-------------------
{
/home/linux2014/linux2014/soft_Install/mysql5556
}
{
sudo apt-get install libaio1S
}
{
《深入浅出MySQL++数据库开发、优化与管理维护+第2版+唐汉明.pdf》
}
//---------
{
韭菜鸡蛋锅贴(配韭菜鸡蛋锅贴20个&精品凉菜&果切&软饮/去哪儿网专供) 1份 已支付
J221
取餐时，您可以从东升科技园北领地B-6-4的 J221 架位直接取到您的餐点。 
}
//--------------
{
成功源码安装MySQL5.5.56:
//----------------
m4:
./configure --prefix=/home/linux2014/WJT_2017/soft_intsall/m4 CFLAGS=-g3 CXXFLAGS=-g3 && make && make install
export M4_PATH=/home/linux2014/WJT_2017/soft_intsall/m4/bin

安装bison:
./configure --prefix=/home/linux2014/linux2014/soft_Install/bison CFLAGS=-g3 CXXFLAGS=-g3
make && make install
./configure --prefix=/home/linux2014/WJT_2017/soft_intsall/bison CFLAGS=-g3 CXXFLAGS=-g3 && make && make install
export BISON_PATH=/home/linux2014/WJT_2017/soft_intsall/bison/bin

安装libncurses5-dev：

$sudo apt-get install libncurses5-dev

cmake:
./configure --prefix=/home/linux2014/WJT_2017/soft_intsall/cmake CFLAGS=-g3 CXXFLAGS=-g3 && make && make install
export CMAKE_PATH=/home/linux2014/WJT_2017/soft_intsall/cmake/bin

源码配置安装MySQL5.5.56：
$cd <mysql的解压后的文件夹内>
$mkdir bld
$cd bld
$cmake .. -DWITH_DEBUG=1 -DCMAKE_INSTALL_PREFIX=/home/linux2014/WJT_2017/soft_intsall/mysql5556
$make && make install
初始化mysql:
$cd /home/linux2014/WJT_2017/soft_intsall/mysql5556
$cp support-files/my-medium.cnf /etc/my.cnf
$scripts/mysql_install_db --user=linux2014 --basedir=/home/linux2014/WJT_2017/soft_intsall/mysql5556 --datadir=/home/linux2014/WJT_2017/soft_intsall/mysql5556/data

开启mysql服务进程：
$mysqld_safe --user=root
按提示初始化root用户的密码；
$mysql_secure_installation

之后就可以开启mysql服务进程：
$mysqld_safe --user=root

开启mysql客户端进程：
$mysql -h localhost -u root -p
按提示输入密码；

关闭mysql服务进程：
$mysqladmin -u root -p shutdown
根据提示输入密码即可。
}
//-----------------
mvn archetype:generate
//-----
java8,Stream,http分类;
老师您好，请您明天抽空批改一下我的作业吧。
题目和作业地址都在这个页面里：http://wiki.corp.qunar.com/pages/viewpage.action?pageId=156646596
//--------
{
maven,idea创建工程；
}
com.qunar.fresh2017
//------------------
{
数据库存储的物理结构，区、页、数据行。
数据表过大要分表，仅靠索引对效率的提升很有限；
查询表结构：describe  表名；
查询表索引：show index from 表名;
查看触发器：show triggers like '表名';
//-----
{
MySQL的默认编码是Latin1，不支持中文，要支持中午需要把数据库的默认编码修改为gbk或者utf8。
需要以root用户身份登陆才可以查看数据库编码方式(以root用户身份登陆的命令为：
$mysql -u root –p,之后两次输入root用户的密码)，查看数据库的编码方式命令为:
mysql>show variables like 'character%';

When BINARY values are stored, they are right-padded with the pad value to the specified length. The
pad value is 0x00 (the zero byte). Values are right-padded with 0x00 on insert, and no trailing bytes
are removed on select.
For VARBINARY, there is no padding on insert and no bytes are stripped on select.

For TEXT and BLOB columns, there is no padding on insert and no bytes are stripped on select.
If a TEXT column is indexed, index entry comparisons are space-padded at the end.

Each BLOB or TEXT value is represented internally by a separately allocated object. This is in contrast
to all other data types, for which storage is allocated once per column when the table is opened.
In some cases, it may be desirable to store binary data such as media files in BLOB or TEXT columns.

having针对分组的数据做筛选；

{NULL与任何值(包含NULL)按任何比较运算符对比时，返回值都是UNKNOWN，
SQL中只选择筛选条件为TRUE的行，而不选择值为UNKNOWN和FALSE的行；
1 IN (1,1,2,3,NULL),return TRUE;
1 NOT IN (1,1,2,3,NULL),return FALSE;
4 IN (1,1,2,3,NULL),return UNKNOWN;
4 NOT IN (1,1,2,3,NULL),return UNKNOWN;
NULL IN (1,1,2,3,NULL),return UNKNOWN;
NULL NOT IN (1,1,2,3,NULL),return UNKNOWN;
判断一个字段是不是NULL的正确方法：<field> IS NULL;
mysql>select 1 IN (1,1,2,3,NULL);
mysql>select NULL IN (1,1,2,3,NULL);
mysql>select NULL IS NULL;
mysql>select NULL=NULL;}

子查询：
in,exists;
<,=,>=;
all,any;

交叉连接::from <tableA> cross join <tableB> ;
内连接:from <tableA> [inner] join <tableB> on ...；
左外连接:from <tableA> left join <tableB> on ...;
右外连接:from <tableA> right join <tableB> on ...;
完全外连接:from <tableA> full join <tableB> on ...;

}
//-----
}
//-----------------
{
create table if not exists book_table
(
book_id varchar(50),
author_id varchar(50),
book_name varchar(50),
pages int unsigned,
price decimal,
press varchar(50),
primary key(book_id),
INDEX book_name_index using btree (book_name(40))
);

insert into book_table(book_id,author_id,book_name,pages,price,press) 
values('1','1','资治通鉴',3000,240.0,'大宋文学出版社'),
('2','2','三国演义',1800,199.5,'古典名著出版社'),
('3','3','水浒传',1950,201.5,'古典名著出版社');

drop table book_table2;
create table if not exists book_table2
(
book_id varchar(50) COMMENT '本书的唯一编号',
author_id varchar(50),
book_name varchar(150) CHARACTER SET utf8 NOT NULL ,
pages int unsigned,
price decimal(10,3),
press varchar(150) CHARSET utf8,
primary key(book_id,author_id),
INDEX book_name_index using btree (book_name(40))
);

insert into book_table2(book_id,author_id,book_name,pages,price,press) 
values
('1','1','资治通鉴',3000,240.0,'大宋文学出版社'),
('2','2','三国演义',1800,199.5,'古典名著出版社'),
('3','3','水浒传',1950,201.5,'古典名著出版社'),
('4','4','曾国藩家书',1091,130.82,'中华人民文学出版社');
('5','5','史记',4020,343.31,'华夏史学出版社'),
('6','6','红楼梦',1100,199.47,'湖南文学出版社'),
('7','7','康熙帝国',750,71.6,'中原文学出版社'),
('8','8','梦溪笔谈',591,33.82,'大宋文化研究出版社');


select length(book_name) from book_table2;

drop table prize_table;
create table prize_table
(
book_id VARCHAR(50) CHARSET utf8,
prize_committee VARCHAR(20) CHARSET utf8  COMMENT '评奖委员会',
cup_type ENUM('金奖','银奖','铜奖','鼓励奖') CHARSET utf8,
cup_date DATE,
PRIMARY KEY(book_id,prize_committee,cup_date),
INDEX cup_type_index USING BTREE (cup_type)
);

delete from prize_table;
insert into prize_table values
('1','人民文学评奖委员会','金奖','1999-08-12'),
('2','古典文学评奖委员会','鼓励奖','2001-12-13'),
('3','茅盾文学评奖委员会','银奖','2004-03-18'),
('4','华夏文学评奖委员会','铜奖','2011-11-27'),
('1','人民文学评奖委员会','金奖','2009-08-12'),
('2','古典文学评奖委员会','铜奖','2007-12-13'),
('3','鲁迅文学评奖委员会','鼓励奖','2014-03-18'),
('4','鲁迅文学评奖委员会','银奖','2016-11-27'),
('3','人民文学评奖委员会','金奖','1999-08-12'),
('1','古典文学评奖委员会','鼓励奖','2001-12-13'),
('2','茅盾文学评奖委员会','银奖','2004-03-28'),
('2','华夏文学评奖委员会','铜奖','2011-11-07'),
('4','人民文学评奖委员会','金奖','2009-08-22'),
('1','古典文学评奖委员会','铜奖','2007-12-23'),
('2','鲁迅文学评奖委员会','鼓励奖','2014-04-18'),
('4','古典文学评奖委员会','金奖','2001-10-27'),
('1','古典文学评奖委员会','银奖','2017-12-23'),
('2','鲁迅文学评奖委员会','金奖','2004-04-18'),
('4','古典文学评奖委员会','鼓励奖','2006-07-20');

select count(*),cup_type,prize_committee,cup_date from prize_table where cup_date > '2008-01-01' group by cup_type ;
select count(*),cup_type,prize_committee from prize_table where cup_type='金奖' group by prize_committee;


drop table author_table;
create table author_table
(
author_id VARCHAR(50),
author_name VARCHAR(50) CHARSET utf8,
content TEXT CHARSET utf8,
PRIMARY KEY(author_id),
INDEX content_index USING BTREE (content(20))
);

insert into author_table values
('1','司马光','北宋名相，著名的文学家、史学家、政治家。曾极力反对王安石的变法维新！'),
('2','罗贯中','元末明初文学家，对三国历史深有研究！'),
('3','施耐庵','明朝著名文学家、方士，精通奇门遁'),
('4','曾国藩','清朝后期著名文学家、军事家、政治家，在家乡办团练，历经多年，镇压太平军。在文学方面造诣也很高。');


select author_name as '金奖作者姓名' from author_table where author_id in (select author_id from book_table2 where book_id in (select book_id from prize_table where cup_type='金奖'));

SELECT author_name FROM author_table
WHERE EXISTS(
SELECT * FROM book_table2
WHERE author_id = book_table2.author_id AND EXISTS 
(SELECT * FROM prize_table WHERE book_id = book_table2.book_id));

select book_table2.book_name,book_table2.book_id,prize_table.book_id,prize_table.cup_type,prize_table.cup_date 
from book_table2 join prize_table
on book_table2.book_id = prize_table.book_id;

select book_table2.book_name,book_table2.book_id,prize_table.book_id,prize_table.cup_type,prize_table.cup_date 
from book_table2 cross join prize_table
on book_table2.book_id = prize_table.book_id;

select book_table2.book_name,book_table2.book_id,prize_table.book_id,prize_table.cup_type,prize_table.cup_date 
from book_table2 inner join prize_table 
on book_table2.book_id = prize_table.book_id;

START TRANSACTION;
INSERT INTO prize_table VALUES
('4','山东文学评奖委员会','鼓励奖','2005-07-21'),
('5','中南文学评奖委员会','金奖','2016-09-20'),
('2','华北文学评奖委员会','银奖','2014-09-12');
COMMIT;

START TRANSACTION;
INSERT INTO prize_table VALUES
('4','泰山文学评奖委员会','金奖','2004-11-21');
SELECT * FROM prize_table WHERE prize_committee = '泰山文学评奖委员会';
ROLLBACK;

START TRANSACTION;
SHOW DATABASES;
CREATE DATABASE wjt_db2;
ROLLBACK;
SHOW DATABASES;

SAVEPOINT savepoint1;
INSERT INTO prize_table VALUES
('7','泰山文学评奖委员会','金奖','2011-11-21');
SELECT * FROM prize_table WHERE prize_committee = '泰山文学评奖委员会';
ROLLBACK TO SAVEPOINT savepoint1;
RELEASE SAVEPOINT savepoint1;

ROLLBACK TO savepoint1;
}
//---------
2017-05-27,
{
exam2评讲：
最终目标是什么，目前手中有什么条件，中间如何衔接；
//-----------
问题的边界、性能、所需资源；
千万不要掉进细节内；
先理解整体框架，再逐个解决每个细节，如果某个细节无法直接解决，再想变通的办法；
//-----------
抛出异常需要耗费较多的系统性能；
检验参数；
//-----------
不要格式化现有代码，因为容易引起混乱；
带着批判的态度听指示；
//------
SPRING源码；
选择数据库连接池主要考虑性能；
}
//---------
{
现在应该新建一个maven project，将之前的每次作业都作为一个module。

不用，你仔细看我发的图。
	14:53:09
https://qt.qunar.com/file/v2/download/temp/18080dd55f3fd48112a16191477807f9.png?name=18080dd55f3fd48112a16191477807f9.png&file=file/18080dd55f3fd48112a16191477807f9.png&fileName=file/18080dd55f3fd48112a16191477807f9.png&w=325&h=91&u=jintao.wang&k=619861495858271935455 
	14:53:19
在这里面加上各个mudule。
	14:53:29
然后改改各个module的pom就行了。
	14:53:47
照猫画虎。下次我检查这个。
}
//--------------
{
com.qunar.fresh2017
}
{
ubuntu设置双显示器的相关方法：
$xrandr
两个显示器显示同样的东西：
$ xrandr --output <辅助显示器>  --same-as <主显示器> --auto
例如：$xrandr --output DP1  --same-as eDP1 --auto
}
{
xrandr常用命令（这里的VGA与LVDS分别换成第1步中的设备名，如VGA1、LVDS1）：
xrandr --output VGA --same-as LVDS --auto
打开外接显示器(--auto:最高分辨率)，与笔记本液晶屏幕显示同样内容（克隆）
xrandr --output VGA --same-as LVDS --mode 1280x1024
打开外接显示器(分辨率为1280x1024)，与笔记本液晶屏幕显示同样内容（克隆）
xrandr --output VGA --right-of LVDS --auto
xrandr --output eDP1 --right-of DP1 --auto
打开外接显示器(--auto:最高分辨率)，设置为右侧扩展屏幕
xrandr --output VGA --off
xrandr --output eDP1 --off
关闭外接显示器
xrandr --output VGA --auto --output LVDS --off
打开外接显示器，同时关闭笔记本液晶屏幕（只用外接显示器工作）
xrandr --output VGA --off --output LVDS --auto
关闭外接显示器，同时打开笔记本液晶屏幕 （只用笔记本液晶屏）
}
{
RFC editor,search,(http://www.rfc-editor.org/search/rfc_search.php);
MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。
MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。
}
{
idea中指定一个文件夹的功能的方法：右键，在菜单中选择；
}
//---------------------
{
echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
}
//--------
{
idea2017,
view->toolbar;
删除一个module的方法：File->Project Structure->Project Settings->Modules，选中要删除的module，点击“-”，点击下方的apply按钮，在右键删除即可;
ctrl+F,搜索字符串；
ctrl+N,搜索一个类;
View->ToolWindows->Project/Structure,可用于修改显示结构;
View->ToolButtons,可用于显示terminal;
选定一个代码区，ctrl+?,可将该区内的代码注释掉;
idea,右侧，Maven Project-> <Module> ->LifeCycle下的命令；
idea,F2键可用于查找程序语法错误；
idea,alt+insert,可用于生成set()和get()方法，构造方法，根据选择的参数情况生成重载的构造函数;
IntelliJ IDEA提供了一个快捷操作Cmd + Shift + T作为类和测试之间的导航;
IDEA，鼠标左键选中，Shift+Tab，可将一个区域内的代码集体左移；Tab，可将一个区域内的代码集体右移；
ctrl+shift+A,显示动作或选项类帮助信息;
idea下maven的刷新功能；
}
{
csdn知识图谱,(http://lib.csdn.net/base/computervison);
(http://lib.csdn.net/wspba/structure/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/node/13363121),
(http://lib.csdn.net/wspba/336835/chart/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BC%80%E5%A7%8B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0),
源码超市,(http://download.csdn.net/album/detail/783);
阿里巴巴集团技术丛书——淘宝一线团队实践,(http://download.csdn.net/album/detail/1013);
//----
java内存模型,(http://blog.csdn.net/qq_37810594/article/details/72802280#t5);
//----
redis分布式缓存,(http://blog.csdn.net/pi9nc/article/details/17719737),
(http://blog.csdn.net/lc0817/article/details/51853671),
(http://blog.csdn.net/u014352080/article/details/49130995);
//----
基于neighbourhood sensitive hashing 就是近邻敏感哈希的knn查找；基于近邻敏感哈希nsh 的knn查找。
(http://www.csto.com/p/89437);
(http://www.csto.com/project/list);
//----
}
//---------------
{
ln
find
grep
//----------
bash: ./idea.sh: 符号连接的层数过多
解决办法是对于目标要用绝对路径；
//----
grep [<options>] <pattern> <file_list,separated by blank>
-i,
-v,--invert-match,
--color[=never,always,auto]
-r
-R
-n
//----------
查找文件
find ./ -type f

查找目录
find ./ -type d

查找名字为test的文件或目录
find ./ -name test

查找名字符合正则表达式的文件,注意前面的‘.*’(查找到的文件带有目录)
find ./ -regex .*so.*\.gz
查找文件名匹配*.c的文件
find ./ -name \*.c
查找权限为644的文件或目录(需完全符合)
find ./ -perm 664

查找用户/组权限为读写，其他用户权限为读(其他权限不限)的文件或目录
find ./ -perm -664
查找文件size小于10个字节的文件或目录
find ./ -size -10c

查找文件size等于10个字节的文件或目录
find ./ -size 10c

查找文件size大于10个字节的文件或目录
find ./ -size +10c

查找文件size小于10k的文件或目录
find ./ -size -10k

查找文件size小于10M的文件或目录
find ./ -size -10M

查找文件size小于10G的文件或目录
find ./ -size -10G
//------------------
}
{
curl,
telnet
wireshark
tcpdump
}
//------------
neighbourhood sensitive hashing 
//-------------------
./configure --prefix=/home/linux2014/WJT_2017/soft_intsall/glib220 CFLAGS=-g3 CXXFLAGS=-g3 && make && make install


/home/linux2014/WJT_2017/soft

/home/linux2014/WJT_2017/soft_intsall/my_soft


/home/linux2014/WJT_2017/soft_intsall/my_soft
//---------------
./configure --prefix=/home/linux2014/WJT_2017/soft_intsall/wireshark_226 CFLAGS=-g3 CXXFLAGS=-g3 && make && make install
/home/linux2014/WJT_2017/soft_intsall/wireshark_226
//-------------

http://blog.jobbole.com/84429/
http://ftp.acc.umu.se/pub/GNOME/sources/glib/2.20/
//----------
{
HTTP协议基础：
(https://wenku.baidu.com/view/b9556a75580216fc710afd21.html);
}
//-------------
/home/linux2014/WJT_2017/soft_intsall/my_soft
//----------
ln -s -t /home/linux2014/WJT_2017/soft_intsall/my_soft /home/linux2014/WJT_2017/soft/qtalk/qtalk
//----------

ln -s -T /home/linux2014/WJT_2017/soft/qtalk/run.sh qtalk
ln -s -T /home/linux2014/WJT_2017/soft/qtalk/LocalMan LocalMan
//------------
{
空行CRLF就是用”/r/n”表示;
主机名由称为 DNS 服务器或域名服务器的服务器映射到 IP 地址。DNS 代表域名服务。在大型网络中，许多 DNS 服务器可以相互协作，以提供主机名和 IP 地址之间的映射。
http://baike.baidu.com/link?url=M-QJnCyN4pFyb-mSlVBVqUQURFm3DzOG_c2sUTHjh-2QZOVtjb0LNjxP3tUW_MN0jldqZKbyBd4vDsxzK5X-aa
}
//------------
{

servlet作业:
题目：http://wiki.corp.qunar.com/pages/viewpage.action?pageId=156646585
CR: http://cr.corp.qunar.com/D100323
GitLab: http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/servlet



servlet作业相关的数据库操作:

/*创建数据库train_db用于存储作业需要用的数据库表*/
CREATE DATABASE train_db;

USE train_db;

应该这样建表：

CREATE TABLE user_table
(
name VARCHAR(20) COMMENT '用户名',
password VARCHAR(20) COMMENT '密码',
nickname VARCHAR(20) COMMENT '昵称',
email VARCHAR(20) COMMENT '邮箱',
PRIMARY KEY(name,password)
)
COMMENT '创建用户表user_table，用于存放用户的信息，包含用户名name、密码password、昵称nickname、邮箱email，其中name和password作为主码';

/*向数据库user_table数据表内插入三个用户的数据用于测试*/
INSERT INTO user_table VALUES
('tiangaoyundan','linux2014','tgyd','15702418795.com'),
('yundanfengqing','15236286736wjt','ydfq','15236286736@163.com'),
('wjt_2017','15236286736wjt','wjt_2017','1746019810@qq.com');
//-------------
/*应该这样建表:*/
CREATE TABLE user_table
(
id INT UNSIGNED AUTO_INCREMENT COMMENT '用户的唯一标识',
name VARCHAR(20) CHARSET UTF8 NOT NULL COMMENT '用户名',
password VARCHAR(20) CHARSET UTF8 NOT NULL COMMENT '密码',
nickname VARCHAR(20) CHARSET UTF8 COMMENT '昵称',
email VARCHAR(20) CHARSET UTF8 COMMENT '邮箱',
PRIMARY KEY(id),
UNIQUE INDEX name_index USING BTREE (name) COMMENT '为字段name创建唯一索引，便于按name查找用户'
)
COMMENT '创建用户表user_table，用于存放用户的信息，包含用户名name、密码password、昵称nickname、邮箱email；新增一个id字段用于唯一标识用户，作为主键';

/*向数据库user_table数据表内插入三个用户的数据用于测试*/
INSERT INTO user_table VALUES
(NULL,'tiangaoyundan','linux2014','tgyd','15702418795.com'),
(NULL,'yundanfengqing','15236286736wjt','ydfq','15236286736@163.com'),
(NULL,'wjt_2017','15236286736wjt','wjt_2017','1746019810@qq.com');
}
{
粟老师点评servlet+jdbc作业：
1、SQL语句要加注释，SQL语句内的COMMENT；
2、用户表需要新增一个id字段用于唯一标识用户，作为主键；将用户名设置为唯一索引；
}
明白
那主键应该怎么设置啊？

前几天做作业时，我考虑到：如果两个用户的用户名和密码都相同，就有可能。

对于每个属性要加一个comment
我是觉得用户表内任意两个用户的用户名和密码都不能相同，如果相同了，一个用户就可以用自己的用户名和密码进入别人的主页，这样就危险了。

感觉用户名就那么几个字符，不可能太长，就像人名一样会重复。

都运行通过了。这次是哪里错了呀？
为什么要用唯一索引呢？要求的是user_table表内的name不重复，只要将name字段设置为UNIQUE不就可以了吗？
讲过，没具体要求语法格式。
我的是按MySQL mannual(5.4版)上的语法写的，该怎么写才好啊？

在字段上增加unique，实际上会建立一个唯一索引。
我们一般都不这么做。
唯一索引的话会显式地建立


{
将字段设置为UNIQUE实际上是为该字段建立了一个唯一索引:
查看索引的方法是：
mysql> show index from <tblname>;
mysql> show keys from <tblname>;
}
{
mysql,查看一个数据表的静态信息的方法:
mysql>show full fields/columns from <table_name>;
//------
在元数据的表里面查看:
Select COLUMN_NAME 列名, DATA_TYPE 字段类型, COLUMN_COMMENT 字段注释
from INFORMATION_SCHEMA.COLUMNS
Where table_name = 'companies'##表名
AND table_schema = 'testhuicard'##数据库名
AND column_name LIKE 'c_name'##字段名
//-----
查看数据表创建SQL语句的方法:
show  create  table  <tablename>;
//-------
取整个数据库的所有表信息（包含表名，表注释，表类型等等）：
SELECT table_name, table_type, engine
FROM information_schema.tables
WHERE table_schema = 'db5' //table_schema是数据库名
ORDER BY table_name DESC;
//---
show table status;
//-----
}
//------------
2017-05-31,
{
你提交的代码不对啊。
08:40:12
粟屹松撤回了一条消息
粟屹松 08:41:51
	
首先，你servlet这个子module和project的module定义不匹配
粟屹松 08:42:25
	
其次，你不知道怎么将它们一起提交是个什么意思。在idea里面，将这个目录提交就行了啊。
上次我帮你改了exam2的了，你照着我的pmo改就行了，一点都不难啊。
08:43:31
粟屹松 08:43:31
	
你没有按照我的要求去做。
}
{
好的。


我执行的操作是：
右键项目名字->Git->Repository->push,
结果是被拒绝了，如下图：

不知道是这是怎么回事？
dev_training2
我是git clone了一个dev_training2，用idea将这个目录导入，然后逐个创建每个作业模块，复制源代码文件。

老师，您是不是要求每个module的依赖都放在本module的pom.xml文件内啊？

只是给出了提交拒绝的提示，不知道该怎么查看原因。
}
//-------
{
Spring,
注解,
日志，
以注解方式装载spring容器，
AOP,java代理;
java静态代理、动态代理、Cglib动态代理；
//------
spring boot,
启动依赖；智能装配；应用监控；
war包、jar包；
测试时不要用main()方法，而用test()方法；
starter按需添加Maven仓库查询；
shift+shift,查找类库;
作业用spring-boot实现；
}
//---------------
{
idea提交作业的方法：
1、执行git clone命令，得到文件夹，在idea内导入该文件夹，构成一个project，完成作业；
2、在idea内，View->ToolBars，打开终端，执行如下命令：
git pull origin jintao.wang  把远程仓库与本地仓库合并，检查冲突，并解决；
完成作业；
git pull origin jintao.wang  把远程仓库与本地仓库合并，检查冲突，并解决；
提交：
git add *
git commit -am "王锦涛，作业整理"    把本地修改推送到本地暂存区
git push --set-upstream origin jintao.wang 把暂存区推送到远程仓库
git add * && git commit -am "王锦涛，servlet作业" && git push --set-upstream origin jintao.wang

git add mybatis
git commit -m '王锦涛，修改后的mybatis作业'
//-----------
GitLab删除一个模块的方法：
git rm -r --cached <模块名>
git commit -m “...”
git push
//-----
例如：
git rm -r --cached servlet
git commit -m “...”
git push
//-------------------
}
{
git add maven_work
git commit -m "王锦涛,maven练习题"
//------
王锦涛,maven练习题
git add maven_wjt
git commit -m "王锦涛，maven练习题，对应模块maven_wjt，readme文件内有详细说明"
git push --set-upstream origin jintao.wang
//-----
base:82c9db086
44f2c16ab
//-------
老师，请您抽空批改一下我的maven练习题作业吧。
题目:http://wiki.corp.qunar.com/pages/viewpage.action?pageId=157365022
GitLab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/maven_wjt
CR:http://cr.corp.qunar.com/D101994
}
//-------
{
idea,maven,
每一个module的pom.xml内(<dependencies>)要包含本module所需的依赖，但不必写版本号；project的pom.xml内(<dependencyManagement>)要包含所有module所需的依赖及其版本号。
}
{
老师，以前的作业都整理好了，请您抽空再检查一下。
整理后的作业GitLab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang
作业题目网址：http://wiki.corp.qunar.com/pages/viewpage.action?pageId=155285466
}
//----------
{
Spring MVC,不要将Request和Response放在一起；
基于Spring boot创建一个工程；
}
//----------
{
【名企互访】之微博来访
讲师： 田瑞林  张欣  王竹峰  
时间： 2017-06-07 周三 14:30-18:00
地点： 东升B区 培训教室一
}
//------------
{
2017-06-02，
//---------------------
http://blog.csdn.net/harvic880925/article/details/44679239
HTTP协议、URI;
(http://blog.csdn.net/fujinlong520/article/details/50922229)
http://localhost:34675/home/linux2014/WJT_2017/projects/CXX_Projects/wjt_train/train1/src/main?user=linux2014&pwd=123456
//---------
将一个字符串的内容赋给变量:sscanf();
//--------
{
Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。到这里，大家应该有个大概的了解了，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。
GET,提交的数据存放在URI；POST提交的数据存放在报文主体；
}
}
{
http://mail.163.com/js6/main.jsp?sid=sCcHcPxxnaZoFMWQUPxxQqrCBLsLwAcg&df=webmail163#module=welcome.WelcomeModule%7C%7B%7D
curl -d "param2=nickwolfe&param2=12345" http://localhost:48780/login.cgi
curl -X GET http://localhost:45390/CXX_Projects/Test.java?user=name&&pwd=123456
}
{
gdb,
set follow-fork-mode [parent|child]
parent: fork之后继续调试父进程，子进程不受影响。
child: fork之后调试子进程，父进程不受影响。
}
//--------------
{
王锦涛本周学习总结：
一、学习中遇到的问题：
这段时间的课程servlet、tomcat、Spring以前没接触过，感觉很吃力。
时间紧张，作业还没来得及重构。

二、对授课老师的评价：
授课老师都很尽心负责，但是时间有点紧，讲得有些东西没能及时消化。

三、与导师沟通情况：
导师很认真细致，对每一个疑难知识点的回答都很细致，讲得很清楚。

四、本组同学存在的问题：
对本周课程学习心得的沟通较少。

五、下周分享计划：
Spring的依赖注入和AOP技术解析。
}
//-----------
{
java动态代理;
java.lang.reflect.Proxy 
代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象。
}
{
6217,9949,5000,4932,271;
}
//------
{
In software development, functions that span multiple points of an application are
called cross-cutting concerns.

Whereas DI helps you decouple your application
objects from each other, AOP helps you decouple cross-cutting concerns from the
objects that they affects.

With AOP , you still define the common functionality in one
place, but you can declaratively define how and where this functionality is applied
without having to modify the class to which you’re applying the new feature. Cross-
cutting concerns can now be modularized into special classes called aspects.

Likewise, aspects have a purpose—a
job they’re meant to do. In AOP terms,
the job of an aspect is called advice.
Advice defines both the what and the when of an aspect.

A join point is a point in
the execution of the application where an aspect can be plugged in. This point could
be a method being called, an exception being thrown, or even a field being modified.
These are the points where your aspect’s code can be inserted into the normal flow of
your application to add new behavior.

If advice defines the what and when of aspects, then pointcuts define the where. A
pointcut definition matches one or more join points at which advice should be woven.
Often you specify these pointcuts using explicit class and method names or through
regular expressions that define matching class and method name patterns.
advice---what and when;
joint point---where,opportunity;
point cut---where,in fact;point-cuts define which join points get advised;

An aspect is the merger of advice and pointcuts.

An introduction allows you to add new methods or attributes to existing classes.

Weaving is the process of applying aspects to a target object to create a new proxied
object. The aspects are woven into the target object at the specified join points.

Spring aspects are implemented as proxies that wrap the target
object. The proxy handles method calls, performs additional aspect logic, and
then invokes the target method.


}
//--------
{
有的。servlet module的pom.xml内第34行，有mysql-connector-java。
servlet module所属的project的pom.xml内第49行，有mysql-connector-java。
cr上显示的pom.xml和本机上的pom.xml内容不一致，
看到了。
应该是因为冲突没有解决好的缘故吧？
是有问题。
这个应该怎么解决啊？
好的。

你git冲突没解决就提交，说明git用的有问题。
	
你先解决冲突。以后细心点了。你的cr都没法运行。
	
你提交给我的不是静态有问题的代码，而应该是可执行的程序。

老师，新添加了CR地址，请您抽空再检查一下servlet作业吧。
servlet作业题目:http://wiki.corp.qunar.com/pages/viewpage.action?pageId=156646585
servlet作业GitLab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/servlet
servlet作业CR:http://cr.corp.qunar.com/D101550
}
//-------------
{
        <!--<dependency>-->
            <!--<groupId>org.eclipse.jetty.orbit</groupId>-->
            <!--<artifactId>javax.servlet</artifactId>-->
        <!--</dependency>-->
        
                    <dependency>
                <groupId>javax.servlet</groupId>
                <artifactId>servlet-api</artifactId>
                <version>3.0.1</version>
                <type>pom</type>
            </dependency>
}
//---------
{
        String xmlFileName = "spring_thoughts.xml";
        ApplicationContext appContext = new ClassPathXmlApplicationContext(xmlFileName);
        Thinker volunteer = (Thinker) appContext.getBean("thinkerID");/*只能返回接口类型*/
}
{
DROP DATABASE spring_db;

CREATE DATABASE spring_db;

use spring_db;

CREATE TABLE user_table
(
id INT UNSIGNED AUTO_INCREMENT COMMENT '用户的唯一编号，作为用户表的主键',
name VARCHAR(20) CHARSET UTF8 NOT NULL COMMENT '用户名，不可为空',
age TINYINT UNSIGNED COMMENT '年龄',
remark VARCHAR(100) CHARSET UTF8 COMMENT '备注',
available ENUM('可用','不可用') CHARSET UTF8 COMMENT '可用性',
email VARCHAR(30) CHARSET UTF8 COMMENT '电子邮箱',
gender ENUM('男','女') CHARSET UTF8 COMMENT '性别',
hobby VARCHAR(80) CHARSET UTF8 COMMENT '兴趣爱好',
createTime DATETIME COMMENT '用户信息创建时间',
lastModifyTime DATETIME COMMENT '用户信息最近修改时间',
PRIMARY KEY(id),
UNIQUE INDEX name_index USING BTREE (name)
)
COMMENT '用户表包含六个属性，分别是编号id、用户名name、出生日期birthDate、电子邮箱email、性别gender、兴趣爱好hobby，用户信息的创建时间，用户信息的最后修改时间，其中id作为主键，用户名唯一且不空';

INSERT INTO user_table VALUES
(NULL,'克林顿',75,'美国前总统','可用','lidunke@qunar.com','男','旅行、影视、政治',NOW(),NOW()),
(NULL,'姚明',41,'NBA篮球巨星','可用','mingyao@qunar.com','男','篮球',NOW(),NOW()),
(NULL,'布什',70,'美国前总统','可用','shibu@qunar.com','男','商业、影视、政治',NOW(),NOW()),
(NULL,'希拉里',73,'美国著名政治家，社会活动家','可用','lalixi@qunar.com','女','社会活动、政治',NOW(),NOW()),
(NULL,'周星驰',63,'无厘头电影大师','可用','xingchizhou@qunar.com','男','拍电影',NOW(),NOW());
}
{
CREATE TABLE user_table (
  id int unsigned NOT NULL AUTO_INCREMENT COMMENT '用户唯一id，作为主键',
  name varchar(30) NOT NULL DEFAULT '' COMMENT '用户姓名',
  sex char DEFAULT ''　COMMENT '用户性别',
  age tinyint unsigned DEFAULT 0　COMMENT '用户年龄',
  password varchar(30) DEFAULT '' COMMENT '密码',
  nick_name varchar(30) DEFAULT '' COMMENT '昵称',
  email varchar(50) DEFAULT '' COMMENT '邮箱',
  create_time timestamp NOT NULL COMMENT '用户记录创建时间',
  last_update_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '用户记录最近更新时间',
  is_deleted tinyint unsigned NOT NULL DEFAULT 0　COMMENT　'用户记录逻辑删除标识,{0:未被删除,1:已经删除}',
  remark varchar(255) NOT NULL DEFAULT '' COMMENT '备注',
  PRIMARY KEY (id)
) COMMENT='用户表';
}
//------
{
http://www.cnblogs.com/sld666666/p/5439528.html
}
//-----------
{
vim文件中查看vim编辑的文件的编码方式：
:set fileencoding
以指定的编码方式打开某个文件:
vim file.txt -c "e ++enc=<编码方式>"
在Vim中直接进行转换文件编码,比如将一个文件转换成utf-8格式
:set fileencoding=utf-8
}
{
od命令;
gedit可以设置为多种类型的文件；
lsof -i :<port_no>，可用于查看正在使用该端口的进程；
top命令是Linux下常用的性能分析工具，比如cpu、内存的使用，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。 
ps可用于查看进程信息；
ps -ef | grep <port_no>
}
{
gedit,
帮助文档,F1;
侧边栏；
字符编码；
}
{
pom的继承，根pom;
占位符；；
profile;
groupID,artifactID,
版本号都应该用占位符，这样便于修改和维护；
快照版本;
maven依赖的传递性;
maven依赖冲突的解决办法：就近、第一声明优先；
Qunar要求显式处理依赖冲突；
jar包依赖冲突的一般处理原则：尽量用较新版本，也即是较成熟的新版本，因为较新版本修复了更多的bug，且向后兼容；
尽量不要用exclude，因为容易影响其他模块；
Duplicated Classes-----完全相同的两个类出现在不同的两个包内；如何处理：exclude掉一个；白名单；
maven生命周期：clean,default,site；
maven是一个插件框架；常用的工具插件；
pom.xml内对同一个库的依赖只能出现一次，若出现多次，则出错。
}
//-----------
{
mvn tomcat7:run
http://localhost:8080/user/list
还有些问题，在调试。
lsof -i :8080
//---------
数据库的用户名和密码都是root
}
//--------
//----------
WebSecurityConfigurerAdapter
}
{
老师您好，我是这次参加培训的应届生，我的spring作业总是运行出错，您能不能帮我解决一下啊？
行。等您有空时帮着看看吧。
那个文本文件(spring_wjt.txt)就是错误日志。是我在idea下的控制台运行命令mvn tomcat7:run > ../../spring_wjt.txt得到的。
老师您好，今天有时间吗？
//-------
好的，谢谢老师啊？您的工位在哪里呀？今晚几点您有空啊？
}
//-------------
{
mybatis,
(http://www.mybatis.org/mybatis-3/getting-started.html),
(http://www.mybatis.org/mybatis-3/zh/statement-builders.html);
}
{
SQL注入,
(http://blog.csdn.net/qq_34858648/article/details/52750038);
}
//--------------
{
CREATE TABLE `employee` (
`id` int(11) NOT NULL AUTO_INCREMENT COMMENT '自增主键',
`staff_id` int(11) unsigned DEFAULT '0' COMMENT '员工工号',
`name` varchar(20) NOT NULL DEFAULT '' COMMENT '中文姓名',
`mobile` varchar(20) NOT NULL DEFAULT '' COMMENT '电话号码',
`area` varchar(32) NOT NULL DEFAULT '' COMMENT '工作地区,例如北京、上海等',
`gender` tinyint(1) NOT NULL DEFAULT '1' COMMENT '性别,1 男 2 女',
`is_valid` tinyint(1) NOT NULL DEFAULT '1' COMMENT '1:在职2:离职',
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='员工信息表'

CREATE TABLE `holiday` (
`id` int(11) NOT NULL AUTO_INCREMENT COMMENT '自增主键',
`staff_id` int(11) unsigned DEFAULT '0' COMMENT '员工工号',
`sick_num` int(10) NOT NULL DEFAULT '0' COMMENT '病假',
`annual_num` int(10) NOT NULL DEFAULT '0' COMMENT '年假',
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='员工假期表';

CREATE TABLE `leave_holiday` (
`id` int(11) NOT NULL AUTO_INCREMENT COMMENT '自增主键',
`staff_id` int(11) unsigned DEFAULT '0' COMMENT '员工工号',
`start_date` datetime NOT NULL DEFAULT '2000-01-01 00:00:00' COMMENT '开始时间',
`end_date` datetime NOT NULL DEFAULT '2000-01-01 00:00:00' COMMENT '开始时间',
`day_num` int(20) NOT NULL DEFAULT '0' COMMENT '使用库存',
`type` tinyint(1) NOT NULL DEFAULT '1' COMMENT '1:年假2:病假',
`area` varchar(32) NOT NULL DEFAULT '' COMMENT '工作地区,例如北京、上海等',
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='员工请假表';
//-----
INSERT INTO employee(staff_id,name,mobile,area,gender,is_valid) VALUES
(30,'李明博','13933715586','北京',1,1),
(34,'萨达姆','15936715586','北京',1,1);
//-----
insert into leave_holiday(staff_id,start_date,end_date,day_num,type,area) values
 (35,'2016-04-05','2016-04-06',1,2,'马尔代夫'),
  (35,'2016-12-07','2016-12-08',1,1,'马尔代夫'),
   (35,'2016-12-05 11:10:20','2016-12-05 18:08:25',7,1,'马尔代夫'),
  (35,'2016-05-07','2016-05-08',7,2,'马尔代夫');
//--------
insert into leave_holiday(staff_id,start_date,end_date,day_num,type,area) values
 (8,'2016-11-04','2016-11-06',3,1,'马尔代夫');
 //------
 select employee.staff_id,employee.name,sum(leave_holiday.day_num) 
 from employee join leave_holiday 
 on employee.staff_id = leave_holiday.staff_id 
 group by leave_holiday.staff_id 
 order by sum(leave_holiday.day_num) desc;
 
/*请病假最多的员工*/
select staff_id,sum(day_num) 
from leave_holiday 
where type = 2
group by staff_id having sum(day_num) >= all
(select sum(day_num) 
from leave_holiday 
where type=2 
group by staff_id);

select staff_id,sum(day_num)
from leave_holiday 
where type = 2 
group by staff_id 
order by sum(day_num) desc limit 1 offset 0;

select employee.name,employee.staff_id,sum(leave_holiday.day_num)
from employee join leave_holiday on employee.staff_id = leave_holiday.staff_id 
where leave_holiday.type = 2
group by leave_holiday.staff_id 
having sum(leave_holiday.day_num) >= all(
select sum(day_num) 
from leave_holiday
);

select employee.name,employee.staff_id,sum(leave_holiday.day_num)
from employee join leave_holiday on employee.staff_id = leave_holiday.staff_id 
where leave_holiday.type = 2 
group by leave_holiday.staff_id 
order by sum(leave_holiday.day_num) desc limit 1 offset 0;
//----------
1,
INSERT INTO employee(staff_id,name,mobile,area,gender,is_valid) VALUES
(8,'韩梅梅','15588866691','香港',2,1);
INSERT INTO holiday(staff_id,sick_num,annual_num) VALUES
(8,10,10);
2,
select * from employee where staff_id=1;

SELECT employee.staff_id,employee.name,employee.mobile,employee.area,employee.gender,employee.is_valid,
leave_holiday.start_date,leave_holiday.end_date,leave_holiday.day_num,leave_holiday.type,leave_holiday.area
FROM employee left join leave_holiday ON employee.staff_id = leave_holiday.staff_id WHERE employee.staff_id = 1;
3,
select * from leave_holiday where staff_id=2;
4,
update leave_holiday set day_num=3 where staff_id=3;
5,
delete from employee where is_valid = 2;
6,
select count(*) from employee where name like '张%' and is_valid = 1;
7,
select staff_id from leave_holiday where type = 1 group by staff_id having sum(day_num) < 3;
8,
9,
10,
select sum(day_num) from leave_holiday where staff_id = 2;
select sum(day_num) from leave_holiday where staff_id = 4;
select annual_sum from holiday  where staff_id = 2;
select annual_sum from holiday  where staff_id = 4;
11,
从人道的角度出发，没必要检查该员工的剩余病假天数。
如果剩余病假天数不足，则在数据表holiday内将该员工的病假剩余天数设置为0。
否则，在数据表leave_holiday内插入该员工的请病假记录,在数据表holiday内将该员工的病假剩余天数减少请病假的天数。
//---------------

}
//-------------
{
CREATE DATABASE spring_db;
USE spring_db;

CREATE TABLE user_table (
  id INT NOT NULL AUTO_INCREMENT COMMENT '用户唯一标示id,用作主键',
  userName VARCHAR(20) NOT NULL default '' COMMENT '用户名',
  sex VARCHAR(1) NOT NULL default '' COMMENT '性别',
  age SMALLINT NOT NULL default 0 COMMENT '年龄',
  phoneNo VARCHAR(20) NOT NULL default '' COMMENT '手机号',
  email VARCHAR(30) NOT NULL default '' COMMENT '电子邮件',
  createTime DATETIME NOT NULL COMMENT '用户记录创建时间',
  lastUpdateTime DATETIME NOT NULL COMMENT '用户记录最近更新时间',
  remark VARCHAR(255) NOT NULL default '' COMMENT '备注',
  isDelete TINYINT NOT NULL default 0 COMMENT '用户记录是否已删除',
  PRIMARY KEY (id)
)CHARSET=UTF8;

insert into user_table(userName, sex, age, phoneNo, email, createTime, lastUpdateTime, remark) values
('克林顿','男',73,'19821052450','lidunke@gmail.com','2017-06-03','2017-06-03','美国前总统'),
('希拉里','女',71,'13621052730','lalixi@gmail.com','2017-06-03','2017-06-03','美国前国务卿'),
('布什','男',68,'13856052050','shibu@gmail.com','2017-06-03','2017-06-03','美国前总统'),
('本拉登','男',72,'13117052050','ladengben@gmail.com','2017-06-03','2017-06-03','塔利班前头目'),
('马克龙','男',41,'13009052050','kelongma@gmail.com','2017-06-03','2017-06-03','法国总统'),
('普京','男',58,'13800782050','jingpu@gmail.com','2017-06-03','2017-06-03','俄罗斯总统'),
('默克尔','女',63,'13888852050','keermo@gmail.com','2017-06-03','2017-06-03','德国总理'),
('朴槿惠','女',67,'13966652050','jinhuipiao@gmail.com','2017-06-03','2017-06-03','韩国前总统'),
('安倍晋三','男',69,'15521052050','jinsananbei@gmail.com','2017-06-03','2017-06-03','日本首相'),
('文在寅','男',62,'16621052050','zaiyinwen@gmail.com','2017-06-03','2017-06-03','韩国总统'),
('卢武铉','男',75,'17721052050','wuxuanlu@gmail.com','2017-06-03','2017-06-03','韩国前总统'),
('金正恩','男',38,'17712052050','zhengenlu@gmail.com','2017-06-03','2017-06-03','朝鲜最高领导人');

}
//----------
{
CSDN,(http://blog.csdn.net/?aspxerrorpath=/teamlet/article/details/5410991);
DBSCAN,(http://blog.csdn.net/tiandd12/article/details/72898316);
mysql,RUNOOB.COM,(http://www.runoob.com/mysql/mysql-sql-injection.html);
}
//-------
{
粟老师点评maven作业：用maven命令行生成一个父子工程：
用命令行完成之后，需要在project的pom.xml和本module的pom.xml内检查父子关系标签：
例如， project的pom.xml内：
<module>maven_wjt</module>

本module的pom.xml内:
  <parent>
    <groupId>com.qunar.fresh2017</groupId>
    <artifactId>dev_training2</artifactId>
    <version>1.0-SNAPSHOT</version>
  </parent>
  //----------
}
//------------
{
数据库事务：
四大特性（ACID）；
//--------
MySQL数据库的事务：
MyISAM不支持事务，InnoDB支持事务;
默认情况下，MySQL将以自动提交模式运行，这意味着没一条小命令都将当做一个只有一条命令的事物来执行。
如果要让mysql支持支持事务，只需要修改数据引擎（alter table person type=INNODB）
使用start transaction或者begin命令来开启一个事物,使用commit,或者rollback来结束事物。
START TRANSACTION [WITH CONSISTENT SNAPSHOT]
BEGIN [WORK]
COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
SET autocommit = {0 | 1}
//--------
Some statements cannot be rolled back. In general, these include data definition language (DDL)
statements, such as those that create or drop databases, those that create, drop, or alter tables or
stored routines.
//----------
}
{
SAVEPOINT identifier
ROLLBACK [WORK] TO [SAVEPOINT] identifier
RELEASE SAVEPOINT identifier
InnoDB supports the SQL statements SAVEPOINT, ROLLBACK TO SAVEPOINT, RELEASE
SAVEPOINT and the optional WORK keyword for ROLLBACK.
The SAVEPOINT statement sets a named transaction savepoint with a name of identifier. If the
current transaction has a savepoint with the same name, the old savepoint is deleted and a new one is
set.
All savepoints of the current transaction are deleted if you execute a COMMIT, or a ROLLBACK that does
not name a savepoint.
The ROLLBACK TO SAVEPOINT statement rolls back a transaction to the named savepoint without
terminating the transaction.
The RELEASE SAVEPOINT statement removes the named savepoint from the set of savepoints of the
current transaction. No commit or rollback occurs.
}
{
SET TRANSACTION Syntax:
//--------------------
SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL
{
REPEATABLE READ
| READ COMMITTED
| READ UNCOMMITTED
| SERIALIZABLE
}
//----
SELECT @@GLOBAL.tx_isolation, @@tx_isolation;
SET TRANSACTION ISOLATION LEVEL without GLOBAL or SESSION is not permitted while there is
an active transaction.
}
//------
{
语法：FROM table1 LEFT/RIGHT/FULL/INNER/CROSS JOIN table2 ON table1.field1 compopr table2.field2  
说明：table1, table2参数用于指定要将记录组合的表的名称。 
field1, field2参数指定被联接的字段的名称。且这些字段必须有相同的数据类型及包含相同类型的数据，但它们不需要有相同的 
名称。 
compopr参数指定关系比较运算符："="， "<"， ">"， "<="， ">=" 或 "<>"。 
}
//-------------
{
mybatis，
//--------------
update对多参数；
mybatis缓存在实际中一般不用，了解即可；
乐观锁、悲观锁；
mybatis不用存储过程；
逆向工程，自动生成POJO和mapper文件；
//----------
}

//--------
{
CREATE
[DEFINER = { user | CURRENT_USER }]
TRIGGER trigger_name
trigger_time trigger_event
ON tbl_name FOR EACH ROW
trigger_body

trigger_time: { BEFORE | AFTER }
trigger_event: { INSERT | UPDATE | DELETE }
//----
delimiter //
CREATE TRIGGER holiday_after_insert_leave_holiday_trigger
AFTER INSERT
ON leave_holiday
FOR EACH ROW
BEGIN
  IF NEW.type = 1 THEN
     UPDATE holiday SET holiday.annual_num = holiday.annual_num - NEW.day_num WHERE staff_id = NEW.staff_id;
  ELSEIF NEW.type = 2 THEN
     UPDATE holiday SET holiday.sick_num = holiday.sick_num - NEW.day_num WHERE staff_id = NEW.staff_id;   
  END IF;
END; //
delimiter ;
//--------------
delimiter //
CREATE TRIGGER holiday_after_insert_employee_trigger
AFTER INSERT
ON employee
FOR EACH ROW
BEGIN
  INSERT INTO holiday(staff_id,sick_num,annual_num) VALUES(NEW.staff_id,10,10);
END; //
delimiter ;
//------
CREATE TRIGGER holiday_after_insert_employee_trigger2
AFTER INSERT
ON employee
FOR EACH ROW
BEGIN
  START TRANSACTION
  INSERT INTO holiday(satff_id,sick_num,annual_num) VALUES(NEW.staff_id,10,10);
  COMMIT
END; //
//-------
CREATE TRIGGER holiday_after_delete_employee_trigger
AFTER DELETE
ON employee
FOR EACH ROW
BEGIN
    DELETE FROM holiday WHERE staff_id = OLD.staff_id; 
    DELETE FROM leave_holiday WHERE staff_id = OLD.staff_id;
END; //
//-----------
insert into employee(staff_id,name,mobile,area,gender,is_valid) values
(42,'村山富市','13519302431','上海',1,1),
(43,'曼德拉','15509302431','上海',1,1);


insert into leave_holiday(staff_id,start_date,end_date,day_num,type,area) values
(42,'2016-12-08','2016-12-10',2,1,'上海'),
(42,'2016-12-18','2016-12-19',1,2,'上海'),
(43,'2016-12-25','2016-12-28',4,1,'北京'),
(42,'2016-12-18','2016-12-19',1,2,'上海'),
(43,'2016-12-25','2016-12-28',3,1,'北京');


delete from employee where staff_id = 40 or staff_id = 41;
//--------
}
{
mysql,SQL,dilimiter的用法：
用某种符号表示提交SQL命令:
mysql>delimiter <其他符号>
例如：
mysql>delimier //
mysql>demiliter ;
}
//----------
{
1、敢于不断挑战自我，以高标准要求自己的人
2、重视OO，重视方法论，努力挖掘事物本质，期望获取对复杂问题的拆解、抽象能力的人
3、积极主动，勇于承担责任
熟悉掌握常用的Java类库及框架，如多线程、并发处理、I/O与网络通讯;
mysql,redis,,开源软件源码及心得;
研究过 http 协议、搜索引擎、缓存、jvm 调优、序列化、nio、RPC 调用框架等，并且有相关实践经验;
有较强的逻辑/概率思维能力，善于分析、归纳、解决问题；能够独立或带队进行项目开发;
}
//--------
 {
 mvn clean tomcat7:run
 }
//----------------
2017-06-09,
//-----
{
/学习记录/spring/spring学习笔记;
spring,(http://www.iteye.com/blogs/subjects/Spring_jiwenke);
}
//-----------
{
mybatis的xxxMapper.xml文件内>、>=、<、<=符号不可直接应用，要做如下转义；
<![CDATA[
                and price <= #{endPrice}
                ]]>
//----------               
<![CDATA[ id >= #{param1} AND id <= #{param2} ]]>                
}
//----
{
xxxMapper.xml:
parameterType
@Param

resultType
resultMap
//------------
}
//------
{
多表查询，namespace的设置,结果如何保存,Mappper.java如何实现；
typeAilias
xxxMapper.xml文件内的字符串组合:concat()函数；例如：
concat('%',#{roleName},'%');
//---------
mybatis编程，当多表联合查询时：
结果集可用Map，或定义一个综合类；
}
//-------------
{
/*一个将整数转换为汉字读音的程序，不难，但是需要事先实验，总结规律，这也是编程的一般方法*/
//------
class IntReader{
    public static String getAnIntStringForLT10000(int n){
        String retStr = "";
        String[] digitWeight={"","十","百","千"};
        String[] digitName={"一","二","三","四","五","六","七","八","九"};
        int i = 0,j = 0;
        List<String> pinyinList = new LinkedList<String>();
        String str = null;
        for(j = 0;n >= 1;n /= 10,j++){
            i = n%10;
            if(i > 0){
                str = digitName[i-1] + digitWeight[j];
                pinyinList.add(str);
            }
        }
        for(i=pinyinList.size()-1;i >= 0;i--){
            retStr += pinyinList.get(i);
        }
        return retStr;
    }
    public static String getAnIntString(int n){
        String retStr = "";
        int i = 0,t = 0;
        if(n == 0){
            retStr = "零";
        }
        else{
            if(n < 0){
                retStr = "负";
                n = -n;
            }
            String[] weight = {"","万","亿"};
            int j = 0;
            String tstr = null;
            List<String> pinyinList = new LinkedList<String>();
            for(j = 0;n >= 1;n /= 10000,j++){
                t = n % 10000;
                if(t > 0){
                    tstr = getAnIntStringForLT10000(t);
                    tstr += weight[j];
                    pinyinList.add(tstr);
                }
            }
            for(i=pinyinList.size()-1;i >= 0;i--){
                retStr += pinyinList.get(i);
            }
        }
        return retStr;
    }
}/*class IntReader*/
//-------
}
//-------------
2017-06-12，
/------------
{
老师，我的mybatis作业已提交，请您抽空批改一下吧！
mybatis作业：
题目地址:http://wiki.corp.qunar.com/pages/viewpage.action?pageId=156646599
CR:http://cr.corp.qunar.com/D103028
GitLab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/mybatis
}
//------------
{
MySQL存储过程和函数：
查看方法：
方法一： 
select `name` from mysql.proc where db = 'your_db_name' and `type` = 'PROCEDURE' //存储过程 
select `name` from mysql.proc where db = 'your_db_name' and `type` = 'FUNCTION' //函数 
方法二： 
show procedure status where db='<db_name>'; //存储过程 

SHOW PROCEDURE STATUS WHERE db='servant_591up' 

show function status; //函数 
//----------
CREATE
[DEFINER = { user | CURRENT_USER }]
PROCEDURE sp_name ([proc_parameter[,...]])
[characteristic ...] routine_body
//----
proc_parameter:
[ IN | OUT | INOUT ] param_name type
//---
characteristic:
COMMENT 'string'
| [NOT] DETERMINISTIC
//----------
CALL sp_name([parameter[,...]])
CALL sp_name[()]
//----------
}
{
MySQL data type:
M indicates the maximum display width for integer types.
For floating-point and fixed-point types, M is the total number of digits that can be stored.

MySQL interprets length specifications in character column definitions in character units. This applies
to CHAR, VARCHAR, and the TEXT types.

Specifying the CHARACTER SET binary attribute for a character string data type causes the
column to be created as the corresponding binary string data type: CHAR becomes BINARY,
VARCHAR becomes VARBINARY, and TEXT becomes BLOB.

In MySQL, NUMERIC is
implemented as DECIMAL, so the following remarks about DECIMAL apply equally to NUMERIC.
//------
整型:bit,tinyint,smallint,int,bigint;
精确浮点型:decimal,numeric;
近似浮点型:float,double;

日期时间型:date,time,datetime;

字符串型:char,varchar,text;
二进制型:binary,varbinary,blob;

枚举、集合;

java type,JDBC type,MySQL type;
//-----------
}
{
idea的测试方法：(ctrl+shift+T)生成测试框架；LOGGER.info(String,Object)输出相关对象；
重载一个类的String toString()函数可以定制输出。
这里讲一下以下几个常用的注解：
@Test：把一个方法标记为测试方法
@Before：每一个测试方法执行前自动调用一次
@After：每一个测试方法执行完自动调用一次
@BeforeClass：所有测试方法执行前执行一次，在测试类还没有实例化就已经被加载，所以用static修饰
@AfterClass：所有测试方法执行完执行一次，在测试类还没有实例化就已经被加载，所以用static修饰
@Ignore：暂不执行该测试方法

@Test的两个属性
excepted,用来测试异常的;
timeout,用来测试性能的，就是测试一个方法能不能在规定时间内完成;
}
{
POJO,java bean;
//--------------
POJO的名称有多种，pure old java object 、plain ordinary java object 等。
按照Martin Fowler的解释是“Plain Old Java Object”，从字面上翻译为“纯洁老式的java对象”，但大家都使用“简单java对象”来称呼它。
POJO的内在含义是指那些没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。
//--------
Java Bean： 就是一个普通的Java 对象， 只不过是加了一些约束条件。  声明的 property 是 private 的，
 并且，实现了 Get 和set 方法。
//-----------
POJO让开发者可专注于业务逻辑和脱离框架的单元测试。除此之外， 由于POJO并不须要继承框架的类或实现其接口，开发者能够极其灵活地搭建继承结构和建造应用。
POJO的意义就在于它的简单而灵活性，因为它的简单和灵活，使得POJO能够任意扩展，从而胜任多个场合，也就让一个模型贯穿多个层成为现实。
先写一个核心POJO，然后实现业务逻辑接口和持久化接口，就成了Domain Model； UI需要使用时，就实现数据绑定接口，变成VO（View Object）。
//----------
}
{
//---
107租房,(http://www.107room.com/);
mobile:15702418795
pwd:linux2014
//------
{
昌平 育新花园 2层
 159-1087-4621
 15910874621
//----------
海淀 冬晴园 2层 1300元/月
  132-4122-8704
 18910585613
 本人微信可随时咨询
邻居都是上班族 朝九晚五 无不良嗜好
小区是个三室一厅 家电齐全全，小区北边就是上地地铁站，东边是北京体育大学，
西边有上地南路，硅谷亮城，中国民生银行，精装修 采光通风都非常好 直接拎包入住
//--------
 海淀 冬晴园 2层 1680元/月
 151-0163-8705
 15101638705
 //--------
 海淀 融泽嘉园6号院 1层 1980元/月
海淀 回龙观新村 9层 1480元/月
   135-2091-8551
//--------
 海淀 柳浪家园 2层 1900元/月
 182-1049-2939
 18210492939
//----------------
 海淀 菊园 2层 1800元/月
小区周围分布着软件园百度联想大厦，上地硅谷亮城，农业大学等，是在这里工作人士的首选之地。 欢迎随时来电咨询，随时可以去看房
 151-0163-8705
 15101638705
//----------
 海淀 朱辛庄 3层 1650元/月
 海淀 肖家河回迁房 7层 1900元/月
 海淀 肖家河 2层 1900元/月(近维亚，农大)
 海淀 上地佳园 6层 1800元/月
 134-3923-3090
 649444981
 a2620588000
 //---------
 海淀 西二旗铭科苑 1层 1300元/月
  185-1137-2211
 18511372211
//-------------
 海淀 百旺茉莉园 7层 1700元/月
 海淀 柳浪家园 7层 1900元/月
 海淀 智学苑 3层 1800元/月
 海淀 大牛坊一期 9层 1600元/月
 海淀 唐家岭新城 7层 1600元/月
 海淀 唐家岭新城 7层 1800元/月
海淀 菊园 3层 1800元/月
海淀 百旺茉莉园 7层 1700元/月
 185-6777-7646
 18567777646
//----------肖家河
上地；
海淀 图景家园 2层 2000元/月
 139-0392-9958
 13903929958
//------------
海淀 昌艺园 6层 1850元/月
海淀 菊园 2层 1800元/月
 151-0163-8705
 15101638705
//--------------
海淀 颐和山庄 3层 1450元/月(近百度;非常优惠;近16号线)
海淀 冬晴园 2层 1600元/月
189-1058-5613
18910585613
//---------
维亚大厦附近地铁站:10号线;
//-------------
二拨子新村西区，龙兴园北区；
{
//-----------
榴莲公寓,
(http://bj.mgzf.com/room/1918840.shtml?page=list)
海淀区-太月园-三居室-南卧-RoomC-18.0㎡
 距10号线知春路476米，步行约5分钟 
 2周前发布  合租
付一  1600 元/月
//----
(http://bj.mgzf.com/room/2016472.shtml?page=list)
丰台区-怡海花园富泽园-三居室-南卧-RoomA-13.0㎡
 距9号线科怡路632米，步行约7分钟 
 1周前发布  合租
付三  1350 元/月
//------
(http://bj.mgzf.com/room/1784515.shtml?page=list)
丰台区-造甲街-三居室-南卧-RoomB-14.0㎡
 距9号线丰台南路597米，步行约6分钟 
 2周前发布  合租
付三  1400 元/月
//--------------
(http://bj.mgzf.com/room/1745107.shtml?page=list)
朝阳区-弘善家园十里河-四居室-东卧-RoomD-15.0㎡
 距10号线十里河524米，步行约6分钟 
 2周前发布  合租
付三  1700 元/月 明细 
管家 / 李辉
 4000606868 转 64774  预 约 看 房
//--------

}
//--------------
}
}
//----------
{
重写equals()，也要重写hashCode()；
尽量重写toString()方法,要保证实用性和性能；
java创建一个对象的方法：new;反射;克隆;反序列化.
反射的性能较低，解决方案可参考spring;
深拷贝和浅拷贝;
String型的比较用equals(),而非==;compareTo()没有检测null;
String不可变，任何对String的改变都会生成新对象;StringBuilder,StringBUffer;
float/double不适合精确计算，只适合科学计算和工程计算；BigDecimal;

封箱类型的应用场景:
1、作为集合类的键值;
2、null;

编码格式：
1、全部用UTF-8;
2、BOM头问题;

1、常见的外部资源;
(1)database/cache;
(2)dubbo/http;
2、后果：
外部依赖会导致系统被拖垮或出错;

HashMap在并发条件下的死锁;
SimpleDateFormat线程不安全;

java.util.concurrent.*

尽量降低锁的粒度;

synchronized;
目标、级别、粒度;

qunar异步处理组件:kmq;
线程安全的判断标准:不同线程之间是否共享公共资源;

张志均
}
//------------
看spring+mybatis demo代码里有很多注解，
这样只需定义接口，而不用实现类，就可访问数据库。
而且用spring+mybatis的方法在XML文件内配置的SQL语句很灵活，但是这些都还没搞懂，所以说“spring功能很强，但是迷失在注解内”。

标红的那些模块是我曾经做过的，提交到GitLab上，系统报告“sonar执行异常”，
就用git rm -r命令删除了，又在idea内强制删除了这些模块，
忘了在project pom.xml内手动删除。
//----------
{
静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。
      1、 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。
      2、 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。
      3、 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。
      通过上面的分析，他们三者的执行顺序应该为：静态代码块 >main()函数> 构造代码块 > 构造函数。
}
//----------
{
在使用BigDecimal类来进行计算的时候，主要分为以下步骤：
1、用float或者double变量构建BigDecimal对象。
2、通过调用BigDecimal的加，减，乘，除等相应的方法进行算术运算。
3、把BigDecimal对象转换成float，double，int等类型。
BigDecimal b1 = new BigDecimal(Double.toString(0.48));
BigDecimal b2 = BigDecimal.valueOf(0.48);
 对于常用的加，减，乘，除，BigDecimal类提供了相应的成员方法。
1 public BigDecimal add(BigDecimal value);                        //加法
2 public BigDecimal subtract(BigDecimal value);                   //减法 
3 public BigDecimal multiply(BigDecimal value);                   //乘法
4 public BigDecimal divide(BigDecimal value);                     //除法
进行相应的计算后，我们可能需要将BigDecimal对象转换成相应的基本数据类型的变量，可以使用floatValue()，doubleValue()等方法。
//-------------
JDK的描述：1、参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。
        2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal("0.1") 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。
        3、当double必须用作BigDecimal的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用Double.toString(double)方法，然后使用BigDecimal(String)构造方法，将double转换为String。要获取该结果，请使用static valueOf(double)方法。
//-------
}
//-------------
{
mybatis,
一定要注意到$和#的区别，$的参数直接输出，#的参数会被替换为?，然后传入参数值执行。
}
//----------
{
spring入门经典:
//-------------------
P9,IoC;
P10,依赖注入;
P16,spring IOC容器;
P18,配置和使用容器;
P27,@Service注解,@Repository注解将一个类定义为bean，默认bean的名称是类名首字母小写的字符串；
@Autowired引起在spring容器内自动查找和装配；
Spring自动扫描类路径内存在的类，尝试在启动期间识别带有@Component注解的类及其派生类；
xml文件内的元素<context:component-scan/>的作用是扫描类路径内的类，通过相关联的注解创建Bean并注入依赖项；
spring容器，ApplicationContext;
AnnotationConfigApplicationContext;
<bean>
P33，依赖解析;
//-------
1、@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的<beans>，作用为：配置spring容器(应用上下文)
2、@Bean标注在方法上(返回某个实例的方法)，等价于spring的xml配置文件中的<bean>，作用为：注册bean对象
(1)、@Bean注解在返回实例的方法上，如果未通过@Bean指定bean的名称，则默认与标注的方法名相同； 
(2)、@Bean注解默认作用域为单例singleton作用域，可通过@Scope(“prototype”)设置为原型作用域； 
(3)、既然@Bean的作用是注册bean对象，那么完全可以使用@Component、@Controller、@Service、@Ripository等注解注册bean，当然需要配置@ComponentScan注解进行自动扫描。
//---------
p62,html,http,uri;
WebApplicationContext;
P63,HandlerMapping,ViewResolver;
Spring MVC的处理器映射(将URL映射到控制器类):
(1),ControllerClassNameHandlerMapping;
(2),BeanNameUrlHandlerMapping;
Spring MVC是一个分层的,基于动作的Java Web开发框架,分为三层:model,view,controller;
用户的每一个请求都关联程序内的一个动作,主要是通过将请求URI映射到类的成员方法实现的,
同时将请求参数映射到成员方法的参数。
Spring MVC提供了一种用户请求数据到Java程序数据的映射机制，只需将用户请求参数名和Java类的成员名匹配即可。
Dispatcher Servlet综合应用处理器映射(handler mapping,HandlerMapping)和视图解析器(view resolver,ViewResolver)来
确定用户请求应该用什么业务逻辑以及处理后应该向用户返回什么内容。
处理器映射、处理器适配器以及视图解析器的默认实现在文件DispatcherServlet.properties内。
P67,<context:component-scan>扫描指定目录下的bean并注册到应用程序上下文，<context:annotation-config />激活bean中定义的注解；
处理器映射将请求的URL与使用@RequestMapping注解的处理器方法相匹配，并将该URL的请求路径与@RequestMapping的value特性相比较；
web.xml->/WEB-INFO/{servlet}-servlet.xml;
{
web.xml,
web.xml 的加载顺序是：ServletContext -> context-param -> listener -> filter -> servlet ，
而同个类型之间的实际程序调用的时候的顺序是根据对应的 mapping 的顺序进行调用的;
}
P66,spring的要素:
pom.xml,
web.xml,
WEB-INF/<servlet-name>-servlet.xml,
@Controller,@RequestMapping,
WEB-INF/pages,

javax.servlet.ServletResponse
javax.servlet.Servlet

JSP,
定义表格内的表头单元格。
HTML 表单中有两种类型的单元格：
表头单元格 - 包含表头信息（由 th 元素创建）
标准单元格 - 包含数据（由 td 元素创建）
th 元素内部的文本通常会呈现为居中的粗体文本，而 td 元素内的文本通常是左对齐的普通文本。

tomcat server也是有作用空间的，部署时要指定其作用空间，相关的页面要指定该作用空间；
Spring+MyBatis,(http://blog.csdn.net/gebitan505/article/details/44455235/),
(http://blog.csdn.net/zoutongyuan/article/details/41379851/),
(http://www.cnblogs.com/best/p/5638827.html),
(http://blog.csdn.net/zhou2s_101216/article/details/51116326);
//--------------------
}
//-----------
{
exam3作业，讲师讲评：

整体划分，估算工作量；

文件差分；
行级，字符串，效率；

登录验证方式，
权限模型；
QSSO
编码规范；
}
{
mybatis,
//-----------
    <insert id="insertAccountBatch" >
        INSERT INTO
        account_table(ownerName,password,balance,accessTime,locked)
        VALUES
        <foreach collection="list" index="index" item="item" open="" separator="," close="" >
            (#{item.ownerName},#{item.password},#{item.balance},#{item.accessTime},#{item.locked})
        </foreach>
    </insert>
//---------------
}
{

}
//------------
{
Spring Framework 开发参考手册,(http://shouce.jb51.net/spring/);
//------
刚开始学习jsp的程序员都会遇到这样一个问题,就是网页上的中文无法显示.总结了以下几条方法。 
在jsp页中加入一条语句： 
<%@ page contentType="text/html;charset=gb2312" %>中文显示就正常了。 
//----------
}
//-------------
{
war模式：将WEB工程以包的形式上传到服务器 ；
war exploded模式：将WEB工程以当前文件夹的位置关系上传到服务器；
（1）war模式这种可以称之为是发布模式，看名字也知道，这是先打成war包，再发布；
（2）war exploded模式是直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。
}
//----------
{
idea调试的快捷键:
F7,执行一步,进入当前方法内;
F8,执行一步,将当前当前方法当做一个整体;
F9,执行到下一个断点处;
shift+F8： 逐过程step over（如果当前行有方法调用，这个方法将被执行完毕返回，然后到下一行）
shift+F7： 逐语句step into向下执行一行。如果该行有自定义方法，则运行进入自定义方法（不进入官方类库的方法）
alt+shift+F7：Force step into调试的时候能进入任何方法。
alt+shift+F8：step out，确定某个方法没有问题时，跳出该方法;
//----------
F9            resume programe 恢复程序
Alt+F10       show execution point 显示执行断点
F8            Step Over 相当于eclipse的f6      跳到下一步
F7            Step Into 相当于eclipse的f5就是  进入到代码
Alt+shift+F7  Force Step Into 这个是强制进入代码
Shift+F8      Step Out  相当于eclipse的f8跳到下一个断点，也相当于eclipse的f7跳出函数
Atl+F9        Run To Cursor 运行到光标处
ctrl+shift+F9   debug运行java类
ctrl+shift+F10  正常运行java类
alt+F8          debug时选中查看值
ctrl+shift+enter,光标放在函数原型的圆括号后，可以自动生成代码结构;
ctrl+shift+f7,光标放在implements处，可以查看接口的方法;
先按ctrl，将光标移动到函数、变量、类型处，就可以看到其声明信息；
//----------
}
{
idea下maven项目的目录结构比较固定，不可随意更改，否则容易出错；
resources目录；
}
//----------
{
总结常用java库的依赖:
guava;
slf4j;
json;
jsp文件上传;
spring mvc;
mybatis;
spring+mybatsi;
}
//--------
{
<h3>最近5条历史对比结果</h3>
<table>
<tr>
<td>对比时间</td>
<td>源文件内容</td>
<td>目标文件内容</td>
<td>差异</td>
<td>操作</td>
</tr>
<tr>....</tr>
}
//----------
{
前端线下课程:
hosts文件,无后缀的系统文件,存储域名和对应的IP地址;
(C:\windows\system32\drivers\etc);
清除DNS缓存,在chrome的具体操作方法;
静态资源版本号是根据css和js内容计算得到的md5值;
刷新CDN缓存和浏览器缓存;
//-----
Node.js
npm
npm 
新项目建议用ykit;
//-----------
rpm i query -safe
Vue.js
}
//----------
{
线下课程,项目研发流程:
磨刀不误砍柴工;
敬畏流程;
}
{
京葱爆羊肉套餐(配精美荤菜&时令素菜2种&果切&软饮/去哪儿网专供) 1份已支付
J221取餐时，您可以从东升科技园北领地B-6-4的 J221 架位直接取到您的餐点。
}
//-----------
{
粟老师点评mybatis作业:
在java中，我们一般是这样做的。
Service包下面的是接口定义，
在Service包下面，再增加一个impl包，
里面是Service包里面接口的实现。
这样做的目的是降低耦合，提高灵活性。
这一层定义接口，接口名字要有意义。
你可以在test类中做这些日志打印。
//-------
老师,mybatis作业可以这样改吗:
定义一个Service接口,再新建一个文件夹impl,在其中定义一个实现了Service接口的类.
Service接口内的成员函数该怎么命名比较合适啊,是否应该和那11个题目一一对应啊?
}
//------
{
qunar项目开发模块划分；
}
//-------------
{
sachame,DTD;
}
//-----
{
wiki更新，mybatis,spring作业；
}
//---------
{
2017-06-21,
小鸡炖蘑菇套餐(配米饭&果切&软饮/去哪儿网专供) 1份已支付
J221取餐时，您可以从东升科技园北领地B-6-4的 J221 架位直接取到您的餐点。
}
//--------------
{
git push --set-upstream origin jintao.wang

//-----
王锦涛，修改后的mybatis作业：
题目地址:http://wiki.corp.qunar.com/pages/viewpage.action?pageId=156646599
GitLab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/mybatis
CR:http://cr.corp.qunar.com/D104576

old:79aeaa85e
revision:b62fc8d2d
//---------

王锦涛,spring作业：
题目地址:http://wiki.corp.qunar.com/pages/viewpage.action?pageId=156646591
GitLab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/spring_wangjintao
CR:http://cr.corp.qunar.com/D104595

revision:9129161fe

//-------------
王锦涛,exam3：
题目地址:http://wiki.corp.qunar.com/pages/viewpage.action?pageId=157374286
GitLab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/Exam3
CR:http://cr.corp.qunar.com/D104596

rev:6119e590c
//---------------
account.properties
}
//--------

{
老师，请您抽空检查一下我的作业吧：

王锦涛，修改后的mybatis作业：
题目地址:http://wiki.corp.qunar.com/pages/viewpage.action?pageId=156646599
GitLab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/mybatis
CR:http://cr.corp.qunar.com/D104576
//------------
王锦涛,spring作业：
题目地址:http://wiki.corp.qunar.com/pages/viewpage.action?pageId=156646591
GitLab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/spring_wangjintao
CR:http://cr.corp.qunar.com/D104595
//-------------
王锦涛,exam3：
题目地址:http://wiki.corp.qunar.com/pages/viewpage.action?pageId=157374286
GitLab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang/Exam3
CR:http://cr.corp.qunar.com/D104596
}
//-------------------
2017-06-19,
//--------------
http,json,redis;
redis用法手册,(https://www.cheatography.com/tasjaevan/cheat-sheets/redis/);
redis设计与实现(第一版),(http://origin.redisbook.com/);
redis GitHub,讨论区,(https://github.com/huangz1990/redisbook);
//-------------
要是将Exam3设置为dev_training的子模块，配置总是出错，很难解决；
mybatis作业对应mybatis module;
spring作业对应spring_wangjintao module;
exam3对应Exam3 module;
网址都发给您了。
//----------
明白。
前面都有地址，在GitLab上可以下载这些代码。
是项目的组织结构吗？
情况是这样的：
spring_wangjintao是按讲师的要求用spring_boot模板实现的；
Exam3主要是某些依赖问题没解决好，所以就将Exam3 module和dev_training2 project隔离开了，
两者的pom.xml相互隔离，这样就能正常运行。
试着解决了，还没解决好。
//--------------------
将Exam3设置为父子工程后，出错日志如下两个文本所示。
将两者隔离，就能正常运行。
每一种依赖都只保留一个版本，统一版本号。
我改一下。
老师，刚才重试了，如果将依赖都按您以前要求的方法设置，并将Exam3设置为dev_training2的子module，就会出错；
将二者隔离，Exam3就能正常运行；
下面的两个文件文件是错误日志:
//----------------
//-------------------
这个是dev_training2的pom.xml文件，版本号都用占位符统一了。
我给tomcat Application context指定了一个名称后才能正常运行，没专门指定Application context的值时也是出错。
//--------------------
别的同学都用那些版本，也都能正常运行。
spring的版本都统一了，刚发给您的pom.xml文件就是我刚整理过的。
刚提交上GitLab,地址是:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang
//-------
刚才忘了执行
git add pom.xml，
只是执行了git add Exam3，
所以修改后的pom.xml文件没能传上去。
刚才我又重新上传了一份，
GitLab:http://gitlab.corp.qunar.com/campus2017/dev_training2/tree/jintao.wang
//--------------------
{
JavaScript全栈教程,(http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000);
W3School,(http://www.w3school.com.cn/js/);
javascript前后端数据交互,(http://www.jianshu.com/p/6f21738e4b7b);
jQuery,ajax,(http://www.w3school.com.cn/jquery/ajax_ajax.asp);
}
//----------
{
最后说一点，我们作为程序员，研究问题还是要仔细深入一点的。当你对原理了解的有够透彻，开发起来也就得心应手了，很多开发中的问题和疑惑也就迎刃而解了，而且在面对其他问题的时候也可做到触类旁通。当然在开发中没有太多的时间让你去研究原理，开发中要以实现功能为前提，可等项目上线的后，你有大把的时间或者空余的时间，你大可去刨根问底，深入的去研究一项技术，为觉得这对一名程序员的成长是很重要的事情。
}
//--------------------
{
redis,
//-----
redis源码与应用,(http://www.redis.cn/),
(https://github.com/linyiqun/Redis-Code);
//------------
那个2>/dev/null是如果你的命令出错的话，错误报告直接就删除了。不会显示在屏幕上，或者是以邮件的形式发给你了。 
[test @test test]# ls -al >  list.txt  
将显示的结果输出到 list.txt 档案中，若该档案以存在则予以取代！ 
[test @test test]# ls -al >> list.txt
将显示的结果累加到 list.txt 档案中，该档案为累加的，旧数据保留！
[test @test test]# ls -al 1> list.txt 2> list.err
将显示的数据，正确的输出到 list.txt 错误的数据输出到 list.err
[test @test test]# ls -al 1> list.txt 2>&1  
将显示的数据，不论正确或错误均输出到 list.txt 当中！ 
[test @test test]# ls -al 1> list.txt 2> /dev/null 
将显示的数据，正确的输出到 list.txt 错误的数据则予以丢弃！
//--------
相比-g选项， -rdynamic 却是一个 连接选项 ，它将指示连接器把所有符号（而不仅仅只是程序已使用到的外部符号）都添加到动态符号表（即.dynsym表）里，以便那些通过 dlopen() 或 backtrace() （这一系列函数使用.dynsym表内符号）这样的函数使用。
//--------------
latency,
//--------
tty是Teletype的缩写(转):
终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。tty是Teletype的缩写。Teletype是最早出现的一种终端设备，很象电传打字机（或者说就是），是由Teletype公司生产的。设备名放在特殊文件目录/dev/下。
//----------
函数名: isatty
用 法: int isatty(int desc);
返回值：如果参数desc所代表的文件描述词为一终端机则返回1，否则返回0。
//--------
epoll有两种触发机制：
水平触发(level-triggered，也被称为条件触发)LT: 只要满足条件，就触发一个事件(只要有数据没有被获取，内核就不断通知你)
边缘触发(edge-triggered)ET: 每当状态变化时，触发一个事件
     “举个读socket的例子，假定经过长时间的沉默后，现在来了100个字节，这时无论边缘触发和条件触发都会产生一个read ready notification通知应用程序可读。应用程序读了50个字节，然后重新调用api等待io事件。这时水平触发的api会因为还有50个字节可读从 而立即返回用户一个read ready notification。而边缘触发的api会因为可读这个状态没有发生变化而陷入长期等待。 因此在使用边缘触发的api时，要注意每次都要读到socket返回EWOULDBLOCK为止，否则这个socket就算废了。而使用条件触发的api 时，如果应用程序不需要写就不要关注socket可写的事件，否则就会无限次的立即返回一个write ready notification。大家常用的select就是属于水平触发这一类，长期关注socket写事件会出现CPU 100%的毛病。
}
//---------------------
{
1.5:1:3:3.5;
项目模块拆得越小，越便于监测；功能模块要细化；
主动向项目干系人介绍自己模块的进展；
每个bug单独拉一个分支，修改；
敢于质疑PM的需求；一旦定稿，就应严格遵循；对于需求问题应及时沟通；
//----------
gira-----Qunar的项目发布管理系统;
//----------
}
//--------
{
Spring官方框架:http://www.springframework.org
JavaEE5 API:http://java.sun.com/javaee/5/docs/api
//----
思维导图；
}
//---------
JSP+QCC;ykit;
{
wiki上有关项目的好文档；
一期的项目样例；
接口，文档，SQL；
//-------
本周要完成查询功能、查看详情+分页、批量上传;
//----------
 实战：webapp与前端qzz关联（Maven Enabled）,(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=51547519);
 QSSO接口文档 ,(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=31265466);
}
//-----------
{
2017-06-21:
项目注意事项:
1、基本权限申请；
服务器；Git工程权限；Jira工程权限；数据库权限；
少动线上的东西，以免出错；
特殊IP白名单；
Watcher权限,(watcher.corp.qunar.com/#/);
发布job权限；
Qunar开发工具集合(cm.corp.qunar.com);
2、需求阶段；
3、设计开发阶段；
分工应按功能划分，不要按分层来，尽量保证每个人都要有完整的功能模块；
数据库设计一定要请导师review，数据库设计要保持到wiki上，MySQL开发规范；
业务逻辑设计一定要Review并保存到Wiki上，最好有Dev导师的Review记录；
如果有对外接口或前端接口，要有Wiki;
接口开发规范；
Coding，尽早请Dev导师Review，多Review，避免翻工；代码配置要清晰，统一配置，统一编码风格，
使用公司组件(qschele,dubbo,qconfig等)，经常提交，merge代码，避免冲突；
Qunar开发规范；
监控和日志；
4、测试阶段；
每个人都应参与设计实现checkList，交叉写，交叉测试；
提测标准；
BUG管理，必须有bug，至少有5个bug；
Dev完成单元测试，集成测试，接口自动化测试(大讲堂上有)，压力测试；
QA导师review;
Code diff----主要针对改善老项目，进行code diff，并记录;
5、发布线上；
//------------
监控课程:
qunar watcher,(http://watcher.corp.qunar.com/#/dash/team/qunar.team);
Qmonitor,(http://ops.corp.qunar.com/qmonitor/qconfig/);
报警统计,(http://cerberus.corp.qunar.com/main.htm);
添加监控的方法,在该页有示例,(http://watcher.corp.qunar.com/#/dash/user/qunar.user.jintao___wang.wjt2?pageNum=1&panelId=1&fullscreen&mode=edit);
//---------
}
{
http://ops.corp.qunar.com/ops/approve/index_new
Portal
}
//-----------
{
maven教程,(http://www.cnblogs.com/hongwz/p/5456578.html);
在Maven中很重要的一点是，groupId、artifactId、version三个元素生成了一个Maven项目的基本坐标，这非常重要。
官方下载的本地仓库的配置在"%MAVEN_HOME%\conf\settings.xml"里面，找一下"localRepository"就可以了；
本地仓库和远程仓库是这样的，Maven工程首先会从本地仓库中获取jar包，当无法获取指定jar包时，本地仓库会从远程仓库（中央仓库）中下载jar包，并放入本地仓库以备将来使用。
}
{
益百教程之maven,(http://www.yiibai.com/maven/);
}
//-----------
{
2017-06-21,粟老师点评spring作业：
spring_wangjintao/src/main/java/com/qunar/fresh2017/dao/UserDao.java
应该有一个count 所有记录总数的接口，
page是根据总数/每页数来定的。
不应该直接给pages接口。
spring_wangjintao/src/main/java/com/qunar/fresh2017/model/Page.java
构造函数里面做的东西太多太杂了。
这些运算逻辑应该放到service里面做。
spring_wangjintao/src/main/java/com/qunar/fresh2017/service/impl/UserServiceImpl.java
dao层只负责与数据库进行交互，逻辑应该放到Service层
不要的东西就删掉。代码保持清洁。
spring_wangjintao/src/main/java/com/qunar/fresh2017/utils/DateFormatter.java
SimpleDateFormat不是线程安全的。在这里没有问题，但是以后在业务线，使用FastDateFormat代替这个类。
}
//---------------
//--------
Maven中央存储库
Maven 中央存储库是 Maven 用来下载所有项目的依赖库的默认位置。当你建立一个 Maven 的项目，Maven 会检查你的 pom.xml 文件，以确定哪些依赖下载。首先，Maven 将从本地资源库获得 Maven 的本地资源库依赖资源，如果没有找到，然后把它会从默认的 Maven 中央存储库 – http://repo1.maven.org/maven2/ 查找下载。
//-----------
{
spring经典思考题,(http://blog.csdn.net/u012562943/article/details/51397417),
(http://blog.csdn.net/zhu_xun/article/details/16877447);
}
//-------------
2017-06-22,
xmind,思维导图软件。
//------
{
部门数据表;数据量较小，可缓存；
管理员权限的可配置；
公司组织架构变化，适应变化的部门；
Qtalk处输入非法字符，前后端都检验；
}
//----------
{
checkList,
//---------------
case来源：需求文档、设计开发文档、外部接口、性能、安全、思维导图、第三方依赖、codediff等；

checkList和case的关系：；
checkList review的参与人员:pm,dev,qa;
checkList review需check哪些点：；
case review;
case步骤：；
checkList,case的语句要明确，不可模糊；
case录入地址是：；如何操作：；
BugFree;
//-----------
UI,UE,功能模块，接口模块；
还应考虑异常；
footer;
逆向case;
//----------------
 case---前10万名(1-->10万)app用户所得优惠券张数是5,打八折；
  case---前10万名(10万+1开始)app用户所得优惠券张数是5,打八折；
  使用期限在注册成功到距离该时间点1个月；
  每天的使用次数不超过2；
  每张只能用1次，特惠标签的促销商品；
  压测；
}
{
五香鸡腿套餐(配米饭&精美荤菜&2种精美素菜&软饮/去哪儿网专供) 1份已支付
J221取餐时，您可以从东升科技园北领地B-6-4的 J221 架位直接取到您的餐点。
16:18:42
您已下单。
}
//-----------
Qunar项目流程,(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=86808614);
//----------------
{
Web通用测试案例,(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=157371588);
1、浏览器--页面兼容，要支持qunart统计中>=5%的浏览器；
浏览器派系：按内核分为Trident,Webkit,Gecko,Presto；
双核浏览器；
兼容测试的方法：页面样式、页面内容、页面功能；
页面检查，加载速度，请求检查；
安全。
2、浏览器--页面检查，货币符号、页面时间显示、页面title；
使用多浏览器访问不能报脚本错误；
页面显示内容的长度；
浏览器收藏夹中的列表页，弹出框DIV；
页面广告检查，查看页面广告位，例如http://hotel.qunar.com/city/beijing_city/?adtest=beta；
header-footer检查，检查链接、缩放、窜行、下拉框不能被隐藏、响应时间可接受。
3、浏览器---页面加载，
DOCTYPE标签一定在第一行，指出浏览器的规范：HTML或XHTML；
head标签下首个标签一定是声明字符集的串，必是UTF-8,避免乱码;
页面加载是从上到下加载文件的，应该使CSS在所有的<script>之前;
4、浏览器---请求检查，任何页面请求中不容许出现IP地址或内网机器名；
JS内容混淆，就是把函数、变量定义转换成无意义的简短字符，使程序的可读性降低；
页面统计功能，beacon用于统计pv(pageview,y页面浏览量),uv(unique vision,独立访客访问数)；
新增/页面需要检查是否添加bc.qunar.com的调用。
//----
http代理工具；
}
//--------------
{
活动说明
1. 99元秒杀，2017.6.12-2017.7.16日每天10点-14点整将有多条指定城市的线路开放秒杀
2. 拍下“99元秒杀”活动商品的用户需在15分钟内完成支付，以付款结果为准；若15分钟内未完成支付，去哪儿网有权关闭订单
3. “99元秒杀”活动产品特殊，仅限活动页面展示日期出行，不可改签，不可更改出行人信息，不支持退票
4. “99元秒杀”活动每个乘机人仅限成功抢购两次，乘机人必须是抢单本人
5. 若因系统故障或其他不可抗力，造成活动未能正常按时进行，去哪儿网有权调整活动时间或取消活动
6. 活动机票的最终解释权归去哪儿网所有
(http://hd.flight.qunar.com/?cid=54&plat=pc)
}
{
qunar前后端接口设计,
(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=83954522),
(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=158603887),
(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=63243288);
//---
Qunar,QA tools,(http://qa.corp.qunar.com/flight/checklist/home),
(http://qa.corp.qunar.com/flight/checklist/suite/editMindmap?id=45206&parentid=995&version=1&iscase=0);
//----
}
//----------
{
C++,CUDA,GPU;
}
//---------------
{
utf8和utfmb4,
//-----------------
MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。
当然，为了节省空间，一般情况下使用utf8也就够了。
那上面说了既然utf8能够存下大部分中文汉字,那为什么还要使用utf8mb4呢? 原来mysql支持的 utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了。
三个字节的 UTF-8 最大能编码的 Unicode 字符是 0xffff，也就是 Unicode 中的基本多文种平面(BMP)。也就是说，任何不在基本多文本平面的 Unicode字符，
都无法使用 Mysql 的 utf8 字符集存储。包括 Emoji 表情(Emoji 是一种特殊的 Unicode 编码，常见于 ios 和 android 手机上)，和很多不常用的汉字，以及任何新增的 Unicode 字符等等。
//-------------------
}
//--------------------
{
MyBatis学习笔记，(http://limingnihao.iteye.com/blog/782190);
}
//-------
{
协同开发时，不可修改他人的文件，只能修改自己的文件，否则会发生冲突；
提交四部曲:git pull,git add,git commit,git push;
$git pull
$git add -A
$git commit -m '...'
$git push
}
//----------
{
mybatis学习心得:
<if test>,监测;
<foreach>,循环;
<where>,<set>,<trim>智能删除不需要的and,or,和逗号分隔符;
            GROUP BY user_id
            <trim prefix="HAVING" prefixOverrides="AND">
                <if test="lowPoint != null">
                    <![CDATA[ SUM(employee_points.points) >= #{lowPoint} ]]>
                </if>
                <if test="upperPoint != null">
                    AND <![CDATA[ SUM(employee_points.points) <= #{upperPoint} ]]>
                </if>
            </trim>
@Param("<param_name>")用于关联xxxMapper.xml文件内的参数和.java文件内的函数参数；
}
//--------
{
ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement
//---

}
{
idea,poject structure;
}
//------------
{
spring_mybatis,
Dao,@Repository;
Service,@Service,@Autowired;
}
//------------
git commit -m '王锦涛，添加controller'
//--------
{
idea,添加注释的方法:
/**,Enter;
}
//---------
http://localhost:8080/score_tomcat/
Administrator/showSysAndPlainAdministratorList
//-------------
107,
{
[房屋租赁] 农大南路厢黄旗万树园小区房屋整租，到苏州街中关村很近哦，感兴趣的来围观啦
电话 18510791582
//-----------
新龙城1期大阳隔转租，租金2100元/月，无中介费，签了1年的合同，刚住3个月，距离龙泽地铁站步行10分钟内（妹子亲测），距东升半小时路程，维亚45分钟，合租的室友们都很爱干净，没有照片，有需要加我微信：ruoqi_Lee  或QT：ruoqi.li 聊~
//--------
 [房屋租赁] [个人招租]北三环中路-安华里-木偶剧院环球贸易对面，温馨干净
现在大次卧招租，我比较爱运动，旅游，烘焙；性格良好，男女不限，价格私聊，有意向可以直接私聊；如有意愿请联系Amy,手机号：15210187214，微信：2858879240	
}
//------------
{
一个用于测试前后端通信的chrome插件:
rest-let client;
chrome-extension://lojhniniegkapineaeepfmdbkdpanhmg/restlet_client.html
//----------
Qunar跳板机配置:http://wiki.corp.qunar.com/pages/viewpage.action?pageId=9949258
BDS的发布逻辑：Tomcat应用:http://wiki.corp.qunar.com/pages/viewpage.action?pageId=4925792
Qunar账号系统:http://ops.corp.qunar.com/ops/account/
//---------
正式项目:/home/linux2014/WJT_2017/projects/idea_projects/frc_170624_2/score;
测试项目:/home/linux2014/WJT_2017/projects/idea_projects/frc_170624_wjt_test;
//-------
登录跳板机的命令示例:
ssh jintao.wang@l-rtools1.ops.cn0.qunar.com
ssh jintao.wang@l-rtools1.ops.cn6.qunar.com
//--------------
ssh jintao.wang@l-crm11.des.beta.cn0.qunar.com
//-------------
2015第四批的大讲堂权限系统的源码_qprivilege.zip
//----------
明天上午10点培一，讲noah环境搭建的问题，大家提前看一下线上课程;
发布系统,(http://qtown.corp.qunar.com/online/detail.html?courseId=100);
//-------
}
//----------
{
"rtxId":"zengguofan.zeng",
"cn":"曾国藩zgf",
"sn":"Q139998",
"jobCode":"dev",
"leader":"奕䜣",
"hireType":"正式",
"dep1":"机票事业部",
"dep2":"国际机票销售部",
"dep3":"机票报价部",
"dep4":"搜索技术部",
"dep5":"国际机票价格搜索",
"role":"1"
}
//----------
{
2017-06-27,
韭菜鸡蛋锅贴(配韭菜鸡蛋锅贴20个&精品凉菜&果切&软饮/去哪儿网专供) 1份已支付
J221取餐时，您可以从东升科技园北领地B-6-4的 J221 架位直接取到您的餐点。
}
//----------
{
redis;gdb,
(gdb)info source
shutdown
help
//--------
repl,
In a REPL, the user enters one or more expressions (rather than an entire compilation unit) and the REPL evaluates them and displays the results. The name read–eval–print loop comes from the names of the Lisp primitive functions which implement this functionality:

The read function accepts an expression from the user, and parses it into a data structure in memory. For instance, the user may enter the s-expression (+ 1 2 3), which is parsed into a linked list containing four data elements.
The eval function takes this internal data structure and evaluates it. In Lisp, evaluating an s-expression beginning with the name of a function means calling that function on the arguments that make up the rest of the expression. So the function + is called on the arguments 1 2 3, yielding the result 6.
The print function takes the result yielded by eval, and prints it out to the user. If it is a complex expression, it may be pretty-printed to make it easier to understand. In this example, though, the number 6 does not need much formatting to print.
The development environment then returns to the read state, creating a loop, which terminates when the program is closed.
//-------
#include <termios.h>
//----------
(gdb) ptype completionCallback
type = void (*)(const char *, linenoiseCompletions *)
(gdb) ptype linenoiseCompletions
type = struct linenoiseCompletions {
    size_t len;
    char **cvec;
}
//------------
struct termios
//--------
在32位环境下,sizeof(long)=sizeof(void*)=4;
在64位环境下,sizeof(long)=sizeof(void*)=8;
//---------
(http://www.cnblogs.com/jacksu-tencent/p/3764822.html)
本项目主要是基于sphinx来解析编写，方便生成各种格式文件。
本文档主要是redis源码的解析，在阅读本文档前最好先阅读《redis的设计与实现》。源码的阅读主要是学习作者的代码风格、编程技巧、以及系统原理。本文档主要就是介绍上面相关的三点，源码是基于redis3.0。
联系方式： 371387455(at)qq.com
//----------
unlink(),close();
//---------
#include<pthread.h>
int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
attr 是线程属性变量；stacksize 则是设置的堆栈大小。 返回值0,-1分别表示成功与失败。
//------------

}
{
linux线程同步:
We can protect our data and ensure access by only one thread at a time by using the
pthreads mutual-exclusion interfaces. A mutex is basically a lock that we set (lock)
before accessing a shared resource and release (unlock) when we’re done. While it is
set, any other thread that tries to set it will block until we release it. If more than one
thread is blocked when we unlock the mutex, then all threads blocked on the lock will
be made runnable, and the first one to run will be able to set the lock. The others will
see that the mutex is still locked and go back to waiting for it to become available again.
In this way, only one thread will proceed at a time.
This mutual-exclusion mechanism works only if we design our threads to follow
the same data-access rules. The operating system doesn’t serialize access to data for us.
//----------
Condition variables are another synchronization mechanism available to threads. These
synchronization objects provide a place for threads to rendezvous. When used with
mutexes, condition variables allow threads to wait in a race-free way for arbitrary
conditions to occur.
The condition itself is protected by a mutex. A thread must first lock the mutex to
change the condition state. Other threads will not notice the change until they acquire
the mutex, because the mutex must be locked to be able to evaluate the condition.
The mutex passed to pthread_cond_wait protects the condition. The caller
passes it locked to the function, which then atomically places the calling thread on the
list of threads waiting for the condition and unlocks the mutex. This closes the window
between the time that the condition is checked and the time that the thread goes to sleep
waiting for the condition to change, so that the thread doesn’t miss a change in the
condition. When pthread_cond_wait returns, the mutex is again locked.
//---------
UNIX app architecture;
UNIX file kernel data structure;
盘块的分配和回收，文件与盘块，Linux系统下的文件系统；
//-----------
The i-node contains all the information about the file: the file type, the file’s access
permission bits, the size of the file, pointers to the file’s data blocks,count of hard-link, and so on. Most
of the information in the stat structure is obtained from the i-node. Only two items
of interest are stored in the directory entry: the filename and the i-node number.
//------
process table entry,file descriptor table entry(fd flags,the pointer to the file table entry),file table entry(ref_count,file status flags,current file offset,v-node pointer);
open,dup,remove,unlink,rename,rm的执行原理;
读写文件的执行原理;
lseek;
同一个进程open同一个文件两次；
相互独立的两个进程open同一个文件两次；
父子进程open同一个文件；
close的执行原理;
//--------------
The file descriptor returned by open and openat is guaranteed to be the lowest-
numbered unused descriptor.
//---------------
所谓的init进程，它是一个由内核启动的用户级进程。
内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。
所以,init始终是第一个进程（其进程编号始终为1）。
内核会在过去曾使用过init的几个地方查找它，它的正确位置（对linux系统来说）是/sbin/init。如果内核找不到init，它就会试着运行/bin/sh，如果运行失败，系统的启动也会失败。
//------------------
Linux下有3个特殊的进程，idle进程(PID = 0), init进程(PID = 1)和kthreadd(PID = 2)
1,idle进程由系统自动创建, 运行在内核态 
idle进程其pid=0，其前身是系统创建的第一个进程，也是唯一一个没有通过fork或者kernel_thread产生的进程。完成加载系统后，演变为进程调度、交换
2,init进程由idle通过kernel_thread创建，在内核空间完成初始化后, 加载init程序, 并最终用户空间 
由0进程创建，完成系统的初始化. 是系统中所有其它用户进程的祖先进程 
linux中的所有进程都是有init进程创建并运行的。首先Linux内核启动，然后在用户空间中启动init进程，再启动其他系统进程。在系统启动完成完成后，init将变为守护进程监视系统其他进程。
3,kthreadd进程由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理 
它的任务就是管理和调度其他内核线程kernel_thread, 会循环执行一个kthread的函数，该函数的作用就是运行kthread_create_list全局链表中维护的kthread, 当我们调用kernel_thread创建的内核线程会被加入到此链表中，因此所有的内核线程都是直接或者间接的以kthreadd为父进程。
//--------------
}
//-------
{
@ResponseBody
开涛的博客—公众号：kaitao-1234567，一如既往的干货分享
博客微博相册收藏留言关于我
}
//-------------
2017-06-27,
{
DevOps,开发运维;

}
//---------
{
好了，看一下在Spring中如何使用注解进行开发吧！
一，首先需要在配置文件中增加命名空间的和约束文件：
<beans ...  
        xmlns:context="http://www.springframework.org/schema/context"  
    xsi:schemaLocation="  
        ...  
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd  
        "> 
二，开启Spring的注解功能，这样Spring环境才会进行指定位置的扫描，进行类之间的关联组合：
<!-- 扫描注解类  
    base-package ： 表示当前扫描的包，框架会根据包查找所有使用注解的类  
 -->  
<context:component-scan base-package="com.ljh.spring.*" />  
三，声明注解类，让Spring框架可以识别：
1，类的分层注解，由于我们后台开发都是分为三层进行开发的，所以Spring框架提供了三种对于不同层的注解方式：
               控制层：@Controller
               服务层：@Service
               持久层：@Repository
     默认情况下使用注解声明的Bean对象id名称为：类名称的首字母小写，一般不需要我们进行设置，如果想要设置时，例如我们指定的是实现类，而名字指向了接口，直接添加value属性即可：@Service(value="name")，当然value是可以省略的。
 Spring框架还为我们提供了代替上边三个分层注解的通用注解：@Component.当然提倡大家使用分层注解更好一些，
 区分层次比较明确。
2，自动装配功能的实现对象之间的组合关系，在属性前边指定下边的注解：
@Autowired : 采用类型的方式完成自动装配 ： byType
@Resource : 采用名称+类型的方式完成自动装配 : byName +byType，此种方法推荐使用。
另外Spring提供的两种注解的自动装配功能，属性不需要声明set,get方法也可以完成组合功能，这是非常方便的。
//-------
 @Resource（JSR-250标准注解，推荐使用它来代替Spring专有的@Autowired注解） 
Spring 不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。 
@使用@Scope来定义Bean的作用范围 。                          
}
//------
{
深入理解mysql字符集,
(http://www.laruence.com/2008/01/05/12.html);
Linux线程池,(http://zsxxsz.iteye.com/blog/2028452),(http://blog.csdn.net/tuantuanls/article/details/41205739);
Linux服务器编程,(http://blog.csdn.net/ustc_dylan/article/details/6930191),(http://blog.csdn.net/Solstice/article/details/5307710);
}
//--------------
2017-06-28,
{
JsonBody;
controller内要有日志记录开始时刻，结束时刻，执行结果，总的执行次数，成功次数；
对于常量，尽量不要用字面常量，要用常变量；
日志要记录三种:debug、info、error，分别记录到三个文件内；
Service类成员方法的异常处理;需要复习java的异常处理；
}
//--------
{
score:
/home/linux2014/WJT_2017/projects/score_170629/score.git
}
//----------
{
发布和发布系统,
}
{
Java App,(http://blog.csdn.net/hj7jay/article/details/54310817);
idea的全局搜索快捷鍵:ctrl+shift+F;
idea的补全键是:ctrl+<space>;
//--------
ubuntu中文输入法:
http://jingyan.baidu.com/article/09ea3ede23958ec0aede39f3.html
http://blog.csdn.net/q1302182594/article/details/47065309
http://jingyan.baidu.com/article/a3a3f8118c5d488da2eb8aa1.html
http://jingyan.baidu.com/article/9c69d48fbecf6613c8024e59.html
//------------
}
//--------
{
spring注解手札,(http://snowolf.iteye.com/blog/1628861);
}
//----------
2017-06-30,
{
code diff课程,
code diff的目的:找出测试范围;
工具:GitLab,idea插件,kdiff,cr,小乌龟;
code diff何时进行？
//-----
mysql，
高并发量的解决;
数据库并发问题的解决；
慢查询;
//-----
TC做性能测试的平台;
dubble接口测试;
jmetr,测试工具;
//------
上线前pom文件引用jar包不能带snapshot;
qconfig发布;
有远端缓存时，发完后刷新缓存;
//-------
btag,rtag;
PMO;
//--------
发布和回滚步骤,(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=159680536);
}
//------------
{
触发器，事务;
}
//--------
ajax,(http://www.w3school.com.cn/example/ajax_examples.asp);
(http://www.runoob.com/ajax/ajax-database.html);
(http://www.w3school.com.cn/jquery/ajax_ajax.asp);
(http://blog.csdn.net/blueheart20/article/details/45174399);
jQuery,(http://www.w3school.com.cn/jquery/jquery_ajax_intro.asp);
//----------
/home/linux2014/WJT_2017/projects/idea_projects/frc_170624_2/score/src/main/webapp/test1.html

/home/linux2014/WJT_2017/projects/idea_projects/frc_170624_2/score/src/main/webapp/test2.html

http://localhost:8080/score_tomcat/test2.html
http://localhost:8080/score_tomcat/test2.html

http://localhost:8080/score_tomcat/test2.html
//-------
http://localhost:8080/score_tomcat/test2.html
//--------------
{
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/text_db?useUnicode=true&characterEncoding=utf8
password=linux2014
user=root
}
//-----------
{
web.xml,filter
(http://blog.csdn.net/liaoxiaohua1981/article/details/6761053)
(http://blog.csdn.net/ps101505138/article/details/24412005/)
(http://blog.csdn.net/zhaozheng7758/article/details/6105749);
interface javax.servlet.Filter
{
void init(FilterConfig config);
void doFilter(ServletRequest request,ServletResponse response,FilterChain chain);
void destroy();
}

}
{
XML,javascript;
(http://www.w3school.com.cn/xmldom/dom_http.asp)
HTML5,Input,(http://www.w3school.com.cn/html5/html_5_form_input_types.asp)
(http://www.w3school.com.cn/tiy/t.asp?f=jsrf_string_style)
javascript的对象,
(http://www.w3school.com.cn/jsref/dom_obj_event.asp)
//----------
JSON.parse(jsonstr); //可以将json字符串转换成json对象 
JSON.stringify(jsonobj); //可以将json对象转换成json对符串 
//--------
前端和后端以json方式交流数据的思想方法:
var xmlHttp = new XMLHttpRequest();
前端js代码可以根据 document.getElementById("<id>").value 获取指定<id>的输入值;
对于js内的单个或多个数据，可利用内置的构造函数或自定义的构造函数构造出js对象;
用JSON.stringify(<js_obj>)　将js对象转换成json字符串<jsonStr>;
利用js内XMLHttpRequest类的成员方法send(<jsonStr>)将jsonStr对象发送给后端controller的成员方法,
该方法的要有对应的注解@RequestMapping和参数注解@RequestBody,并且参数列表要对应;
该controller内的成员方法要有＠ResponseBody注解，其返回值会被包装成json字符串<jsonStr>，
存在xmlHttp.responseText内,再调用JSON.parse(<jsonStr>)可将json字符串解析成对应的js对象<js_obj>,
如果函数的返回值是线性容器,则js_obj就是js数组,
如果函数返回的是某个类的实例对象,则<js_obj>也是一个对象，可以用<js_obj>.<attribute>直接访问其属性;
如果函数返回的是基本的java类型，则<js_obj>就是相应的对象;
//--------------
js数字与字符串的区别
js的数字的加法与字符串的连接都是 + 符号， 所以究竟是加还是字符串的连接就取决与变量的类型。
举例：
var a = 'abc' + 'xyz'; //a的值为：abcxyz,字符串与字符串是连接
var a = 10 + 5; //a的值为：15，数字是加
var a = 'abc' + 10; //a的值为：abc10，字符串与数字，自动将10转换成字符串了
var a = 'abc' + 10 + 20 + 'cd'; //a的值为:abc1020cd
var a = 10 + 20 + 'abc' + 'cd'; //a的值为:30abccd，可以数字加的先数字加，然后再连接
补充：
js字符串转换数字。方法主要有三种:
转换函数、强制类型转换、利用js变量弱类型转换。
1. 转换函数：
js提供了parseInt()和parseFloat()两个转换函数。前者把值转换成整数，后者把值转换成浮点数。只有对String类型调用这些方法，这两个函数才能正确运行；对其他类型返回的都是NaN(Not a Number)。
2. 强制类型转换
还可使用强制类型转换（type casting）处理转换值的类型。使用强制类型转换可以访问特定的值，即使它是另一种类型的。
ECMAScript中可用的3种强制类型转换如下：
Boolean(value)——把给定的值转换成Boolean型；
Number(value)——把给定的值转换成数字（可以是整数或浮点数）；
String(value)——把给定的值转换成字符串。
用这三个函数之一转换值，将创建一个新值，存放由原始值直接转换成的值。这会造成意想不到的后果。
当要转换的值是至少有一个字符的字符串、非0数字或对象时，Boolean()函数将返回true。如果该值是空字符串、数字0、undefined或null，它将返回false。
//-----------------
}
//------------
{
清除浏览器数据的方法:
打开谷歌浏览器(Chrome)，点击上方右侧的菜单按钮，依次进入“工具”--“清除浏览器数据”，
或使用快捷键CTRL+SHIFT+DEL。
}
/home/linux2014/WJT_2017/projects/idea_projects/frc_170624_2/score/src/main/webapp/test3.html
//---------
2017-07-03,
{
接口测试:
Qunar常见接口分类:HTTP接口(前端页面访问);HTTPS接口(支付&登录);RPC(后端应用之间服务);
request,response;
dubbo的组成和作用;
dubbo接口常见的测试方法?
GET方法、POST方法的特点，如何测试?
接口测试详解:(1)分层测试;(2)接口测试方法(功能、性能、安全、异常、兼容性);
分层测试的分层方案:从上到下依次是:
(1)UI展示层(移动端、网页端);
(2)负载层分配(nginx,HAProxy,..);
(3)接口层(http,https);
(4)业务层(tomcat,Jetty,JBoss);
(5)业务间通信层(消息队列方式、SOA方式);
(6)数据存储层(常用缓存技术;关系数据库、对象数据库等);
接口测试需要的基本功能:接口协议、接口调用方式(POST,GET)、接口数据交换(接口参数、接口响应);
接口测试之安全:(1)权限(水平、垂直);(2)sql注入;(3)敏感信息;
http接口、dubbo接口；
//-----
有了系统级测试，为什么还要接口测试?
//--------
dubbo接口和http接口比较有什么优势?
}
//--------------
{
tcpdump,libpcap代码下载,(http://www.tcpdump.org/release/);
tcpdump教程;
}
//---------
{
HTTP报文详解,
(http://www.cnblogs.com/klguang/p/4618526.html),
(http://www.cnblogs.com/klguang/p/4624333.html),
(http://blog.csdn.net/longeremmy/article/details/8012532),
(http://www.cnblogs.com/x_wukong/p/3929654.html);
//--------
具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。
同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，
所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。
//-----
Safe Methods（安全方法）
RFC 2616 中定义如下：
Implementors should be aware that the software represents the user in their interactions over the Internet, and should be careful to allow the user to be aware of any actions they might take which may have an unexpected significance to themselves or others.
In particular, the convention has been established that the GET and HEAD methods SHOULD NOT have the significance of taking an action other than retrieval. These methods ought to be considered "safe". This allows user agents to represent other methods, such as POST, PUT and DELETE, in a special way, so that the user is made aware of the fact that a possibly unsafe action is being requested.
Naturally, it is not possible to ensure that the server does not generate side-effects as a result of performing a GET request; in fact, some dynamic resources consider that a feature. The important distinction here is that the user did not request the side-effects, so therefore cannot be held accountable for them.
综上所述，可总结如下：
GET 仅用来获取查看信息，不能改变服务器信息。
POST 用来改变服务器信息。
这里说的改变，包括增加、修改和删除。
这是 HTTP 协议中的要求，众多浏览器和浏览器插件都遵守这些约定。如果你的代码不按照这约定来，可能会出现严重的后果。
//----------
}
{
spring MVC,
(http://jinnianshilongnian.iteye.com/blog/1670856/),
(http://blog.csdn.net/qyp1314/article/details/42023725),
(http://blog.csdn.net/l729035983/article/details/48781479);
//-------
ServletRequest,
(http://blog.csdn.net/chenrushui/article/details/52293962),
(http://blog.csdn.net/qq_26975307/article/details/54958276),
(http://blog.csdn.net/zhangsify/article/details/51474734),
(http://www.cnblogs.com/xdp-gacl/p/3789624.html);
}
//--------------
{
bugfree,(http://bugfree.corp.qunar.com/index.php/case/list/54?productmodule_id=14669);
}
{
进入线上系统(积分晋级系统)的方法:
1、复制hosts文件,以便于回复;
sudo cp /etc/hosts /etc/hosts_bak  
2、文件编辑
 sudo gedit /etc/hosts  
添加两行内容:
192.168.228.23 q.qunarzz.com
192.168.228.23 qunarzz.com
3、保存后重启网络
sudo /etc/init.d/networking restart 
//--------
http://l-score.fresh.beta.cn0.qunar.com:8080/#
//----------
}
//-------
json在线解析,(http://www.sojson.com/json2entity.html);
//--------
{
JSON 语法规则:
JSON 语法是 JavaScript 对象表示法语法的子集。
数据在名称/值对中
数据由逗号分隔
大括号保存对象
中括号保存数组
//---------
}
//---------
2017-07-05,
{
CPP,STL,(http://yosef-gao.github.io/2016/07/25/cjson-source-code/?utm_source=tuicool&utm_medium=referral);
cJSON,(http://www.kuqin.com/shuoit/20141224/344068.html);
hash table,(http://github.tiankonguse.com/blog/2014/11/04/hash-table.html);
memcached,(http://www.kuqin.com/shuoit/20141108/343083.html);
}
//----------
{
编码,(http://www.cnblogs.com/xinruzhishui/p/5763894.html);
//------------------
需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。
比如，汉字"严"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。
表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。
这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？
第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，
那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。
它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。
互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。
其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。
重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。
互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。
重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。
UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。
UTF-8的编码规则很简单，只有二条：
1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
2）对于n字节的符号（n>1），第一个字节的高n位都设为1，第n+1高位设为0，后面字节的高两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码，
从低字节到高字节，从低位到高位，一一对应，不足二进制位的补0。
下表总结了编码规则，字母x表示可用编码的二进制位。

Unicode符号范围 | UTF-8编码方式
(十六进制) | （二进制）
--------------------+----------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
//-----------------------------------------------------------
实际表示ASCII字符的UNICODE字符，将会编码成1个字节，并且UTF-8表示与ASCII字符表示是一样的。所有其他的UNICODE字符转化成UTF-8将需要至少2个字节。
每个字节由一个换码序列开始。第一个字节由唯一的换码序列，由n位连续的1加一位0组成, 首字节连续的1的个数表示字符编码所需的字节数。
Unicode转换为UTF-8时，可以将Unicode二进制从低位往高位取出二进制数字，每次取6位，如上述的二进制就可以分别取出为如下示例所示的格式，前面按格式填补，不足8位用0填补。
注：Unicode转换为UTF-8需要的字节数可以根据这个规则计算：如果Unicode小于0X80（Ascii字符），则转换后为1个字节。否则转换后的字节数为Unicode二进制位数减1再除以5。
//-----------------------------------------------------------
Unicode码可以采用UCS-2格式直接存储。以汉字"严"为例，Unicode码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。
存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。
Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做"零宽度非换行空格"（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。
这正好是两个字节，而且FF比FE大1。
如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。
//-----------------------------------------------------------
GB2312是中国规定的汉字编码，也可以说是简体中文的字符集编码;GBK 是 GB2312的扩展 ,除了兼容GB2312外，它还能显示繁体中文，还有日文的假名。
//-----------
UTF-8/UTF-16等则是对Unicode进行了编码，是其一种实现方式。UTF-8(8-bit Unicode Transformation Format)，是一种变长的编码方式，
它以8位为码元,用1-6个码元对Unicode进行编码，对英文字符使用单字节编码，对中文编码用到三个字节来编码。
//----------
c语言程序中判断unix系统下，某个字符是字符本身还是汉字的一部分？
首先你要知道你文件的汉字编码是什么。
如果是gb2312或者是gbk 那么每发现一个超过0x80的字符，那么下一个和它一起构成一个汉字。
如果是utf-8 那么每发现一个超过0x80的 ，和后续两个字节构成一个汉字。
这样 从开头到结尾扫描一次，就知道汉字有多少个 都是哪些了。
//----------------------
(http://blog.csdn.net/hherima/article/details/38961575);
在正常情况下一个Unicode两个字节，在转化uft-8的时候，根据协议，两个两个字节，对应一个uft-8这样完成转化或者称为映射！
其实在第0个平面中，专门有一个代理区域，不表示任何字符，只用于指向第1到第16个平面中的字符，这段区域是：D800——DFFF.。
其中0xD800——0xDBFF是前导代理(lead surrogates).0xDC00——0xDFFF是后尾代理(trail surrogates).
一个代理对儿（前导，后尾），就表示一个utf-16的字符。就那emoji的微笑来说，前导是代理：D83D；后尾代理是：DE03。根据下图可以得出utf-16的值是：0x1-F603。这就照应上了。
具体的公式是：0x10000 + (前导-0xD800) * 0x400 + (后导-0xDC00) = utf-16编码。
}
//----------
{
者智亮：鲁朗软件联合创始人，tensorflow contributor，花伴侣团队机器学习负责人。(http://blog.csdn.net/wemedia/details.html?id=38193);
}
{
顶尖程序员的五种思维模式，你具备吗？
(http://blog.csdn.net/wemedia/details.html?id=36787),
勇于去研究你不懂的代码;
精通代码调试(debug);
重视能够节约时间的工具;
优化你的迭代速度;
系统性的思考方式;
//------------
毕业3年的程序员，怎么进BAT | 12000字揭秘阿里连环炮面试,(http://blog.csdn.net/wemedia/details.html?id=38710);
//-----------------
}
//------------
{
《MyBatis从入门到精通》,(刘增辉 著),(http://blog.csdn.net/column/details/andyalien-mybatis.html),(http://blog.csdn.net/techbirds_bao/article/details/9233599/);
《深入理解并行编程》,(【美】Paul E.Mckenney （保罗·E·麦肯尼） 著谢宝友 鲁阳 译);
《深入理解JVM&G1GC》,(周明耀 著);
《Nginx完全开发指南：使用C、C++和OpenResty》,(罗剑锋 著);
《收获，不止SQL优化——抓住SQL的本质》,(梁敬彬 梁敬弘 著);
《深入浅出深度学习：原理剖析与Python实践》,(黄安埠 著);
《数据科学家养成手册》,(高扬 编著);
《网络爬虫全解析——技术、原理与实践》;
《Python大战机器学习：数据科学家的第一个小目标》;
《Spring MVC实战》;
OPENCV＋OPENMP,(http://blog.csdn.net/Summer_And_Opencv/article/details/73518736);
//----------
{
servlet,(http://www.runoob.com/servlet/servlet-tutorial.html),
(https://www.ibm.com/developerworks/cn/education/java/j-intserv/index.html),
(https://www.ibm.com/developerworks/cn/java/j-lo-servlet/),
(http://www.cnblogs.com/xdp-gacl/p/3763559.html);
(http://blog.csdn.net/u012422829/article/details/51570652);
(http://www.cnblogs.com/rocomp/p/4803864.html);
(http://blog.csdn.net/bboyfeiyu/article/details/41863951);
(http://www.cnblogs.com/rocomp/p/4803864.html);
(http://blog.csdn.net/longeremmy/article/details/8012532);
web app内bean的创建、初始化次序;
ServletConfig,ServletContext;
<init-param>,<context-param>;
/*用ServletContext实现请求转发*/
RequestDispatcher rd = context.getRequestDispatcher("/servlet/ServletContextDemo5");//获取请求转发对象(RequestDispatcher)
rd.forward(request, response);//调用forward方法实现请求转发
HTTP Content-type 对照表,(http://tool.oschina.net/commons);
}
//-----
{
    /**
13          * 1.调用sendRedirect方法实现请求重定向,
14          * sendRedirect方法内部调用了
15          * response.setHeader("Location", "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp");
16          * response.setStatus(HttpServletResponse.SC_FOUND);//设置302状态码，等同于response.setStatus(302);
17          */
18         response.sendRedirect("/JavaWeb_HttpServletResponse_Study_20140615/index.jsp");
19         
20         //2.使用response设置302状态码和设置location响应头实现重定向实现请求重定向
21         //response.setHeader("Location", "/JavaWeb_HttpServletResponse_Study_20140615/index.jsp");
22         //response.setStatus(HttpServletResponse.SC_FOUND);//设置302状态码，等同于response.setStatus(302);
}
//--------
{
在JavaWeb开发中，只要是写URL地址，那么建议最好以"/"开头，也就是使用绝对路径的方式，那么这个"/"到底代表什么呢？可以用如下的方式来记忆"/";
如果"/"是给服务器用的，则代表当前的web工程，如果"/"是给浏览器用的，则代表webapps目录。
(http://www.cnblogs.com/xdp-gacl/p/3791993.html);
}
//-------
{
response细节问题:
　　getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOuputStream、Printwriter对象。
　　getOutputStream和getWriter这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。  
　　Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎从response里面获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。 
Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象。
}
//------
{
请求重定向和请求转发的区别:
一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发/307。
一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302。
}
//---------
/download/STL_src.pdf

/score_tomcat/download/http_resp.png
15236286736@163.com
//------------
2017-07-10,
//---------
报销;
//--------
{
晋级积分系统、会议室预订系统，讲师点评:
１、数据库要加索引；属性不要冗余太多；
2、spring要求面向接口编程；controller内尽量不用具体类，而用接口；
３、不要重复自己的代码；
４、不要总是跟从老系统，可适当更新；
5、log1.2，于朝辉老师视频；
６、对于错误，日志可复现错误，监控可报警通知；
７、参数校验，不可全放进service内；
８、在实际项目中，不可盲从，要敢于问清楚，提出自己的想法，请leader解决。
}
//---------
2017-07-11,
{
(http://qcollege.corp.qunar.com/);
研发新人学习路径图（流程、工具等）,
这周学习完成&通过在线考试,
(http://l-process.training.cn8.qunar.com/independency/Tech20170602v520170602122602402/Tech20170602v5/Tech20170602v5%20-%20Storyline%20output/story.html)
//----------
《产品开发流程》,
项目分类：产品需求，技术需求，线上BUG，紧急发布。
//------------
《故障处理》，
故障定义，分为三类：服务中断，服务质量下降；影响收入；影响公司品牌、形象。
报故障的原则：短时间内无法确认问题影响面，优先按故障申报处理；宁可误报，不可漏报。
故障申报方式：找NOC,(RTX_ID:noc;18801385307;010-57603911;nocteam@qunar.com)；团队的人,dev/qa/leader/pm/运营。
故障定级。
故障处理流程：发现故障->找NOC报故障->成立故障处理团队->处理故障->确认故障结束。
故障处理原则和技巧：优先回复线上，方式不限；先降级，再处理；短时间内没思路，要及时上升求助。
常见场景处理技巧：代码逻辑引发的问题，看相关模块最近是否有发布--回滚代码；
服务器/数据库资源满引发的问题，先重启临时回复；直接在线上修改，注意检查和备份；
对于涉及对用户赔付、更正通知的故障，产品、运营应该在故障解决的过程中同步考虑对用户如何处理。
//-------
《配置管理》，
版本控制工具Git；Git管理的四个阶段：工作区(workspace)，暂存区(index)，本地仓库(local repository)，远程仓库(remote repository)。
项目构建工具：maven;gradle;fekit/qzz。
《maven实战》。
Nexus。
自助发布平台：BDS，QDR；->。
CM导航页,(http://cm.corp.qunar.com/)；
Wiki主页,(http://wiki.corp.qunar.com/display/CM/Home);
RTX:cmrexian
//------------
《开发过程》。
//------------
《数据库必知必会》，
１、与mysql dba组沟通：
db-request@qunar.com，（处理需求）；
dbateam@qunar.com，（讨论问题）；
邮件标题格式：[<部门名>]主题
DBA首页(http://wiki.corp.qunar.com/pages/viewpage.action?pageId=4919845),
DBA导航页(http://putin.corp.qunar.com/),
SQL审核,(http://putin.corp.qunar.com/qso/dev/index.html#/home);
//------------
}
//-------------------
2017-07-12,
{
《故障处理流程》，

}
//--------------
{
红黑树,平衡树,
(http://www.cnblogs.com/daoluanxiaozi/archive/2012/04/26/2471256.html),
(https://www.zhihu.com/question/20545708),

}
{
基于redis的分布式缓存,
(http://blog.csdn.net/pi9nc/article/details/17719737);
}
//---------
{
一个文件夹内存了十多个文件，这些文件的总容量远超过3G，无法用163邮箱一次性发送，可分别压缩，分别发送。
分别压缩的shell脚本：
for fname in $(ls)
do
	echo ${fname}
	tar -cf ${fname}.tar ${fname}
done
}
//------------
项目中的AOP;
拦截器;
培训总结；
培训资料整理；
问明在公司住宿的事情；
换房+收拾衣物、被单；
//----------
《spring入门经典》
//---------
15702418795@163.com
//---------
{
xrandr --output eDP1 --right-of DP1 --auto
nohup qtalk &
nohup mysqld_safe --user=root &
nohup idea.sh &
nohup ss-qt5 &
}
//---------
{/WJT_work/学习记录/books/20170713_books}
//------
IEEE浮点数标准;
//-------
java,mybatis,(http://blog.csdn.net/isea533/article/list/1);
idea,(http://blog.csdn.net/isea533/article/details/53706744);
《编程之法》;
//----------
{
(http://blog.csdn.net/acm_lkl/article/details/46778527);
(http://www.cnblogs.com/Zhuqy/p/4720348.html);
(http://blog.chinaunix.net/uid-20687780-id-2302001.html);
(http://www.cnblogs.com/Zhuqy/p/4720348.html);
x != T.nil;
现在因为y替代z以后被染成z原来的颜色，所以至z以上红黑树的所有性质都不会变，唯一有可能会影响红黑树性质的地方在x替代y这一点。所以其实情况有返回到情况1了，下面按y的颜色进行分类讨论： 
(1).y的颜色为红；那么无论x的颜色为红还是为黑，x替换y以后都不会影响任何性质。 
(2).y的颜色为黑；这时与上面的情况1是相似的，如果x为黑，则性质5会被违反，我们通过将其染成双重黑色解决。如果x为红，则性质4,5都会被违反，但是我们可以通过将x染成黑色恢复。
}
若原先y为红色，则删除z后不会破坏性质；
若原先y为黑色，若x为红色，简单地将x染黑即可，若x为黑色，将x染成2重黑色即可；
关键在于如何删除x携带的多出一重的黑色；
//-----------
{
C GUI,
(http://blog.csdn.net/rs_network/article/details/6509490),
(http://blog.csdn.net/liuchao35758600/article/details/7213978),
(http://blog.csdn.net/liuchao35758600/article/details/7213973),
(http://blog.csdn.net/liuchao35758600/article/details/6789910),
(http://blog.csdn.net/liuchao35758600/article/details/7288822),
(http://weiyinchao88.iteye.com/blog/1414165);
//-----
(http://huoyufei.iteye.com/blog/340371);
(http://www.cnblogs.com/esingchan/p/3958962.html);
(http://blog.jobbole.com/76676/);
(http://blog.csdn.net/iumffcfkpim/article/details/52433604);
}
//---------
2017-07-17,
{
Qunar重置密码,
userName:jintao.wang
Pwd:Qunar.201351
}
//-----------
(业务线没老师，只有同事，你的目标就是技术上碾压这些老人);
//--------
{
CRM,
(http://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=55527617);
//-------
watchdog,(git@gitlab.corp.qunar.com:scm/watchdog.git);
 jdbc.jdbcUrl=jdbc\:mysql\:///test
 //---------
 java.util
Interface Map<K,V>,An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value.
//-----
}
//-----------
{
java,final,
(http://www.importnew.com/7553.html);
}
//---------
{
mysql -h l-crmdb2.des.dev.cn0.qunar.com:3308/scm_mdc?characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useCursorFetch=true&defaultFetchSize=100 -u cmdev -p

mysql -h l-crmdb2.des.dev.cn0.qunar.com:3308 -u cmdev -p
//------
linux2014@linux2014-Latitude-E5440:~/WJT_2017/projects/qunar_projects$ mysql -h l-crmdb2.des.dev.cn0.qunar.com -port 3308 -u cmdev -p
Enter password: 
ERROR 1045 (28000): Access denied for user 'cmdev'@'100.80.180.66' (using password: YES)
//-----
}
//-----------
{
线上系统不可用绝对路径，最好不要用线上系统访问计算机硬盘存储的数据。
CRM代码规范,(http://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=57337072);
CRM技术wiki;
}
//------------------
{
值班表系统：
关系模式：
employee_onduty_table(id,name,email,mobile,值班日期,值班类型编号,值班业务编号);
存储每个员工下一次的值班安排;

onduty_type_table(id,值班类型编号,值班类型说明);
存储值班类型编号及其说明;

onduty_work_table(id,值班业务编号,值班业务说明);
存储值班业务编号及其说明;

(id,不排值班的日期);
存储因为节假日等原因不安排值班的日期;

(wiki:http://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=164997413)
//---
先完成，再完美；
程序中有变化的部分和固定不变的部分，要将变化的部分向固定不变的部分靠拢；
//----
}
//------
{
spring常用注解,(http://www.cnblogs.com/xingzc/p/5777814.html);
spring-mybatis,
(http://blog.csdn.net/lemonyfei/article/details/8925332),
(http://blog.csdn.net/trwhoya/article/details/4535433),
(http://www.cnblogs.com/leiOOlei/p/3725911.html),
(http://blog.csdn.net/mrslw/article/details/52824145),
(http://blog.csdn.net/yexumoutian/article/details/18719649),
(http://www.cnblogs.com/zhangxingBlob/p/6369187.html),
(http://www.cnblogs.com/tjlgdx/p/5846294.html),
}
//------------------
{
//-----
用idea查看pom.xml内依赖的jar包的.java文件的方法；
//------
《代码重构》，tomcat源码，spring源码，网络协议，数据结构，并发；
//-------
2017-07-19,
//----------
deep learning,(http://cn.udacity.com/course/deep-learning-nanodegree-foundation--nd101?utm_source=baidu&utm_medium=cpc&utm_campaign=DLND02&utm_term=shenduxuexi);
(https://www.zhihu.com/question/26006703);
希望初学者长点心，不要报什么培训班，被别人收割智商税。当然你只要英语强，你可以直接去YouTube上找到一堆的大牛开的公开课以及会议演讲的视频。
马尔科夫链,(https://www.zhihu.com/question/20962240);
}
{
java注解,
(http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html);
(http://www.cnblogs.com/peida/archive/2013/04/26/3038503.html);
(http://www.importnew.com/17413.html);
(http://www.cnblogs.com/lzh984294471/p/4959953.html),
(http://blog.csdn.net/ye1992/article/details/19971467);
}
//---------
{
编程技术网站,ImportNew,(http://www.importnew.com/);
优秀的java库,(http://www.importnew.com/25495.html);
}
//----
{
//------
在idea内由接口或类的定义导出UML的方法:在类文件上右键，选择diagrams，显示出图形后可点击"+"放大;还可生成图片导出;
在idea内由pom.xml文件生成依赖关系图的方法:在pom.xml文件上右键，选择diagrams，显示出图形后可点击"+"放大;还可生成图片导出;
//------
mvn dependency:tree，查看依赖关系;
//-------
maven命令clean,package,compile,install,deploy;
在idea内可用GUI方式执行这些命令，打开一个project，选择maven project，选择lifecycle，执行以上这些命令；
clean，清除编译过的maven project;
compile，编译maven project或module;编译一个project/module时，必须保证它依赖的module已经被install到本机;
package,将一个maven project打包;
install,将一个maven project部署到本机，通常是本机主目录下的.m2文件夹内;
deploy,将一个maven project部署到maven远程仓库，需要授权；但是在pom.xml内这样指定
(    <packaging>jar</packaging>
    <version>1.0.10-SNAPSHOT</version>)，亦可部署到maven远程仓库内;
(http://www.cnblogs.com/phoebus0501/archive/2011/05/10/2042511.html),
(http://www.cnblogs.com/adolfmc/archive/2012/07/31/2616908.html);
//-----
}
//--------
办了招商银行卡，记得注销。
//---------
北京海淀区苏州街维亚大厦16层
//------
2017-07-20,
//----------
{
git branch 20170718_DZS-15792
DZS-15956
qunar,gitlab,(http://gitlab.corp.qunar.com/);
}
//----
怎样查看网络协议报文？多请教。
//------
{
切换并下载gitlab分支；
idea，删除无用的import的快捷键;
}
//--------
{
war,jar,pom包是什么？
}
{
idea,UML;
(http://www.jianshu.com/p/a6bd7e3048ef),
(http://blog.csdn.net/snrnjhna/article/details/49464837),
(http://blog.csdn.net/zxc123e/article/details/71837923);
}
//----------
(北京维亚大厦	16层伊洛河会议室外	100.80.190.5	HP401	网络)
//----------
{
SSM,(http://blog.csdn.net/gebitan505/article/details/44455235/);
(http://blog.csdn.net/zhshulin/article/details/37956105/);
}
//-----
{
Use 'mvn dependency:tree' to locate the source of the banned dependencies.
}
//------------
编程技术网站,(http://www.programcreek.com/);
(http://www.importnew.com/7530.html);
(http://www.importnew.com/25791.html),(mybatis部分精讲);
mybatis的#和$,(http://www.importnew.com/25791.html);
简书,(http://www.jianshu.com/p/2a4b24734bac);
//--------------
{
Java常用的库和依赖的总结，从两个方面总结：功能->库，库->功能；
1、核心库
Apache Commons Lang：来自Apache的核心库，为java.lang API补充了许多常用的工具类，如字符串操作、对象的创建等。
Google Guava：来自谷歌的核心库，包括集合（Collection）、缓存（Caching）、支持原语（Primitives）等。（示例）
2、HTML、XML Parser
Jsoup：一个简化了的 HTML操作的库。（示例）
STaX：一组可以高效处理 XML的API。 （示例）
3、Web框架
Spring：Java平台上众所周知的开源框架和依赖注入容器。（示例）
4、自然语言处理
OpenNLP：来自Apache的自然语言处理库。 （示例）
Stanford Parser：斯坦福大学提供的自然语言处理库。（示例）

首页所有文章资讯Web架构基础技术书籍教程Java小组工具资源
最常用的Java库一览
2013/12/05 | 分类： 技术之外 | 8 条评论 | 标签： 常用开发库
分享到： 189
本文由 ImportNew - 邢 敏 翻译自 programcreek。欢迎加入翻译小组。转载请见文末要求。
写在前面：

1) 本文列出的名单是根据我自己的调查，并结合个人的经验。有可能是它们不恰恰是最流行的，但至少众所周知的。

2) 我会不断更新这个列表，使之更加完整和准确。感谢您的意见。

一个典型的Java项目依赖于第三方库。本文总结的Java库适用于各种应用，比较流行并且广泛使用。其中一些还提供简单的示例（来自ProgramCreek）。
Java SDK 肯定是使用最广的库，所以本文的名单焦点是流行的第三方库。该列表可能并不完善，所以如果你觉得有什么应该出现在列表中的，请留下您的评论。非常感谢！
1、核心库
Apache Commons Lang：来自Apache的核心库，为java.lang API补充了许多常用的工具类，如字符串操作、对象的创建等。
Google Guava：来自谷歌的核心库，包括集合（Collection）、缓存（Caching）、支持原语（Primitives）等。（示例）
2、HTML、XML Parser
Jsoup：一个简化了的 HTML操作的库。（示例）
STaX：一组可以高效处理 XML的API。 （示例）
3、Web框架
Spring：Java平台上众所周知的开源框架和依赖注入容器。（示例）
Google Web Toolkit：Google提供的开发工具库，主要用于构建和优化复杂的Web程序用。 （示例）
Strips：使用最新Java技术构建的Web程序框架，推荐使用。
Tapestry：面向组件的框架，用于使用Java创建动态、健壮、扩展性高的Web应用程序。
4、图表、报表、图像
JFreeChart：用于创建如条形图、折线图、饼图等图表。
JFreeReport：创建于输出PDF格式的报表。
JGraphT：创建图像，其中只包含由线段连接的点集。
5、自然语言处理
OpenNLP：来自Apache的自然语言处理库。 （示例）
Stanford Parser：斯坦福大学提供的自然语言处理库。（示例）
如果你是一名NLP专家，请猛击这里 查看更多工具库介绍。
6、JSON和XML
Jackson： 用于处理JSON数据格式的多用途的Java库。Jackson 旨在快速、准确、轻量、对开人员友好之间找到最好的平衡点。
XStream：一个简单用于对象和XML互相转换的库。
Google Gson：一个专门用于Java对象和Json对象相互转换的工具库。（示例）
JSON-lib：用于 beans、maps、collections、java arrays、XML 和 JSON 之间相互转换操作的工具库。
7、数学
Apache Commons Math：提供数学计算和数值统计需函数的工具库。
8、日志
Apache Log4j：风行一时的日志记录操作库。 （示例）
Logback：当前流行的log4j项目的继任者。
SLF4J（The Simple Logging Facade for Java）： 各种日志框架的一个简单的外观或抽象（如java.util.logging 、logback、log4j等），允许用户在部署时加入需要的日志框架。
9、Office
Apache POI：利用其提供的APIs，可以使用纯Java代码操作各种基于微软OLE2合成文档格式的文档。
10、日期和时间
Joda-Time：如有质量问题包退包换的Java日期和时间类。
11、开发工具
Lombok： 旨在减少代码编写的Java开发库。
//---------
}
//---------
{
解决依赖冲突；
}
//-------
{
[ERROR] [Qunar Enforcer Rules] find DuplicateClasses

  Found in:
    commons-logging:commons-logging:jar:1.1.1:compile
    org.slf4j:jcl-over-slf4j:jar:1.7.5:runtime
  Duplicate classes:
    org/apache/commons/logging/impl/SimpleLog$1.class
    org/apache/commons/logging/Log.class
    org/apache/commons/logging/LogConfigurationException.class
    org/apache/commons/logging/impl/NoOpLog.class
    org/apache/commons/logging/impl/SimpleLog.class
    org/apache/commons/logging/LogFactory.class
    //-----
    mvn dependency:tree | grep  commons-logging
}
//-----
{
git add -f *
git commit -m "王锦涛，值班表后端代码"
git push
}
//--------
{
idea内git指定上传文件的方法；
idea内根据pom.xml生成依赖关系图并在图上查找依赖项；
}
//-----
{
申请beta机器；
配置beta开发环境；
}
//-------
{
mysql -h l-crm13.des.beta.cn0.qunar.com -P 3306 -u qa -phWyIT1a3P57E6cxc
crm_statistic
ssh jintao.wang@l-rtools1.ops.cn0.qunar.com
ssh jintao.wang@l-crm13.des.beta.cn0.qunar.com
}
//------
{
        <!--<property name="location" value="classpath:onduty_jdbc.properties" />-->
classpath:profiles/beta/
}
//-------
Maven类包冲突终极三大解决技巧 mvn dependency:tree,
(http://ian.wang/106.htm),
(http://www.cnblogs.com/wuchanming/p/5403135.html);
//------------
{
<!--配置文件-->
    <context:property-placeholder location="classpath:jdbc.properties,
                                            classpath:ApplicationResources.properties,
                                            classpath:zookeeper.properties,
                                            classpath:crate.properties"/>
}
//------------
{
由本机登录到跳板机示例:
ssh weixing.zhou@l-rtools1.ops.cn0.qunar.com
ssh jintao.wang@l-rtools1.ops.cn0.qunar.com
由跳板机登录到服务器示例:
ssh baoqiu.xiao@l-crm13.des.beta.cn0.qunar.com
ssh jintao.wang@l-crm13.des.beta.cn0.qunar.com
ssh jintao.wang@l-scmct1.des.cn6.qunar.com
发布时看监控的方法示例：
cd /home/q/www
ll
cd ct.svr.qunar.com/logs/
tail -f catalina.out -n550
grep Exception catalina.out
 grep 'ScmException' catalina.out
}
//-------
{
值班表程序错误记录集:
//-------
1,空插入；
2,删除一个元素时，下标需更新;
3,返回qtalkList时不可有空串;
//--------
处理字符串多用gauva；
Splitter,Joiner,CharMatcher;
//------
将不可变列表内的元素放入可变列表内;
Serialize序列化；定时器；
}
//------
{
2017-07-24，(baoqiu.xiao)review值班表代码总结:
1、文件头部注释，设置模板;
2、每一个源文件/类/接口/类的属性/方法都要有注释，可通过按键:</>+<*>+<*>+<Enter>实现;
设置文件头部注释模板的方法：File->Settings->Editor->File and Code Templates->Includes->File header；
/**
 *@author ${USER} Date: ${DATE} Time: ${TIME}
 */
3、用idea提交代码的方法，可以右键点击项目/模块/文件，在菜单栏内选择Git，可在不同的层次上、选择文件提交到gitlab;
每次更新一个项目/模块/文件的内容后要记得执行Maven Projects内的clean命令，以便清除缓存；
4、idea右侧的Maven Projects可用于对项目/模块进行清理缓存、编译、打包、部署到本机、部署到远程仓库;
5、清空项目缓存的方法：点击File -> Invalidate caches；
}
//------
{
jdk,guava容器的组织结构;
}
//-------
{
2017-07-24,score_mvc_170724,;
//---
学习《spring实战》时，在knights程序内，pom.xml内的依赖配置完整，程序文件内无法识别@Slf4j、@Test，报错"Cannot resolve symbol 'Slf4j'"，这时利用idea右侧的clean命令，检查出大概的错误，
再在terminal下执行mvn -e命令，显示出具体的错误信息：pom.xml内缺少<version>信息，据此修改，并将test文件夹mark成test sources问题解决；
}
//--------------
{
2017-07-25,
//---------
ubuntu侧边栏，标题栏以及最大最小化关闭按钮不见问题，解决方案：
重设compiz设置
dconf reset -f /org/compiz/
重置compiz后，重启Unity：
setsid unity
此外，如果你想将Unity图标也进行重置，试试以下的命令吧：
unity --reset-icons
}
//--------
{
最全的在线API,(http://tool.oschina.net/apidocs/);
}
//-------
{
adobe acrobat reader
wget ftp://ftp.adobe.com/pub/adobe/reader/unix/9.x/9.5.5/enu/AdbeRdr9.5.5-1_i586linux_enu.deb
}
{
Qunar,发布系统时的SQL代码审核,(http://putin.corp.qunar.com/qso/index.html#/add/pxc);
进入网址，选择“SQL审核”，进入，在右上角选择"申请审核->PXC审核"；
按要求提交SQL代码和附件，申请审核，将申请页面的网址现发给QA，请求审核，QA审核通过后再将网址发给DBA请求审核，DBA审核通过后方可发布；
//-------
登录跳板机示例：
ssh jintao.wang@l-rtools1.ops.cn5.qunar.com
由跳板机登录到在线机器的示例：
ssh jintao.wang@l-scmdata.des.cn5
}
//----------
{
jdk,guava容器总结：
interface Iterable<T>,
interface Collection<E> extends Iterable<E>,
interface List<E> extends Collection<E>,
interface Map<K,V>,
interface Set<E> extends Collection<E>,
abstract class AbstractCollection<E> implements Collection<E>,
abstract class ImmutableCollection<E> extends AbstractCollection<E>,

}
//-------
{
idea快捷键,(http://blog.csdn.net/tang9140/article/details/52333601);
//----------
idea安装vim插件的方法：File->Settings->点击Plugins->输入VIM->点击Browse->点击Install plugin然后点击restart安装完成;
Tools->VIM Emulator开关VIM插件。
}
{
Java虚拟机原理解析,(http://blog.csdn.net/luanlouis/article/details/41046443);
}
//----------
{
qtalk 中文问题,(http://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=127470918);
转至元数据结尾
由 刘江伟ljw创建, 最后修改于2016-07-25 转至元数据起始
首先安装fcitx-frontend-qt5。
sudo apt-get install fcitx-frontend-qt5
然后编辑安装目录下run.sh文件。
修改为：#!/bin/bash
BASEPATH=$(cd "$(dirname "$0")"; pwd)
cd $BASEPATH
export XMODIFIERS="@im=fcitx"
export QT_IM_MODULE=fcitx
export LC_CTYPE=zh_CN.UTF-8
export LD_LIBRARY_PATH=$BASEPATH/lib
export QT_QPA_PLATFORM_PLUGIN_PATH=$BASEPATH/plugins/platforms
export QT_PLUGIN_PATH=$BASEPATH/plugins
ulimit -c 1024
$BASEPATH/LocalMan
}
//-----------
{
2017-07-26,
leader讲话总结：
1、缺乏主动性和斗志。要主动熟悉本职业务、技术，业务的上下游，发现缺陷，持续改进。研究框架的实现原理和细节，培养自己发现问题、分析问题、解决问题的能力。
多花时间钻研业务和技术，前三年放弃业余休息时间。
2、缺乏必要的总结、自省。每做一个项目，都要多与他人沟通，熟悉整个项目框架、流程、接口、缺陷和解决办法。做完一个项目后要做总结，不断优化。
3、不善于沟通是一大劣势。要多与本组同事沟通，例如开发项目时多交流，吃饭时多交流，多了解他人对工作的思考与看法，多学习他人优秀的工作方法。
有什么想法就直说，不要怕目前水平低劣，只有不断求教、思考、实践、总结，才能真正提高！
4、不熟悉技术，不熟悉业务，要加班加点学习，不懂就要问，争取一次性掌握，但是同样的错误不可重犯。
5、积极、主动、机灵，要让人看到进步和可培养性。
6、每周至少一次总结与分享(可分享到CSDN)，积极分享，能让听众快速听明白，这是提高沟通能力的好机会。
7、要善于从客户、公司、领导、同事的角度考虑问题。
//-----
2017-08-01,补充：
8、善于发现公司项目中的痛点，立项研究，在解决实际问题中成长；
9、多关心周围同事的工作，以求扩大视野、熟悉项目流程；
10、多关心项目的方方面面，包括需求分析、开发、测试、发布、报警、日志等，这样才能提升工作能力；
}
//---------
jintao.wang
Qunar.201351
//---------
{
供应链(SCM)业务开发:
(1),主要的业务技术点：
qmp
qschedule
watcher
qconfig
B端和C端。
(2),主要的开源框架:SSM,Java,MySQL。
(3),目标：准确地、高效地、无死锁地处理大量数据。
}
{
spring aop,(http://www.cnblogs.com/MrSaver/p/6104130.html);
pom.xml配置正确程序文件却报告某些符号无法解析，可通过刷新pom.xml解决；刷新pom.xml的的方法是修改一下pom.xml即可引起刷新；
}
//---------------
{
中国MySQL用户组
Redis中国用户组
台湾MySQL用户组
香港MySQL用户组
Inception 开源项目,(http://mysql-inception.github.io/inception-document/command/),(https://github.com/mysql-inception/inception);
}
{
2017 Qunar Hackathon 比赛作品收集,(http://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=158020659);
}
{
spring配置中 <aop:aspectj-autoproxy/>的含义:
通过aop命名空间的<aop:aspectj-autoproxy />声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。
默认为false，表示使用jdk动态代理织入增强，当配为<aop:aspectj-autoproxy  poxy-target-class="true"/>时，表示使用CGLib动态代理技术织入增强。
@aspectJ 切面注解，写在public class上面。  是AOP的一个属性，AOP可以实现不动源码的情况切入一个新的方法.
}
{
Cannot perform refactoring.
Selected block should represent a expression
}
{
byType
  @Autowired
  @Qualifier("stringed")
  private Instrument instrument;
  //----
  @Autowired(required=false)
  //----
  <context:annotation-config />，开启注解;
}
//---------
{
When you added <context:annotation-config> to your Spring configuration, you
told Spring that you wanted it to honor a certain set of annotations in the beans that
you declared and to use those beans to guide bean wiring. Even though <context:
annotation-config> can go a long way toward eliminating most uses of <property>
and <constructor-arg> elements from your Spring configuration, you still must
explicitly declare beans using <bean> .
But Spring has another trick up its sleeve. The <context:component-scan> ele-
ment does everything that <context:annotation-config> does, plus it configures
Spring to automatically discover beans and declare them for you. What this means is
that most (or all) of the beans in your Spring application can be declared and wired
without using <bean> .
To configure Spring for autodiscovery, use <context:component-scan> instead of
<context:annotation-config> :
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-3.0.xsd">
<context:component-scan
base-package="com.springinaction.springidol">
</context:component-scan>
</beans>
The <context:component-scan> element works by scanning a package and all of its
subpackages, looking for classes that could be automatically registered as beans in the
Spring container. The base-package attribute tells <context:component-scan> the
package to start its scan from.
//------
So, how does <context:component-scan> know which classes to register as Spring
beans?
By default, <context:component-scan> looks for classes that are annotated with one
of a handful of special stereotype annotations:
 @Component —A general-purpose stereotype annotation indicating that the class
is a Spring component
@Controller —Indicates that the class defines a Spring MVC controller
@Repository —Indicates that the class defines a data repository
@Service —Indicates that the class defines a service
Any custom annotation that is itself annotated with @Component
//--------
When we first started looking at Spring’s XML -based configuration, I showed you a
snippet of XML with the <beans> element from Spring’s beans namespace at its root.
The Java-based equivalent to that XML is a Java class annotated with @Configuration .
For example:
package com.springinaction.springidol;
import org.springframework.context.annotation.Configuration;
@Configuration
public class SpringIdolConfig {
// Bean declaration methods go here
}
The @Configuration annotation serves as a clue to Spring that this class will contain
one or more Spring bean declarations. Those bean declarations are just methods that
are annotated with @Bean . Let’s see how to use @Bean to wire beans using Spring’s Java-
based configuration.
The actual creation of the bean is defined in the method body. Because it’s all Java, you gain some benefit
in terms of compile-time checking to ensure that your bean’s type is a real type and
that its ID is unique.
//----------
Then, whenever we refer to that method in another bean declaration method, Spring
will intercept the call to the method and try to find the bean in its context instead of
letting the method create a new instance.
//---------
Logging, security,and transaction management are important, but should they be activities that your
application objects are actively participating in? Or would it be better for your applica-
tion objects to focus on the business domain problems they’re designed for and leave
certain aspects to be handled by someone else?
//----------
In software development, functions that span multiple points of an application are
called cross-cutting concerns. Typically, these cross-cutting concerns are conceptually
separate from (but often embedded directly within) the application’s business logic.
Separating these cross-cutting concerns from the business logic is where aspect-
oriented programming ( AOP ) goes to work.
//-----------
Whereas DI helps you decouple your application
objects from each other, AOP helps you decouple cross-cutting concerns from the
objects that they affect.
//------
This chapter explores Spring’s support for aspects, including how to declare regu-
lar classes to be aspects and how to use annotations to create aspects. In addition,
you’ll see how AspectJ—another popular AOP implementation—can complement
Spring’s AOP framework.
//-------
In short, a cross-cutting concern can be described as any functionality that affects multiple points of an
application.
//-----------
Figure 4.1 represents a typical application
that’s broken down into modules. Each mod-
ule’s main concern is to provide services for its
particular domain. But each module also
requires similar ancillary functionalities, such
as security and transaction management.
A common object-oriented technique for
reusing common functionality is to apply
inheritance or delegation. But inheritance can
lead to a brittle object hierarchy if the same
base class is used throughout an application, 
and delegation can be cumbersome because
complicated calls to the delegate object may be required.
//--------
Aspects offer an alternative to inheritance and delegation that can be cleaner in
many circumstances. With AOP , you still define the common functionality in one
place, but you can declaratively define how and where this functionality is applied
without having to modify the class to which you’re applying the new feature. Cross-
cutting concerns can now be modularized into special classes called aspects. This has
two benefits. First, the logic for each concern is now in one place, as opposed to being
scattered all over the code base. Second, our service modules are now cleaner since
they only contain code for their primary concern (or core functionality) and second-
ary concerns have been moved to aspects.
//-----------
In AOP terms,the job of an aspect is called advice.
A join point is a point in the execution of the application where an aspect can be plugged in. This point could
be a method being called, an exception being thrown, or even a field being modified.
These are the points where your aspect’s code can be inserted into the normal flow of
your application to add new behavior.
Pointcuts help nar-row down the join points advised by an aspect.
If advice defines the what and when of aspects, then pointcuts define the where. A
pointcut definition matches one or more join points at which advice should be woven.
Often you specify these pointcuts using explicit class and method names or through
regular expressions that define matching class and method name patterns.
If advice defines the what and when of aspects, then pointcuts define the where. A
pointcut definition matches one or more join points at which advice should be woven.
Often you specify these pointcuts using explicit class and method names or through
regular expressions that define matching class and method name patterns.
//---------
Weaving is the process of applying aspects to a target object to create a new proxied
object. The aspects are woven into the target object at the specified join points. The
weaving can take place at several points in the target object’s lifetime:
Compile time—Aspects are woven in when the target class is compiled. This
requires a special compiler. AspectJ’s weaving compiler weaves aspects this way.
Classload time—Aspects are woven in when the target class is loaded into the
JVM . This requires a special ClassLoader that enhances that target class’s byte-
code before the class is introduced into the application. AspectJ 5’s load-time
weaving ( LTW ) support weaves aspects in this way.
Runtime—Aspects are woven in sometime during the execution of the applica-
tion. Typically, an AOP container will dynamically generate a proxy object that
will delegate to the target object while weaving in the aspects. This is how
Spring AOP aspects are woven.
That’s a lot of new terms to get to know. Revisiting figure 4.2, you can now see how
advice contains the cross-cutting behavior that needs to be applied to an application’s
objects. The join points are all the points within the execution flow of the application
that are candidates to have advice applied. The pointcut defines where (at what join
points) that advice is applied. The key concept you should take from this is that point-
cuts define which join points get advised.
Now that you’re familiar with some basic AOP terminology, let’s see how these core
AOP concepts are implemented in Spring.
//---------
In Spring, aspects are woven into Spring-managed beans at runtime by wrapping them
with a proxy class. As illustrated in figure 4.3, the proxy class poses as the target bean,
intercepting advised method calls and forwarding those calls to the target bean.
Between the time when the proxy intercepts the method call and the time when it
invokes the target bean’s method, the proxy performs the aspect logic.
Spring doesn’t create a proxied object until that proxied bean is needed by the
application. If you’re using an ApplicationContext , the proxied objects will be 
created when it loads all of the beans from the BeanFactory . Because Spring creates proxies
 at runtime, you don’t need a special compiler to weave aspects in Spring’s AOP .
//--------
Because it’s based on dynamic proxies, Spring only supports method join points.
//-------
In Spring AOP , pointcuts are defined using AspectJ’s pointcut expression language.
}//
//--------
springidol-aop/src/main/resources/com/springinaction/springidol/spring-idol-2.xml
//---------
Around advice has an advantage over before and after advice in this regard. With
around advice, you can accomplish the same thing as you can with distinct before and
after advice, but do it in a single method. Since the entire set of advice takes place in a
single method, there’s no need to retain state in a member variable.
//--------
}
//------
{
spring scope prototype与singleton区别
2016-10-09by coin, 7690次阅读
1、singleton作用域
　　当一个bean的作用域设置为singleton, 那么Spring IOC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。换言之，当把一个bean定义设置为singleton作用域时，Spring IOC容器只会创建该bean定义的唯一实例。这个单一实例会被存储到单例缓存（singleton cache）中，并且所有针对该bean的后续请求和引用都将返回被缓存的对象实例。
     这里要注意的是singleton作用域和GOF设计模式中的单例是完全不同的，单例设计模式表示一个ClassLoader中只有一个class存在，而这里的singleton则表示一个容器对应一个bean，也就是说当一个bean被标识为singleton时候，spring的IOC容器中只会存在一个该bean。
 
2、prototype
　　prototype作用域部署的bean，每一次请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）都会产生一个新的bean实例，相当与一个new的操作，对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个prototype bean的整个生命周期负责，容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。
      不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法，而对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责。（让Spring容器释放被singleton作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用。）
    scope="prototype"没写的问题,项目中对一个表的增删该操作是用一个action，这个actionadd,update,delete,save这些方法， 添加和修改是共用一个页面，当页面得到id时代表进行的修改操作，反之是添加操作。因为在配置spring的bean是忘了写scope="prototype" 所以每次添加时都显示最后一次访问过的记录,scope="prototype" 会在该类型的对象被请求 时创建一个新的action对象。如果没有配置scope=prototype则添加的时候不会新建一个action，他任然会保留上次访问的过记录的信息 webwork的Action不是线程安全的，要求在多线程环境下必须是一个线程对应一个独立的实例，不能使用singleton。所以，我们在Spring配置Webwork Action Bean时，需要加上属性scope=”prototype”或singleton=”false”。
     singleton模式指的是对某个对象的完全共享，包括代码空间和数据空间，说白了，如果一个类是singleton的，假如这个类有成员变量，那么这个成员变量的值是各个线程共享的（有点类似于static的样子了），当线程A往给变量赋了一个值以后，线程B就能读出这个值。
      因此，对于前台Action，肯定不能使用singleton的模式，必须是一个线程请求对应一个独立的实例。推而广之，只要是带数据成员变量的类，为了防止多个线程混用数据，就不能使用singleton。对于我们用到的Service、Dao，之所以用了singleton，就是因为他们没有用到数据成员变量，如果谁的Service需要数据成员变量，请设置singleton=false。 有状态的bean都使用Prototype作用域，而对无状态的bean则应该使用singleton作用域。
}
//---------
2017-07-31,
{
Spring,
创建java bean的方法：1、XML配置，ApplicationContext；
2、@Configuration+beanID方法+<context:component-scan>+ApplicationContext；
3、@Component、@Controller、@Repository、@Service、@Qualifier+<context:component-scan>+ApplicationContext；
}
//-------
{
nginx,redis,
(http://blog.csdn.net/column/details/niginxsourcelearning.html),
(http://blog.csdn.net/chen19870707/article/details/41050379),
(http://blog.csdn.net/chen19870707);
//------
nginx源码剖析,
(http://blog.csdn.net/column/details/niginxsourcelearning.html);
//--------
基于redis分布式缓存实现（新浪微博案例）,
(http://blog.csdn.net/guoqmao/article/details/52169053);
}
//-----
{
spring,(http://www.iteye.com/blogs/subjects/Spring_jiwenke);
spring开发组;
}
//-------------
{
In the grand tradition of software development, an acronym has been created to
describe transactions: ACID . In short, ACID stands for
Atomic—Transactions are made up of one or more activities bundled together
as a single unit of work. Atomicity ensures that all the operations in the transac-
tion happen or that none of them happen. If all the activities succeed, the trans-
action is a success. If any of the activities fails, the entire transaction fails and is
rolled back.
Consistent—Once a transaction ends (whether successful or not), the system is
left in a state consistent with the business that it models. The data shouldn’t be
corrupted with respect to reality.
Isolated—Transactions should allow multiple users to work with the same data,
without each user’s work getting tangled up with the others. Therefore, transac-
tions should be isolated from each other, preventing concurrent reads and
writes to the same data from occurring. (Note that isolation typically involves
locking rows and/or tables in a database.)
Durable—Once the transaction has completed, the results of the transaction
should be made permanent so that they’ll survive any sort of system crash. This
typically involves storing the results in a database or some other form of persis-
tent storage.
}
//-----------
{
JDBC transactions
If you’re using straight JDBC for your application’s persistence, DataSource-
TransactionManager will handle transactional boundaries for you. To use Data-
SourceTransactionManager , wire it into your application’s context definition using
the following XML :
<bean id="transactionManager" class="org.springframework.jdbc.
➥ datasource.DataSourceTransactionManager">
<property name="dataSource" ref="dataSource"/>
</bean>
Note that the dataSource property is set with a reference to a bean named data-
Source . Presumably, the dataSource bean is a javax.sql.DataSource bean defined
elsewhere in your context definition file.
Behind the scenes, DataSourceTransactionManager manages transactions by mak-
ing calls on the java.sql.Connection object retrieved from the DataSource . For
instance, a successful transaction is committed by calling the commit() method on the
connection. Likewise, a failed transaction is rolled back by calling the rollback()
method
}
//-------------
{
To specify one or more Spring configuration files for ContextLoaderListener to
load, set the contextConfigLocation parameter in the servlet context:
<context-param>
<param-name>contextConfigLocation</param-name>
<param-value>
/WEB-INF/spitter-security.xml
classpath:service-context.xml
classpath:persistence-context.xml
classpath:dataSource-context.xml
</param-value>
</context-param>
The contextConfigLocation parameter is specified as a list of paths. Unless specified
otherwise, the paths are relative to the application root. But since our Spring configu-
ration is split across multiple XML files that are scattered across several JAR files in the
web application, we’ve prefixed some of them with classpath: to load them as
resources from the application classpath and others with a path local to the web
application.
}
//------
{
@Resource
@Autowired
}
//-----
{
spring单元测试:
@Slf4j
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"classpath:applicationContext.xml","classpath:springmvc-servlet.xml"})
}
//--------
{
数据库,(https://www.zhihu.com/question/62464757/answer/206613596);
网络爬虫；
}
//------------
{
 依赖冲突的解决办法;
}
//-----------
{
Spring In Action(The 4th Edition),
//-----
Spring’s fundamental mission: Spring simplifies Java development.
//-------
That’s a bold statement! A lot of frameworks claim to simplify something or other.
But Spring aims to simplify the broad subject of Java development. This begs for more
explanation. How does Spring simplify Java development?
To back up its attack on Java complexity, Spring employs four key strategies:
Lightweight and minimally invasive development with POJO s
Loose coupling through DI and interface orientation
Declarative programming through aspects and common conventions
Eliminating boilerplate code with aspects and templates
Almost everything Spring does can be traced back to one or more of these four 
strategies.
//-------
The act of creating associations between application components is commonly
referred to as wiring. In Spring, there are many ways to wire components together, but
a common approach has always been via XML.
If XML configuration doesn’t suit your tastes, you might like to know that Spring
also allows you to express configuration using Java.(@Configuration,@Bean).
Whether you use XML -based or Java-based configuration, the benefits of DI are the
same.
//------
In a Spring application, an application context loads bean definitions and wires them
together. The Spring application context is fully responsible for the creation of and
wiring of the objects that make up the application. Spring comes with several imple-
mentations of its application context, each primarily differing only in how it loads its
configuration.
//-----------
Although DI makes it possible to tie software components together loosely, aspect-
oriented programming ( AOP ) enables you to capture functionality that’s used
throughout your application in reusable components.
//----------
AOP makes it possible to modularize these services and then apply them declaratively
to the components they should affect. This results in components that are more cohe-
sive and that focus on their own specific concerns, completely ignorant of any system
services that may be involved.
//---------
In a Spring-based application, your appli-
cation objects live in the Spring container.
Spring container
As illustrated in figure 1.4, the container
creates the objects, wires them together,
configures them, and manages their com-
plete lifecycle from cradle to grave (or new
to finalize() , as the case may be).
//-----------
Spring comes with several container imple-
mentations that can be categorized into two distinct types. Bean factories (defined by
the org.springframework.beans.factory.BeanFactory interface) are the simplest
of containers, providing basic support for DI . Application contexts (defined by the
org.springframework.context.ApplicationContext interface) build on the notion
of a bean factory by providing application-framework services, such as the ability to
resolve textual messages from a properties file and the ability to publish application
events to interested event listeners.
//-----------
Spring comes with several flavors of application context. Here are a few that you’ll
most likely encounter:
AnnotationConfigApplicationContext —Loads a Spring application context
from one or more Java-based configuration classes
AnnotationConfigWebApplicationContext —Loads a Spring web application
context from one or more Java-based configuration classes
ClassPathXmlApplicationContext —Loads a context definition from one or
more XML files located in the classpath, treating context-definition files as class-
path resources
FileSystemXmlApplicationContext —Loads a context definition from one or
more XML files in the filesystem
XmlWebApplicationContext —Loads context definitions from one or more
XML files contained in a web application.
//----------
The act of creating these associations between application objects is the essence of
dependency injection ( DI ) and is commonly referred to as wiring.
//--------
When it comes to expressing a bean wiring specification,
Spring is incredibly flexible, offering three primary wiring mechanisms:
Explicit configuration in XML
Explicit configuration in Java
Implicit bean discovery and automatic wiring
//----------
Spring attacks automatic wiring from two angles:
Component scanning—Spring automatically discovers beans to be created in the
application context.
Autowiring—Spring automatically satisfies bean dependencies.
Working together, component scanning and autowiring are a powerful force and can
help keep explicit configuration to a minimum.
//---------
With no further configuration, @ComponentScan will default to scanning the same
package as the configuration class. Therefore, because CDPlayerConfig is in the
soundsystem package, Spring will scan that package and any subpackages underneath
it, looking for classes that are annotated with @Component . It should find the Compact-
Disc class and automatically create a bean for it in Spring.
If you’d rather turn on component scanning via XML configuration, then you can
use the <context:component-scan> element from Spring’s context namespace. Here
is a minimal XML configuration to enable component scanning.
//----------
(Listing 2.4 Enabling component scanning in XML)
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd">
<context:component-scan base-package="soundsystem" />
</beans>
//----------
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=CDPlayerConfig.class)
//---------
}
{
Spring测试示例:
//------
/*
Listing 2.3 Wiring beans @ComponentScan enables component scanning
With no further configuration, @ComponentScan will default to scanning the same
package as the configuration class. Therefore, because CDPlayerConfig is in the
soundsystem package, Spring will scan that package and any subpackages underneath
it, looking for classes that are annotated with @Component . It should find the Compact-
Disc class and automatically create a bean for it in Spring.
*/
package soundsystem;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
@Configuration
@ComponentScan
public class CDPlayerConfig {
}
//------
package soundsystem;
import static org.junit.Assert.*;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=CDPlayerConfig.class)
public class CDPlayerTest {
@Autowired
private CompactDisc cd;
@Test
public void cdShouldNotBeNull() {
assertNotNull(cd);
}
}
CDPlayerTest takes advantage of Spring’s SpringJUnit4ClassRunner to have a Spring
application context automatically created when the test starts. And the @Context-
Configuration annotation tells it to load its configuration from the CDPlayerConfig
class. Because that configuration class includes @ComponentScan , the resulting applica-
tion context should include the CompactDisc bean.
//------
}

{
Naming a component-scanned bean
//--------
@Component("lonelyHeartsClub")
@Named("lonelyHeartsClub")
Spring supports the @Named annotation as an alternative to @Component . There are a
few subtle differences, but in most common cases they’re interchangeable.
}
{
Setting a base package for component scanning:
//-------
@Configuration
@ComponentScan(basePackages="soundsystem")
public class CDPlayerConfig {}
//--------
@Configuration
@ComponentScan(basePackages={"soundsystem", "video"})
public class CDPlayerConfig {}
//--------
Rather than specify the packages as simple String values, @ComponentScan also
offers you the option of specifying them via classes or interfaces that are in the
packages:
@Configuration
@ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class})
public class CDPlayerConfig {}
As you can see, the basePackages attribute has been replaced with basePackage-
Classes . And instead of identifying the packages with String names, the array given
to basePackageClasses includes classes. Whatever packages those classes are in will
be used as the base package for component scanning.
//-------
Although I’ve specified component classes for basePackageClasses , you might
consider creating an empty marker interface in the packages to be scanned. With a
marker interface, you can still have a refactor-friendly reference to an interface, but
without references to any actual application code (that could later be refactored out
of the package you intended to component-scan).
}
{
Put succinctly, autowiring is a means of letting Spring automatically satisfy a bean’s
dependencies by finding other beans in the application context that are a match to
the bean’s needs. To indicate that autowiring should be performed, you can use
Spring’s @Autowired annotation.
//-----
The @Autowired annotation’s use isn’t limited to constructors. It can also be used on a
property’s setter method.
//---------
Actually, there’s nothing special about setter methods. @Autowired can also be
applied on any method on the class.
//---------
Whether it’s a constructor, a setter method, or any other method, Spring will attempt
to satisfy the dependency expressed in the method’s parameters. Assuming that one
and only one bean matches, that bean will be wired in.
//---------
If there are no matching beans, Spring will throw an exception as the application
context is being created. To avoid that exception, you can set the required attribute
on @Autowired to false :
@Autowired(required=false)
public CDPlayer(CompactDisc cd) {
this.cd = cd;
}
When required is false , Spring will attempt to perform autowiring; but if there are no
matching beans, it will leave the bean unwired. You should be careful setting required
to false , however. Leaving the property unwired could lead to NullPointer-
Exception s if you don’t check for null in your code.
//---------
@Inject comes from the Java Dependency Injection specification, the same specifica-
tion that gave us @Named . Spring supports the @Inject annotation for autowiring
alongside its own @Autowired . Although there are some subtle differences between
@Inject and @Autowired , they’re interchangeable in many cases.
//---------
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=CDPlayerConfig.class)
//----------
}
{
C2.3
//----------
Although automatic Spring configuration with component scanning and automatic
wiring is preferable in many cases, there are times when automatic configuration isn’t
an option and you must configure Spring explicitly. For instance, let’s say that you
want to wire components from some third-party library into your application.
Because you don’t have the source code for that library, there’s no opportunity to
annotate its classes with @Component and @Autowired . Therefore, automatic configu-
ration isn’t an option.
In that case, you must turn to explicit configuration. You have two choices for
explicit configuration: Java and XML .
//--
The @Bean annotation tells Spring that this method will return an object that should
be registered as a bean in the Spring application context. The body of the method
contains logic that ultimately results in the creation of the bean instance.
If you’d rather it have a different name, you can either rename the method or prescribe a different
name with the name attribute:
@Bean(name="lonelyHeartsClubBand")
public CompactDisc sgtPeppers() {
return new SgtPeppers();
}
//----
The simplest way to wire up beans in JavaConfig is to refer to the referenced bean’s method.
@Bean
public CDPlayer cdPlayer() {
return new CDPlayer(sgtPeppers());
}
It appears that the CompactDisc is provided by calling sgtPeppers , but that’s not
exactly true. Because the sgtPeppers() method is annotated with @Bean , Spring will
intercept any calls to it and ensure that the bean produced by that method is returned
rather than allowing it to be invoked again.
//------
By default, all beans in Spring are singletons.
//-----
@Bean
public CDPlayer cdPlayer(CompactDisc compactDisc) {
return new CDPlayer(compactDisc);
}
//----
Here, the cdPlayer() method asks for a CompactDisc as a parameter. When Spring
calls cdPlayer() to create the CDPlayer bean, it autowires a CompactDisc into the
configuration method. Then the body of the method can use it however it sees fit.
With this technique, the cdPlayer() method can still inject the CompactDisc into the
CDPlayer ’s constructor without explicitly referring to the CompactDisc ’s @Bean
method.
//------
This approach to referring to other beans is usually the best choice because it
doesn’t depend on the CompactDisc bean being declared in the same configuration
class. In fact, there’s nothing that says the CompactDisc bean even needs to be
declared in JavaConfig; it could have been discovered by component scanning or
declared in XML . You could break up your configuration into a healthy mix of config-
uration classes, XML files, and automatically scanned and wired beans. No matter how
the CompactDisc was created, Spring will be happy to hand it to this configuration
method to create the CDPlayer bean.
//--------
2.4 Wiring beans with XML
Before you can start using XML to wire together beans in Spring, you’ll need to create
the empty configuration specification. With JavaConfig, that meant creating a class
annotated with @Configuration . For XML configuration, that means creating an XML
file rooted with a <beans> element.
//------------------
2.5 Importing and mixing configurations
@Configuration
public class CDConfig {
@Bean
public CompactDisc compactDisc() {
return new SgtPeppers();
}
}
@Configuration
@Import(CDConfig.class)
public class CDPlayerConfig {
@Bean
public CDPlayer cdPlayer(CompactDisc compactDisc) {
return new CDPlayer(compactDisc);
}
}
//----
@Configuration
@Import({CDPlayerConfig.class, CDConfig.class})
public class SoundSystemConfig {
}
//---
@Configuration
@Import(CDPlayerConfig.class)
@ImportResource("classpath:cd-config.xml")
public class SoundSystemConfig {
}
//------------
<bean class="soundsystem.CDConfig" />
<import resource="cdplayer-config.xml" />
//--------
}
{
Spring defines several scopes under which a bean can be created, including the
following:
Singleton—One instance of the bean is created for the entire application.
Prototype—One instance of the bean is created every time the bean is injected
into or retrieved from the Spring application context.
Session—In a web application, one instance of the bean is created for each session.
Request—In a web application, one instance of the bean is created for each
request.
Singleton scope is the default scope, but as we’ve discussed, it isn’t ideal for mutable
types. To select an alternative type, you can use the @Scope annotation, either in con-
junction with the @Component annotation or with the @Bean annotation.
//-------
@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class Notepad { ... }
Here, you specify prototype scope by using the SCOPE_PROTOTYPE constant from the
ConfigurableBeanFactory class. You could also use @Scope("prototype") , but using
the SCOPE_PROTOTYPE constant is safer and less prone to mistakes.

Alternatively, if you’re configuring the Notepad bean as a prototype in Java config-
uration, you can use @Scope along with @Bean to specify the desired scoping:
@Bean
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public Notepad notepad() {
return new Notepad();
}
//---------
}
{
//---------
3.5、Runtime value injection:
Other times, however, you may want to avoid
hard-coded values and let the values be determined at runtime. For those cases,
Spring offers two ways of evaluating values at runtime:
Property placeholders
The Spring Expression Language ( S p EL )
//----------
3.5.1、Injecting external values
The simplest way to resolve external values in Spring is to declare a property source
and retrieve the properties via the Spring Environment . For example, the following
listing shows a basic Spring configuration class that uses external properties to wire up
a BlankDisc bean.
Listing 3.7 Using the @PropertySource annotation and Environment
package com.soundsystem;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;
@Configuration
@PropertySource("classpath:/com/soundsystem/app.properties")
public class ExpressiveConfig {
@Autowired
Environment env;
@Bean
public BlankDisc disc() {
return new BlankDisc(
env.getProperty("disc.title"),
env.getProperty("disc.artist"));
}
//----------
In this example, @PropertySource references a file named app.properties in the class-
path. It might look something like this:
disc.title=Sgt. Peppers Lonely Hearts Club Band
disc.artist=The Beatles
This properties file is loaded into Spring’s Environment , from which it can be
retrieved later.
//-------
getProperty() is overloaded into four variations:
String getProperty(String key)
String getProperty(String key, String defaultValue)
T getProperty(String key, Class<T> type)
T getProperty(String key, Class<T> type, T defaultValue)
//---------------
}
{
In Spring wiring, placeholder values are property names wrapped with ${ ... } .
When relying on component-scanning and autowiring to create and initialize your
application components, there’s no configuration file or class where you can specify
the placeholders. Instead, you can use the @Value annotation in much the same way as
you might use the @Autowired annotation. In the BlankDisc class, for example, the
constructor might be written like this:
public BlankDisc(
@Value("${disc.title}") String title,
@Value("${disc.artist}") String artist) {
this.title = title;
this.artist = artist;
}
In order to use placeholder values, you must configure either a PropertyPlaceholder-
Configurer bean or a PropertySourcesPlaceholderConfigurer bean. Starting with
Spring 3.1, PropertySourcesPlaceholderConfigurer is preferred because it resolves
placeholders against the Spring Environment and its set of property sources.
The following @Bean method configures PropertySourcesPlaceholderConfigurer
in Java configuration:
@Bean
public
static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {
return new PropertySourcesPlaceholderConfigurer();
}
If you’d rather use XML configuration, the <context:property-placeholder /> 
ele-ment from Spring’s context namespace will give you a PropertySourcesPlaceholderConfigurer bean:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd">
<context:property-placeholder />
</beans>
Resolving external properties is one way to defer value resolution until runtime, but
its focus is finely tuned on resolving properties, by name, from Spring’s Environment
and property sources.
}
//---------
{
With a strong foundation in bean wiring established, we’ll now turn our attention to
aspect-oriented programming ( AOP ). Much as dependency injection helps decouple
components from the other components they collaborate with, AOP helps decouple
your application components from tasks that span multiple components in an applica-
tion.
//-------
Weaving is the process of applying aspects to a target object to create a new proxied
object. The aspects are woven into the target object at the specified join points.
Runtime—Aspects are woven in sometime during the execution of the applica-
tion. Typically, an AOP container dynamically generates a proxy object that del-
egates to the target object while weaving in the aspects. This is how Spring AOP
aspects are woven.

Spring’s support for AOP comes in four styles:
Classic Spring proxy-based AOP
Pure- POJO aspects
@AspectJ annotation-driven aspects
Injected AspectJ aspects (available in all versions of Spring)

Whatever the case, the ability to
create pointcuts that define the join points at which aspects should be woven is what
makes it an AOP framework.

Spring’s support for AOP comes in four styles:
Classic Spring proxy-based AOP
Pure- POJO aspects
@AspectJ annotation-driven aspects
Injected AspectJ aspects (available in all versions of Spring)
The first three styles are all variations on Spring’s own AOP implementation. Spring
AOP is built around dynamic proxies. Consequently, Spring’s AOP support is limited
to method interception.

All the advice you create in Spring is written in a standard Java class. That way, you get
the benefit of developing your aspects in the same integrated development environ-
ment ( IDE ) you’d use for normal Java development. The pointcuts that define where
advice should be applied may be specified with annotations or configured in a Spring
XML configuration, but either will be familiar to Java developers.

Because ampersands have special meaning in XML , you’re free to use and in place
of && when specifying pointcuts in a Spring XML -based configuration. Likewise, or
and not can be used in place of || and !, respectively.

Spring adds a bean() designator that
lets you identify beans by their ID in a pointcut expression. bean() takes a bean ID or
name as an argument and limits the pointcut’s effect to that specific bean.
For example, consider the following pointcut:
execution(* concert.Performance.perform())
and bean('woodstock')
Here you’re saying that you want to apply aspect advice to the execution of
Performance’s perform() method, but limited to the bean whose ID is woodstock.

//-------
package concert;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;
@Configuration
@EnableAspectJAutoProxy
@ComponentScan
public class ConcertConfig {
@Bean
public Audience audience() {
return new Audience();
}
Enable AspectJ
auto-proxying
Declare
Audience bean
}

If, however, you’re using XML to wire your beans in Spring, then you need to use the
<aop:aspectj-autoproxy> element from Spring’s aop namespace. The XML config-
uration in the following listing shows how this is done.
Listing 4.4
Enable
AspectJ auto-
proxying
Enabling AspectJ auto-proxying in XML using Spring’s aop namespace
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
Declare
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
Spring’s aop
xmlns:context="http://www.springframework.org/schema/context"
namespace
xmlns:aop="http://www.springframework.org/schema/aop"
xsi:schemaLocation="http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd">
<context:component-scan base-package="concert" />
<aop:aspectj-autoproxy />
<bean class="concert.Audience" />
</beans>

It’s important to understand that Spring’s AspectJ auto-proxying only uses
@AspectJ annotations as a guide for creating proxy-based aspects. Under the covers,
it’s still Spring’s proxy-based aspects. This is significant because it means that although
you’re using @AspectJ annotations, you’re still limited to proxying method invoca-
tions. If you want to be able to exploit the full power of AspectJ, you’ll have to use the
AspectJ runtime and not rely on Spring to create proxy-based aspects.
//-------
@Aspect

@EnableAspectJAutoProxy
@Bean
@Configuration

@Pointcut
@Before,...;
}
//---------
{
Because ampersands have special meaning in XML , you’re free to use and in place
of && when specifying pointcuts in a Spring XML -based configuration. Likewise, or
and not can be used in place of || and !, respectively.
}
//--------
{
spring MVC,
//--------
When the request leaves the browser , it carries information about what the user
is asking for.At the least, the request will be carrying the requested URL .
The first stop in the request’s travels is at Spring’s DispatcherServlet . Like most Java-
based web frameworks, Spring MVC funnels requests through a single front controller
servlet. A front controller is a common web application pattern where a single servlet
delegates responsibility for a request to other components of an application to per-
form actual processing. In the case of Spring MVC , DispatcherServlet is the front
controller.
The DispatcherServlet ’s job is to send the request on to a Spring MVC controller.
A controller is a Spring component that processes the request. But a typical application
may have several controllers, and DispatcherServlet needs some help deciding
which controller to send the request to. So the DispatcherServlet consults one or
more handler mappings C to figure out where the request’s next stop will be. The
handler mapping pays particular attention to the URL carried by the request when
making its decision.
Once an appropriate controller has been chosen, DispatcherServlet sends the
request on its merry way to the chosen controller D . At the controller, the request
drops off its payload (the information submitted by the user) and patiently waits while
the controller processes that information. (Actually, a well-designed controller per-
forms little or no processing itself and instead delegates responsibility for the business
logic to one or more service objects.)
The logic performed by a controller often results in some information that needs
to be carried back to the user and displayed in the browser. This information is
referred to as the model. But sending raw information back to the user isn’t suffi-
cient—it needs to be formatted in a user-friendly format, typically HTML . For that, the
information needs to be given to a view, typically a JavaServer Page ( JSP ).
One of the last things a controller does is package up the model data and identify
the name of a view that should render the output. It then sends the request, along
with the model and view name, back to the DispatcherServlet E .
So that the controller doesn’t get coupled to a particular view, the view name
passed back to DispatcherServlet doesn’t directly identify a specific JSP . It doesn’t
even necessarily suggest that the view is a JSP . Instead, it only carries a logical name
that will be used to look up the actual view that will produce the result. The
DispatcherServlet consults a view resolver F to map the logical view name to a spe-
cific view implementation, which may or may not be a JSP .
Now that DispatcherServlet knows which view will render the result, the
request’s job is almost over. Its final stop is at the view implementation G , typically a
JSP , where it delivers the model data. The request’s job is finally done. The view will
use the model data to render output that will be carried back to the client by the (not-
so-hardworking) response object H .
As you can see, a request goes through several steps along its way to producing a
response for the client. Most of these steps take place within the Spring MVC frame-
work, in the components shown in figure 5.1. Although the bulk of this chapter will
focus on writing controllers, let’s take a moment to set up the essential components of
Spring MVC .
}
{
Spring不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。
　　@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。
　　@Resource装配顺序
　　1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常
　　2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常
　　3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常
　　4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；
}
//-------------------
{
mysql> select * from employee_onduty_table;
mysql> select * from employee_onduty_table\G;
两个的输出内容一致，格式不同；
}
//------------------
{
2017-08-02,
值班表系统修改：
1、修改“值班管理模块”，展示一个页面，在页面内选择值班模块，修改值班序列和值班步长(也就是值班人数)，默认每人每天值班一次；暂不考虑休假事宜。
2、浮层展示当天值班信息。
3、改造数据库，增加一个字段表示步长，也就是每天的值班人数，每个值班模块的步长可能不同。
4、根据state字段确认当天是否安排值班。在周一到周五买水果模块的state字段默认是1，表示安排值班；在周六周日state字段的默认值是0，表示不安排值班。
}
//-------
2017-08-03,
{
值班表系统，
线上机:l-scmdata.des.cn5 
跳板机:l-rtools1.ops.cn5
进入mysql的命令:stat
数据库是:crm_statistic;
数据表是:employee_onduty_table ;
}
//----------
{
(http://gitlab.corp.qunar.com/groups/scm),mdc;
酒店审核相关的问题--韩鹏涛;
酒店聚合相关的问题--李刚;
房型相关的的问题--严红樟;
}
//------------
{
2017-08-04，
//---------
布隆过滤器；
}
//----------
{
gitlab常用命令示例:
git add -A
git commit -m 'wjt,170804'
git checkout master
git pull
git checkout watchdog_170802
git merge master
//-------
git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。
//---------
git push --set-upstream origin wjt_170804
gitk --all
git remote -v
git log
git reset --hard <commit标识符号串>
git revert <commit标识符号串>
//--------
git <cmd_name> --help
//-----
git diff,需要学习;
#将当前分支和指定的分支branch_name作对比
git diff <branch_name>
#将两次提交的commit作对比:
git diff <a-commit标识符> <b-commit标识符>
}
{
git reset --hard和git revert命令:
reset是指将当前head的内容重置，不会留任何痕迹。
revert是撤销某次提交，但是这次撤销也会作为一次提交进行保存（这样就不会丢失原来修改过，但是没有提交的内容）
}
{
回滚到之前的版本的一种方法(示例):
git checkout d6284cb81299b68f8371a5cfaafdd25a0a09fdb0 
强行覆盖(示例):
git push -f origin  watchdog_170802
}
{
git cola
}
//-------
Qunar.201351
Qunar.201721
//----------
    <parent>
        <groupId>com.qunar.des.scm</groupId>
        <artifactId>scm-root</artifactId>
        <version>1.0.12</version>
    </parent>
//------------------
crm_dev
Velocity
//---------
6f4748a3fb15e95e7fdc135a298e314b47203373
//------------
{
28款GitHub最流行的开源机器学习项目,(http://www.cnblogs.com/hellochennan/p/5423776.html);
//------
史上最浅显易懂的Git教程！,(http://blog.csdn.net/asklxf/article/details/10131835);
}
//----------
{
同步请求，异步请求,(important);
Ajax;
DOM;jQuery;
}
//-----
QCI
//----------
{
idea+Maven,(http://maven.apache.org/enforcer/enforcer-rules/index.html);
(/home/linux2014/WJT_2017/projects/qunar_projects/170806_2/watchdog);
}
//--------
{
git,易百教程,(http://www.yiibai.com/git/git_push.html);
}
//------
{
Qunar.201351
Qunar.4832
Qunar.201721
}
//-------
{
ssh jintao.wang@l-noahd85wi7vl1.auto.beta.cn0.qunar.com
/home/q/www/scm.watchdog.qunar.com
http://l-noahd85wi7vl1.auto.beta.cn0.qunar.com:8098/duty/update.htm
//---------
10.86.62.188:8098
//--------
Noah的发布、配置方法;
//----------
shuang.gao;yangi.li;xinya.song;weixing.zhou;guangyan.yao;baoqiu.xiao;jintao.wang;zijing.zhang;weigui.li;baoqiu.xiao
}
{
tomcat怎样配置,启动过程;
//------------
chrome,调试,F12,network;
//--------
}
//------
{
用命令行查看tomcat的端口:
1、先到tomcat配置文件查看tomcat的端口是什么，配置文件一般是：$CATALINA_HOME/conf/server这个文件，查找
<Connector port="8080" redirectPort="8443" connectionTimeout="20000" protocol="HTTP/1.1"/>这一行。这里，端口是8080。
2、使用netstat 命令查看占用情况
netstat -ap |grep 8080 //查找tomcat端口是否被占用
3、其他
netstat -tln   //表示以数字形式查看正在监听的端口
netstat -ap   //查看所有应用占用端口情况
}
//--------------
{
2017-08-07,排错方法总结;
}
//------
{
ssh jintao.wang@http://l-noahd85wi7vl1.auto.beta.cn0.qunar.com
l-noahd85wi7vl1.auto.beta.cn0.qunar.com:8098
sudo /home/q/tools/bin/restart_tomcat.sh scm.watchdog.qunar.com
}
{
在本机连接Noah测试机MySQL数据库(http://noah.corp.qunar.com/database/index.htm?t=test&workgroupId=-1&namespace=&standdbname=):
mysql -h 10.93.25.64 -P 3306 -u qa -p
hWyIT1a3P57E6cxc
USE crm_statistic;
SELECT * FROM employee_onduty_table\G;
}
{
ajax前端向后端传参示例:
//-------
        $.ajax({
            type: "GET",
            url: url,
            data: {qtalkId:$("#addQtalk").val(),onDutyModule:$("#addModuleName").val()},
            dataType: "json",
            asysnc:false,
            success: function (result) {
                if(result.data != null){
                    alert(result.data)
                }else {
                    alert(result.message)
                }
            }
        });
//-----
    @RequestMapping("/add.json")
    @ResponseBody
    public ApiResult add(@RequestParam(value = "qTalkId") String qTalkId, @RequestParam(value = "startDate", required = false) String startDate)
//----
}
//------------
/home/linux2014/WJT_2017/projects/qunar_projects/170806_watchdog/watchdog/watchdog-main/src/main/webapp/WEB-INF/views/memcached/statsItems.vm
-Xdebug -Xrunjdwp:transport=dt_socket,address=60222,suspend=n,server=y
//---------
{
Linux命令大全,(http://man.linuxde.net/diff);
(http://www.cnblogs.com/wangqiguo/p/5793448.html);
$diff -y --suppress-common-lines
}
{
1、在本机调试，以提高开发效率；
2、配置文件都在project的profiles文件夹下或QConfig(http://qconfig.corp.qunar.com/view/profileInfo.do?group=h_scm_watchdog&profile=dev:)；
}
//--------
{
2017-08-10,
//------------
leader,代码review指导:
1、每个函数都应该是较细粒度的，功能专一，分支尽可能少，逻辑清晰，便于单元测试。执行基本功能的函数功能专一；执行复合功能的函数应该是逻辑清晰，总体流程简单，
下级功能由专门的下级函数完成。这样逻辑清晰，圈复杂度较低，便于单元测试。
2、时序图，总体设计和详细设计。
3、研读代码规范、代码重构之类的好书。
4、数据库的主键、索引、编码。
5、数据库查询一定是有限制的，可以用where做限制，亦可用limit做限制，一是为了信息安全，二是为了防止数据记录占用内存过多。
6、数据表查询时要转换为对主键的查询，不要查询字符串候选码，因为它受编解码的影响太大。
}
//-----
{
官方文档翻译：mysql的索引——innodb索引（1）聚簇索引和次级索引,(http://www.cnblogs.com/wyeat/p/translation_mysql_innodb_index.html);
主键就是聚簇索引，所有其他索引查询都会先找聚簇索引，然后再找记录。
}
//-----
{
每天发日报，用邮件发给leader。
内容:做了什么，遇到什么问题，有啥写啥。
}
//-------
{
employee.vm,怎样显示值班安排;
Task,任务接口;
}
{
Qunar,配置,(http://qschedule.corp.qunar.com/jobs/edit.do?jobName=hotel.scm.watchdog.task.duty),
controb用法,(http://www.cnblogs.com/cocowool/archive/2009/04/22/1441291.html);
Qschedule,(http://wiki.corp.qunar.com/confluence/display/devwiki/qschedule);
}
{
在Noah首页(http://noah.corp.qunar.com/public/env/index.htm?t=my)点击wd，进入项目环境页，找到自己的项目，点击对应的>_，即可进入QTerminal；
//----------
在QTerminal查看日志的命令:
[n-jintao.wang@l-noahd85wi7vl1.auto.beta.cn0 /home/q/www/scm.watchdog.qunar.com/logs]$ tail -f -n 500 catalina.out
或：
$tail -f -n 500 /home/q/www/scm.watchdog.qunar.com/logs/catalina.out
}
//---------
{
添加idea远程调试功能时，对Noah的配置方法:
[n-jintao.wang@l-noahd85wi7vl1.auto.beta.cn0 /home/q/www/scm.watchdog.qunar.com]$ sudo vim startenv.sh
$sudo vim /home/q/www/scm.watchdog.qunar.com/startenv.sh
添加内容(-Xdebug -Xrunjdwp:transport=dt_socket,address=60222,suspend=n,server=y)；
重启使之生效：
$sudo /home/q/tools/bin/restart_tomcat.sh scm.watchdog.qunar.com
或:
[n-jintao.wang@l-noahd85wi7vl1.auto.beta.cn0 /home/q/tools/bin]$ sudo ./restart_tomcat.sh scm.watchdog.qunar.com
}
//---------
{
爬虫,(https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/5162711?fr=aladdin);
(http://www.csdn.net/article/2015-11-13/2826205),
(http://blog.csdn.net/huangxy10/article/details/8120106)
}
//------
{
国家信访局    
地 址：北京市西城区月坛南街8号邮 编：100017电 话：010—68015310网 址: http://www.gjxfj.gov.cn    
}
{
部门	接访大厅地址	联系电话	邮编	网上信访网址
省接访大厅	郑州市纬三路35号	0371-65905012  0371-65905013	450003	http://wsxfdt.hnxf.gov.cn/sy/initPlatform.action?alias=HA_2_455
平顶山市	平顶山市祥云路与清风路交叉口西南	0375-2692626	467000	http://wsxfdt.hnxf.gov.cn/sy/initPlatform.action?alias=ODPS41040000_3_455
}
//------------------
{
guava,(http://outofmemory.cn/java/guava/Collections/Iterators);
//----
远程调试,jmx,(https://my.oschina.net/aiguozhe/blog/104478);
//---------
}
//-------
{
软件开发经典书籍：
《代码大全》，《重构：改善既有代码的设计》，《代码整洁之道》。
//-----[
学习html,css,js;
W3School,(http://www.w3school.com.cn/);
(https://www.w3cschool.cn/htmltags/tag-select.html);
(http://www.w3school.com.cn/jsref/index.asp);
json,(http://www.w3school.com.cn/json/json_syntax.asp);
AJAX,(http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_response.asp),(http://www.w3school.com.cn/ajax/);
js参考手册,(http://www.w3school.com.cn/jsref/index.asp);
HTML,(http://www.w3school.com.cn/html/html_layout.asp);
HTML5,(http://www.w3school.com.cn/html5/index.asp);
菜鸟教程,html,js,(http://www.runoob.com/js/js-cookies.html);
}
{
//-----------
<script> 标签
如需在 HTML 页面中插入 JavaScript，请使用 <script> 标签。
<script> 和 </script> 会告诉 JavaScript 在何处开始和结束。
<script> 和 </script> 之间的代码行包含了 JavaScript：
<script>
alert("My First JavaScript");
</script>
您无需理解上面的代码。只需明白，浏览器会解释并执行位于 <script> 和 </script> 之间的 JavaScript。
那些老旧的实例可能会在 <script> 标签中使用 type="text/javascript"。现在已经不必这样做了。JavaScript 是所有现代浏览器以及 HTML5 中的默认脚本语言。
外部的 JavaScript
也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。
外部 JavaScript 文件的文件扩展名是 .js。
如需使用外部文件，请在 <script> 标签的 "src" 属性中设置该 .js 文件：
实例
<!DOCTYPE html>
<html>
<body>
<script src="myScript.js"></script>
</body>
</html>
//-----------
分号 ;
分号用于分隔 JavaScript 语句。
通常我们在每条可执行的语句结尾添加分号。
使用分号的另一用处是在一行中编写多条语句。
提示：您也可能看到不带有分号的案例。
在 JavaScript 中，用分号来结束语句是可选的。
JavaScript 代码
JavaScript 代码（或者只有 JavaScript）是 JavaScript 语句的序列。
浏览器会按照编写顺序来执行每条语句。
//-----------
}
{
核显
独显
大黄蜂
//-----
苏宁易购，裤子,(https://product.suning.com/0070092167/630235343.html###);
}
//----------------
{
权限验证
软删除
数据库读取员工信息
}
{
前后端分离的具体编程实现方法;
QSSO;
chrome,F12,preserve log,请求的转发过程;
//-----
wireshark,
(http://blog.csdn.net/sanjiaozhen/article/details/49440551),
(http://www.cr173.com/html/20128_all.html);
filter
http and ip.addr == 192.168.1.106 and tcp.port == 8080
apply
右键,follow TCP  Stream;
}
{
spring,(http://blog.csdn.net/xlgen157387/article/details/45290799);
(http://www.cnblogs.com/whtydn/p/5128103.html);
(http://www.cnblogs.com/duguheilang/p/5340070.html);
(http://blog.csdn.net/think_soft/article/details/49678429);
}
{
Spring框架Web页面乱码问题
在做java Web 项目时，乱码问题时常都会出现，解决方法也不尽相同，有简单也有复杂的；如果加入了Spring框架之后就不一样了，可以采用Spring框架自带的过滤 器CharacterEncodingFilter，这样可以大大减轻了我们的工作量，即简单方便又容易理解，配置方式如下：在web.xml文件中 filter的位置加上如下内容：
<filter>
<filter-name>encodingFilter</ filter-name >
<filter-class>
org.springframework.web.filter.CharacterEncodingFilter
</filter-class>
<init-param>
<param-name>encoding</param-name>
<param-value>UTF-8</param-value>
</init-param>
<init-param>
<param-name>forceEncoding</param-name>
<param-value>true</param-value>
</init-param>
</filter>
<filter-mapping>
<filter-name>encodingFilter</filter-name>
<url-pattern>*</url-pattern>
</filter-mapping>
}
//-------------------
2017-08-17,
{
qsso在qunar的实现;
//--------
时刻关注群消息，及时行动；
安装google代理;
//---------
(chrome-extension://padekgcemlokbadohgkifijomclgjgif/options.html#/profile/proxy)
}
{
leader推荐的web原理资料:
(http://www.cnblogs.com/EzrealLiu/p/5559255.html),
(http://bubkoo.com/2014/04/21/http-cookies-explained/),
《构建高性能Web站点》;
}
//----------------------
{
苏宁易购,(https://order.suning.com/onlineOrder/orderList.do);
PhoneNo:17600485175
Pwd:linux201721
}
//--------
{
学步园,
(http://www.xuebuyuan.com/);
//------------
爱沙河,(http://ishahe.net/portal.php);
}
//----------
{
sudo dpkg -i graphviz_2.38.0-1-saucy_amd64.deb
(http://neitui.zhiye.com/qunar)
Shadowsocks-Qt5
}
//----------------------
2017-08-21,
//-------------
{
从今天起，两周内学习完《代码大全》，每天自测。
//------
mybatis-spring,(http://www.mybatis.org/spring/zh/index.html),
(https://github.com/liyifeng1994/ssm),
(http://blog.csdn.net/zhshulin/article/details/37956105),
(http://www.cnblogs.com/best/p/5638827.html),
(http://www.importnew.com/22880.html),
(http://blog.csdn.net/eson_15);
}
{
classpath 和 classpath* 区别： 
classpath：只会到你的class路径中查找找文件; 
classpath*：不仅包含class路径，还包括jar文件中(class路径)进行查找. 
classpath*的使用：当项目中有多个classpath路径，并同时加载多个classpath路径下（此种情况多数不会遇到）的文件，*就发挥了作用，如果不加*，则表示仅仅加载第一个classpath路径，代码片段： 
Java代码  收藏代码
<param-value>classpath*:context/conf/controller*.xml</param-value>  
在多个classpath中存在同名资源，都需要加载， 
那么用classpath:只会加载第一个，这种情况下也需要用classpath*:前缀 
注意： 
用classpath*:需要遍历所有的classpath，所以加载速度是很慢的，因此，在规划的时候，应该尽可能规划好资源文件所在的路径，尽量避免使用classpath*。
}
{
如果javas实现，watchdog需要增加权限拦截，只处理用户是否在crm系统中且登陆即可，无需处理权限。
//---------
(http://pmo.corp.qunar.com/browse/DZS-17244)
}
//----------------------
{
/home/q/www/scm.watchdog.qunar.com
(http://qterminal.corp.qunar.com/pages/terminal.html?host=l-noahd85wi7vl1.auto.beta.cn0.qunar.com#/server)
}
//----------------------
{
spring+mybatis，排查错误：
tail -f -n 500 catalina.out
grep Exception catalina.out
grep scmMultiDataSource catalina.out -C 20
tail -f -n 500 catalina.out
grep validateConnection catalina.out -C 20
tail -f -n 500 catalina.out
resolve 10.86.37.202
host 10.86.37.202
ping l-redis5.dba.dev.cn0.qunar.com
查找类/接口；由接口查找实现类;
}
//------------
{
测试修改的代码:
DutyConfigureService
watchdog/service/QtalkToNameFunction.java
CrateMonitorTask
MemcachedMonitorTask
DataMonitorTask
OndutyInfoUpdateTask
}
//------------
(http://gitlab.corp.qunar.com/scm/watchdog/tree/DZS-17244);
//----------
{
Noah测试环境的创建,(http://wiki.corp.qunar.com/confluence/display/~haibo.yu/Noah);
(http://noah.corp.qunar.com/env/project/detail.htm?envId=25854);
供应链/项目环境/wjt ( 环境ID:25854 );
nginx.IP:10.90.167.121
}
//-------------
2017-8-22,
{
leader review代码总结:
1、格式化代码；代码要参考开发规范(java,sql)，代码要整洁，统一(Autowired,Resource)；不可上传target内的任何代码；
2、maven管理依赖，记得每个模块的依赖和继承的依赖，不要重复引入依赖，浪费时间；
3、实现某些复杂的功能之前，一定要参考相关教程、网站资源、优秀开源项目源码，不可自以为是；例如cache；
4、及时学习跟进，以满足项目需要，一次学会，不可再犯同样的错误(例如import *；不可上传废弃的文件，要保持代码的整洁)；
5、先跟得上，才能融入团队，才会有发展的机会；
7、要按项目开发的科学流程来高效推进，否则劳而无功；要明白maven对java项目管理方法，不可乱引，解耦；
}
{
缓存技术资源,
(http://blog.csdn.net/zhangzeyuaaa/article/details/42673245),
(http://www.importnew.com/23980.html);
}
//---------
{
idea更改快捷键，
File->Settings->KeyMap;
}
//-------------
{
    <!--配置文件-->
    <context:property-placeholder location="classpath:memcached.properties,
                      classpath:crate.properties,
                      classpath:database.properties,
                      classpath:mail.properties" ignore-unresolvable="true"/>
                      
}
//-----------------
{
建群，将相关人员拉入同一个群，有话公开说。
//--------
供应链/项目环境/wjt ( 环境ID:25906 )
}
//----------------------
{
供应链/项目环境/wjt ( 环境ID:25906 )
10.86.50.200	scm.qunar.com
http://scm.qunar.com/onduty/allOndutyInfo.htm
http://neitui.zhiye.com/qunar
http://10.86.50.200:8098/onduty/allOndutyInfo.htm
/onduty/allOndutyInfo.htm
}
//---------
{
2017-08-23,
登录跳板机:ssh jintao.wang@l-rtools1.ops.cn0.qunar.com
passcode是:自设密码和token码;
登录beta机:ssh jintao.wang@l-crm11.des.beta.cn0.qunar.com
进入qunar operation service,(http://ops.corp.qunar.com/);
进入(http://ops.corp.qunar.com/ops/account/)，找到Passphrase，按要求输入；
项目和相关文件都部在/home/q/目录下；
watchdog的相关文件在目录(/home/q/www/scm.watchdog.qunar.com)下;
nginx的相关文件在目录(/home/q/nginx)下;
进入watchdog所在的线上机,(ssh jintao.wang@l-scmdata.des.cn5.qunar.com);
一个应用的线上机是固定的。
//---------
http://l-crm11.des.beta.cn0.qunar.com:8098/onduty/allOndutyInfo.htm
}
//---------
{
nginx的配置:
//------
{
upstream scm_watchdog {
	server 127.0.0.1:8098;
}
//---
location ~ /onduty/ {
proxy_pass              http://scm_watchdog;
proxy_buffering         off;
proxy_set_header        Host $host;
proxy_set_header        X-Real-IP $remote_addr;
proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_connect_timeout   3s;
proxy_read_timeout      30s;
}
//--------
}
//-------
{
weixing.zhou;shuang.gao;yangi.li;xinya.song;guangyan.yao;jintao.wang;zijing.zhang;weigui.li;baoqiu.xiao
guangyan.yao;shuang.gao;xinya.song;weigui.li;weixing.zhou;baoqiu.xiao;bo.li
}
{
postman,
前后端数据交流;
POST提交数据,(https://imququ.com/post/four-ways-to-post-data-in-http.html);
查看线上机日志;
}
//------------
{
以后日报抄送到:
crm-dev@qunar.com
//---------
1. 从阅读代码，画流程图开始 
2. 光有想法，没有行动，就是好高骛远，清晰一致的目标和执行的结合，才能产生实际的成果。对工作和问题的思考与总结，不断纠正你前行的方向。思想的高度决定你人生的高度。
3.别人的流程图那是人家的理解，你自己画出来的认知上肯定不一样。
}
//---------------
{
mysql --default-character-set=utf8 -uqa -phWyIT1a3P57E6cxc -hl-crm11.des.beta.cn0.qunar.com -P3306 crm_statistic
QA，betaf发布,(http://hscqa.beta.qunar.com/home#L2pvYjt1bmRlZmluZWQ7R0VU);
QA,脑图测试,(http://hscqa.beta.qunar.com/suite/viewMindmap?id=747);
}
//------------
{
sudo  dpkg  -i StarUML-v2.8.0-64-bit.deb
//------
添加值班人时，一定要检查qtalk是否在合法范围内;
}
//-----------
{
周六计划望京西地铁站集合
}
//---------
{
开发总结：
软件系统的整体需求分析、每项需求的功能实现；
公共接口的抽象，底层具体实现；
//--------
1、前端页面组件，组件的属性,数据的输入、提取、显示；
好多坑，例如$("#组件id").val()，document.getElementById("组件id").value；
select组件,var selectObj = document.getElementById("selectId");选中的选项的索引:selectObj.selectedIndex，选中的选项:selectObj.options[selectObj.selectedIndex]，
利用该对象提取用户选择信息;但是动态设置选项得用$("#selectId").empty()、$("#selectId").append()函数；
2、前后端数据交流；
ajax，POST方法，contentType,async;
3、项目框架,程序功能模块间的关系，内部的构成，pom依赖；
3、接口、实现，抽象与具体；
4、代码规范；
5、公司的dev、beta、release环境；
6、发布流程：发布时要注意尽量避免影响原来的系统和其他相关的系统，防止数据丢失，避免影响系统的用户；一般是先提交增加数据库字段的sql，再停止用户的权限，再洗数据，发布新的系统代码，同时关注日志和系统报警，及时通知因发布系统造成的报警，发布完之后要验证，确保没错才能恢复用户权限，提交删除废弃字段的SQL，如果发布或验证的过程中出错，要回滚系统代码；
}
{
这个需求发布后，写一个完整的项目总结
邮件给我，抄送crm-dev
你可以先写在你的wiki上 
}
//------
{
ssh jintao.wang@l-rtools1.ops.cn5.qunar.com
ssh jintao.wang@l-scmdata.des.cn5.qunar.com
http://
}
//------------
{
http://scm.corp.qunar.com/index.jsp
http://l-crm11.des.beta.cn0.qunar.com:8098/onduty/allOndutyInfo.htm
}
//-----------
{
//---------
origin  git@gitlab.corp.qunar.com:scm/watchdog.git (push)
}
//------
{
java网络爬虫,(http://www.cnblogs.com/Jims2016/p/5877300.html);
Linux系统优化,(http://www.it168.com/redian/linuxmr/);
}
//----------
2017-08-28,
//-----
{
值班表系统:
铺满今天之后的值班信息；
//--------
发布流程用时序图画出来；
遇到的问题要清楚地讲述，用图表示，要确保一次性解决；
}
//--------
{
Maven学习记录3——创建、编译、打包、运行项目,(http://blog.csdn.net/yaya1943/article/details/48464371);
Maven编译代码的相关命令,(http://www.cnblogs.com/exmyth/archive/2013/04/17/3026432.html);
}
{
UML建模之时序图（Sequence Diagram）,(http://www.cnblogs.com/ywqu/archive/2009/12/22/1629426.html);
(http://www.cnblogs.com/vipygd/p/3175256.html);
(http://blog.csdn.net/shulianghan/article/details/17927131);
(http://blog.csdn.net/bzhxuexi/article/details/44152453);
(http://www.cnblogs.com/vipygd/p/3175256.html);
UML和设计模式,(http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html);
(http://www.cnblogs.com/ywqu/archive/2009/12/22/1629426.html);
(http://smartlife.blog.51cto.com/1146871/284874);
}
//---------
{
一个进程对外提供网络服务，才会被分配一个端口号。
而netstat命令可用于查看所有网络服务进程的统计信息，包括端口号。
所以要根据端口号查看占用的进程，可用netstat命令。
netstat -ap | grep <portNo>
(lsof -i:<portNo>,只能查看打开文件的进程);
这时可以看到占用该端口的进程的pid，用ps -ef | grep <pid>命令可以查看该进程的信息；
查到了占用指定端口号的进程的pid，可用命令kill <pid>停止该进程，从而释放出该端口号。
//----
(http://man.linuxde.net/netstat);
(http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html);
//----
}
{
top,(https://my.oschina.net/leejun2005/blog/157910);
linux进程剖析在网页面下方;
Linux内存和IO,(http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html)；
top -p <pid> -d <delay_seconds>
}
//---------
{
buffer 与cache 的区别
A buffer is something that has yet to be “written” to disk. A cache is something that has been “read” from the disk and stored for later use 从应用程序角度来看，buffers/cached 是等于可用的，因为buffer/cached是为了提高文件读写的性能，当应用程序需在用到内存的时候，buffer/cached会很快地被回收。
所以从应用程序的角度来说，可用内存 = 系统free memory + buffers + cached.
}
//---------
{
ps：用于显示当前进程的状态（非动态）
ps [options]:
选项有三种风格：
1、UNIX风格，必须在选项前面加“-”
2、BSD风格，选项前不能加“-”
3、GNU风格，选项前为两个“-”
常用组合之一：aux
a：所有与终端相关的进程
x：所有与终端无关的进程
u：以用户为中心组织进程状态信息显示
//------
常用组合之二：-ef
-e：显示所有进程
-f：显示完整格式的进程信息
//------
常用组合之三：-eFH
-F：显示完整格式的进程信息；
C： cpu utilization cpu占用百分比
PSR：运行于哪颗CPU之上
-H：以层级结构显示进程的相关信息；
//---------
}
{
程序师,(http://www.techug.com/);
GeeksforGeeks ,(http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/);
}
{
下载安装配置tomcat，练习应用；
熟悉其底层工作原理；
}
//------------
{
brainy software,(http://www.brainysoftware.com/);
}
//---------
{
git 连接远程仓库方法:
方案一 : 本地创建项目根目录, 然后与远程Git关联, 之后的操作一样：
#创建新文件夹
mkdir xxx
#进入
cd xxx 
#初始化Git仓库 
git init
#提交改变到缓存
git commit -m 'description'
#本地git仓库关联GitHub仓库 
git remote add origin git@github.com:han1202012/TabHost_Test.git
#提交到GitHub中 
git push -u origin master
方案二 : 方案二就是不用关联Git仓库, 直接从Git中克隆源码到本地, 项目根目录也不用创建;
#从GitHub上克隆项目到本地 
git clone git@github.com:han1202012/NDKHelloworld.git #注意克隆的时候直接在仓库根目录即可, 不用再创建项目根目录 ;
#添加文件 
git add ./*  # 将目录中所有文件添加;
#提交缓存 
git commit -m '提交';
#提交到远程GitHub仓库 
git push -u origin master ;
}
//--------
{
Qunar技术资料,(http://qtown.corp.qunar.com/knowledge/list.html?albumDirId=124);
}
{
单元测试：针对时间边界的单元测试；
}
//----------
DZS-17563
{
XML约束：
DTD,schema;(https://www.ibm.com/developerworks/cn/xml/x-sd/index.html);
}
//------
{
当日事，当日毕！
每天、每周、每周期都要回顾、总结、自测当天的学习、工作内容。
}
//-----------
{
A red-black tree with n internal nodes has height at most  2*log(2,n+1);
}
//-----------
2017-08-30,
{
单点登录;
运行task;
添加更多的节假日,(查wiki);
发布流程的时序图;
整明白一两个项目;
CSDN、wiki内流程图的画法。
}
{
1、一次性添加多行注释的快捷键
首先选中要注释区域，然后
ctrl+/        这个是多行代码分行注释，每行一个注释符号
ctrl+shift+/    这个是多行代码注释在一个块里，只在开头和结尾有注释符号
2、取消多行注释快捷键
怎样添加快捷键的，用相同方法取消，
如 ctrl+/  添加注释，则ctrl+/取消注释
ctrl+shift+/添加注释，则ctrl+shift+/取消注释
}
{
代码里将多条件判断处理转化为循环的方法和好处；
}
//--------
{
cookie为什么和域名关联;
域名系统，域名解析方法和流程；
}
{
domain的设置，有两点要注意：
1.在setcookie中省略domain参数，那么domain默认为当前域名。
2.domain参数可以设置父域名以及自身，但不能设置其它域名，包括子域名，否则cookie不起作用。
那么cookie的作用域：
cookie的作用域是domain本身以及domain下的所有子域名。
}
{
一次登录与一次退出。 回头看看普通商场的故事，什么东西才是保持登录状态关键的东西？记录器（session）？那种叫做cookie的纸张？写在纸张上的ID? 是session里面记录的信息跟那个ID，cookie只不是记录ID的工具而已。客户端持有ID，服务端持有session，两者一起用来保持登录状态。客户端需要用ID来作为凭证，而服务端需要用session来验证ID的有效性（ID可能过期、可能根本就是伪造的找不到对于的信息、ID下对应的客户端还没有进行登录验证等）。但是session这东西一开始是每个server自己独有的，豆瓣FM有自己的session、豆瓣读书有自己的session，而记录ID的cookie又是不能跨域的。所以，我们要实现一次登录一次退出，只需要想办法让各个server的共用一个session的信息，让客户端在各个域名下都能持有这个ID就好了。再进一步讲，只要各个server拿到同一个ID，都能有办法检验出ID的有效性、并且能得到ID对应的用户信息就行了，也就是能检验ID[1]  。
}
//---------
2017-08-31,
//--------
技术博客集,(http://blog.csdn.net/hongchangfirst);
//---------
{
命令行创建本地库：

初始化一个本地Git仓库(把本地的文件夹初始化成一个Git可以管理的版本库)
git init

执行完该命令，该文件夹下就会生成.git文件夹。
此时该版本库没有和任何远程仓库关联，需要用远程仓库(一个或多个)和该版本库建立关联:
git remote add <远程仓库名> <远程仓库地址>

至此，一个可用的本地版本库已经建成。之后就可以执行git pull,git push等命令了。
//----
示例:
git init
git remote add origin ttps://github.com/wjt2015/wjt_train_170622_170831.git
git pull
}
{
git分支的增删查:

创建新的分支:
git branch <newBranchName>

切换到一个已经存在的分之:
git checkout <branchName>

创建并切换到一个新分支:
git checkout -b <newBranchName>

删除本地分支:
git branch -d branchName

强制删除本地分支:
git branch -D branchName

删除远程分支(注意：冒号前面的空格不能少，相当于把一个空分支push到server上，等于删除该分支):
git push origin :branchName

查看本地所有分支:
git branch

查看远程所有分支:
git branch -r

查看所有分支:
git branch -a

给本地分支设置一个远程上游分支：git push –set-upstream origin <remoteBranchName>
推送一个本地分支到远程分支：git push origin <localBranch>:<remoteBranch>
从远程分支拉取到本地分支：git push origin <remoteBranch>:<localBranch>

}
{
本地分支和远程分支的关联：

给本地分支设置一个远程上游分支：
git push –set-upstream origin <remoteBranchName>

推送一个本地分支到远程分支：
git push origin <localBranch>:<remoteBranch>

从远程分支拉取到本地分支：
git pull origin <remoteBranch>:<localBranch>

在执行git pull将远程分支拉取到本地远程分支后，在本地创建分支追踪远程分支：git checkout - -track <remoteBranch>。这里的<remoteBranch> 其实是本地远程分支。
}
{
git远程仓库的查看、添加、删除:

查看:
git remote -v

添加远程仓库
git remote add <远程仓库名> <git远程仓库地址>
示例:
 git remote add pb git://github.com/paulboone/ticgit.git
 git remote add wjt_train_170622_b1_romte https://github.com/wjt2015/wjt_train_170622_170831.git

取消本地仓库和远程仓库的关联：
git remote remove <远程仓库名>

查看远程仓库信息：
git remote show <远程仓库名>

远程仓库的重命名：
git remote rename <远程仓库的原名字> <远程仓库的新名字>

远程仓库的删除：
git remote rm <远程仓库的名字>

显式指定远程仓库，以拉取、或上传代码：
git fetch <远程仓库名>
git pull <远程仓库名>
git push <远程仓库名>
}
//-------
{
代码回滚:
本地代码库回滚示例：
git reset --hard commit-id :回滚到commit-id，讲commit-id之后提交的commit都去除
git reset --hard HEAD~3：将最近3次的提交回滚
}
{
查看git操作日志:
git log
}
{
对比文件差异(以下的这些命令如不指定文件，则比较仓库内的所有文件):

diff里面a表示前面那个变量，b表示第二个变量。
HEAD     commit版本;Index     staged版本。

查看工作区文件相对于暂存区文件的差异：
git diff <fname>

查看本分支和另一分支文件的差异：
git diff <branchName> <fname>

查看暂存区和本地仓库内文件的差异：
git diff --cached <commit> <filename>

查看工作目录和本地仓库内文件的差异：
git diff <commitID> <filename>

查看同一仓库内两次提交之间指定文件的差别：
git diff <commitID> <commitID> <fname>
//----
以上命令可以不指定 <filename>，则对全部文件操作。
以上命令涉及和 Git仓库 对比的，均可指定 commit 的版本。
HEAD 最近一次 commit
HEAD^ 上次提交
HEAD~100 上100次提交
每次提交产生的哈希值
//-------
}
{
分支合并:

将名字为branchName的分支合并到当前分支:
git merge <branchName>
}
//---------------
{
web压力测试工具，(http://blog.csdn.net/lansetiankong12/article/details/50144417)；
}
//------
{
格式化,qunar;
import *;
单行注释和多行注释的差别(//,/**/);
异常；
报警；
监控；
代码要简洁，去除不必要的变量定义、赋值、函数返回值；
本机sonar检查器;
开发规范；
SQL规范；
日志规范；
qunar代码规范,(http://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=63243031);
CRM开发规范,(http://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=98571950);
}
{
系统代码分层:
controller,biz,service,dao;
}
{
CRM代码规范-日常需注意点:
增加注释(业务流程注释，属性注释)，提交前请格式化
写代码时请思考，你写的代码是否可以写单元测试
监控的添加, 对于外部系统调用的接口和对外提供的接口必须有监控，我们需要通过监控了解到系统整体的健康情况
SQL中禁用以下语句delete, on duplicate for update, select...for update
}
//---------
{
---------------- 在 Debian, Ubuntu 和 Linux Mint 上安装Guake(下拉式终端) ----------------
sudo apt-get update
apt-get install guake
}
{
值班表的权限管理、操作记录；
发布流程的时序图；
索引变化的单元测试；
配置文件内没有的直接显示qtalk；
}
{
wiki:
http://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=175604957
}
//-----------
2017-09-01,
//------------
{
linux常用命令总结:

whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。
whereis命令的使用实例：
$ whereis grep

which
which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。
which命令的使用实例：$ which grep

type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。
type命令的使用实例：
　　$ type cd
系统会提示，cd是shell的自带命令（build-in）。
　　$ type grep
系统会提示，grep是一个外部命令，并显示该命令的路径。
　　$ type -p grep
加上-p参数后，就相当于which命令。

grep -rn <pattern> <path>

find也可用正则表达式：
find ./ -name "*.xml" --print
}
//----------
{
时序图：
（1）简单消息
简单消息是没有区分同步和异步的消息。
 
（2）同步消息
消息的发送者把进程控制传递给消息的接收者，然后暂停活动，等待消息接收者的回应消息。（就是程序中的调用）
 
（3）异步消息
消息的发送者将消息发送给消息的接受者后，不用等待回应的消息，即可开始另一个活动。（就是程序中发消息给消息队列的操作）
（3）返回消息
主动发消息后消息的回馈，可画可不画
}
//------------
{
yangi.li;baoqiu.xiao;guangyan.yao;jintao.wang;zijing.zhang;weigui.li;weixing.zhou;haibo.yu;xinya.song;shuang.gao;
}
//------------------
{
１、时序图作为一种表示系统内对象交互的。
}
{
当天工作：
1、继续回顾总结了常用的linux命令的常用方法，以求熟练掌握，提高工作效率。
2、对值班表的索引递进过程建立本机单元测试，主要利用定向扫描方法控制扫描范围，避开线上资源的影响。
其中经常遇到创建Bean失败的异常，重新拉取一个分支，在分支上修改代码和xml配置文件，根据报错信息修改程序，
纠错的过程就是加深理解spring的过程。

心得体会：
1、善用linux命令有助于提高工作效率。
2、通过查看报错信息来纠正错误有助于加深对相关知识的理解。
}
//---------
(http://pmo.corp.qunar.com/browse/DZS-17793)
//------
架构探险-从零开始构建Java Web框架
//----------
dubbo,(http://dubbo.io/);
//-------
(http://pmo.corp.qunar.com/browse/DZS-17835);
//-------
{
知识的灵活应用，有时候想要保留本地分支，放弃远程分支的某些东西，而且本地分支落后于远程分支，这时可以删除远程分支，再git push，
即可得到与本地分支完全一致的远程分支。
}
//--------
{
Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。
ZooKeeper是一种分布式协调服务，用于管理大型主机。 在分布式环境中协调和管理服务是一个复杂的过程。 ZooKeeper通过其简单的架构和API解决了这个问题。
ZooKeeper允许开发人员专注于核心应用程序逻辑，而不必担心应用程序的分布式特性。
}
//--------
{
git知识,(https://backlogtool.com/git-tutorial/cn/intro/intro1_1.html),
(https://git-scm.com/book/zh/v2),
(https://git-scm.com/downloads);
//----
zookeeper,(https://www.w3cschool.cn/zookeeper/);
}
{
慕课网,(http://coding.imooc.com/?c=be);
51CTO博客,(http://pangge.blog.51cto.com/);
开源中国,(https://www.oschina.net/);
//---------
mysql日志,(https://my.oschina.net/u/205403/blog/85155),
(http://pangge.blog.51cto.com/6013757/1319304);
}
{
git merge的作用原理和效果；
idea应用git的方法;
}
//--------
{
qunar节假日判断,(http://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=63243270);
DateQuery;
//-----
duty项目的date-service内有代码示例；
}
//--------
{
需要学习dubbo的用法;
}
//---------
{
谨记：
(1)、每次更新代码前要注意当前分支，更新后要提交；
(2)、方法内部的自定义变量应该尽量少，需要的数据尽量作为参数传入，这样便于控制；
}
//----
scm.notify.zookeeper.address
//----
{
mvn clean;mvn compile
mvn clean;git add -A;git commit -m '测试值班表';git push --set-upstream
}
{
今日计划(2017-09-06)：
１、xml文件在spring配置中的应用,DTD,xsd,schema；
２、dubbo；
３、mysql日志；
４、权限管理和日志的基本原理与实现，编程实现demo；
(token、令牌环、java登录服务验证);
５、练习idea的单元测试环境配置和程序测试；
６、java注解；
７、java serialize；
８、java访问权限；
９、java异常；
10、synchronized；
11、transient；
11、三种设计模式(代理、观察者、命令、职责链)；
12、XML文件的解析方法,XSD,
(http://www.w3school.com.cn/schema/index.asp),
(https://my.oschina.net/itblog/blog/390001),
(http://www.jianshu.com/p/badce73c00bc),
(http://www.cnblogs.com/doit8791/p/5757798.html),
(https://my.oschina.net/itblog/blog/390001),
(http://www.jianshu.com/p/43aa940838d2?utm_campaign=maleskine&utm_content=note&utm_medium=pc_all_hots&utm_source=recommendation);
13、java内部类；
14、MD5；
15、java泛型；
16、java servlet、cookie；
17、how tomcat works；
18、回顾晋级积分系统源码；
19、spring in action;spring官网,(最权威的教程),(https://projects.spring.io/spring-framework/)；
20、《架构探险——从零开始写Java Web框架》；
21、跟开涛学习springMVC,(http://jinnianshilongnian.iteye.com/category/231099)；
22、linux命令curl和javaWeb后端工作原理，尤其是GET、POST、cookie；
23、日志功能的diff方法；
24、研究crm的三个项目(watchdog、mdc、duty、common)；
21、学习markdown,(http://blog.csdn.net/column/details/markdown.html),(http://blog.csdn.net/whqet)；
22、dubbo服务的原理和java调用方法；
23、如何查看一个接口的实现类，右键->find usages；
24、程序代码内加监控、日志、调用dubbo服务时要处理异常；
25、给定一个java注解，怎样查看其源码，理解其应用；
26、xsi、XML文件解析；
}
//-------
{
１、@Transactional注解的成员方法构成一个事务，当该函数执行完毕后，数据库数据才能更新；
２、java注解,(http://blog.csdn.net/mlljava1111/article/details/49928185)。
３、详细的java注解教程，不仅有注解定义、还有注解处理器，
(http://www.cnblogs.com/peida/archive/2013/04/23/3036035.html),(http://www.cnblogs.com/peida/archive/2013/04/26/3038503.html)。
} 
{
JAVA注解,
java5.0定义了四个元注解，用于注解其他注解，分别是：
@Documented，标记注解，用于标识一个注解是否可以被javadoc文档化；
@Inherited，标记注解，用于标识一个注解是否可以被继承；
@Target，指明了一个注解的作用对象，例如包、类、成员变量、成员方法、构造方法等，由枚举类型java.lang.annotation.ElementType指定；
@Retention，指明了一个注解的生命周期，也就是一个注解的有效时间范围，由枚举类型java.lang.annotation.RetentionPolicy指定。
}
{
根据java元注解自定义注解的基本方法：
使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。
在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。
方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。

　　定义注解格式：
　　public @interface 注解名 {定义体}
　　
　　注解参数可支持的数据类型有6类，分别是：
　　　　1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)
　　　　2.String类型
　　　　3.Class类型
　　　　4.enum类型
　　　　5.Annotation类型
　　　　6.以上所有类型的数组

　Annotation类型里面的参数的设定方法: 
　　第一,只能用public或默认(default)这两个访问权限修饰； 　
　　第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,
　　以及这一些类型的数组。
　　例如,String value();这里的参数成员类型就为String，参数名称是value，访问权限是default。　

注解处理器：
注解要发挥作用，需要和注解处理器结合起来。(http://www.cnblogs.com/peida/archive/2013/04/26/3038503.html);
Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。
除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：
Class：类定义
Constructor：构造器定义
Field：累的成员变量定义
Method：类的方法定义
Package：类的包定义
}
//------
{
linux下的各种工具软件用法详解,(http://linuxtools-rst.readthedocs.io/zh_CN/latest/),
(http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html);
//------
linux公社,(http://www.linuxidc.com/Linux/2014-08/106019.htm);
//-------
W. Richard Stevens' Home Page,(http://www.kohala.com/start/);
//-----------
开发者--(http://www.admin10000.com/),(http://www.admin10000.com/document/6768.html);
InfoQ,(http://www.infoq.com/cn?utm_source=infoq&utm_medium=breadcrumbs_feature&utm_campaign=breadcrumbs);
java tutorial,(https://www.tutorialspoint.com/java/index.htm);
天码营,(java web),(https://www.tianmaying.com/);
//----------
C/C++爬虫,(http://lifeofzjs.com/blog/2015/09/09/how-to-write-a-event-based-crawler-using-c/),
(https://github.com/zyearn/zhihuCrawler),
(http://lifeofzjs.com/blog/2015/09/09/how-to-write-a-event-based-crawler-using-c/),
(https://www.v2ex.com/t/245884),
(http://sxysxy.org/blogs/28),
(https://linux.cn/thread-14501-1-1.html),
(https://github.com/luohaha/CSpider/wiki/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8c%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%88%AC%E8%99%AB);
BloomFilter;
//---------
GNU C/C++,(https://www.gnu.org/software/libc/manual/html_node/Concept-Index.html#Concept-Index),
(https://www.gnu.org/software/libc/manual/html_node/index.html#SEC_Contents),
(https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html);
//-----
redis源码解析,(http://redissrc.readthedocs.io/en/latest/),(http://blog.csdn.net/column/details/redis-code.html),
(https://zhuanlan.zhihu.com/zeecoderRedis);
//---------
51CTO博客之星编程浪子朱云翔,(http://zhuyunxiang.blog.51cto.com/);
//---------
推荐几本学习MySQL的好书,(http://mingxinglai.com/cn/2015/12/material-of-mysql/);
//-------
linux命令、guava,(http://www.cnblogs.com/peida/archive/2012/12/19/2824418.html);
}
{
Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。
ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。
}
//-----
{
Qunar的服务分为三类：dev、beta、prod。
可在(http://cactus.dev.qunar.com/)的“服务治理”菜单下搜索、查看三类服务，
只要输入服务的关键字，即可搜索，(也可以搜索应用和机器)；
在机器(beta、prod)上查看服务的方法：
１、通过跳板机登录到beta或prod机器。
２、所有的服务都部署在/home/q/www/目录下，先进入此目录。
３、用ll命令可以看到有很多文件夹，每个文件夹对应一个服务，文件夹名字和服务名字一致。
４、每一个文件夹下都有一个webapps文件夹，每一个应用服务的代码文件都在webapps/ROOT下。
５、dubbo服务的配置文件是webapps/ROOT/WEB-INF/classes/zk.properties，
在该文件内的dubbo.port标识了dubbo接口，知道了这个dubbo接口，就可以说明该服务曾经部署在本机，
但不确定是否能连接，是否存活。
连接本机上的该服务的shell命令是:telnet 127.0.0.1 <dubbo.port>
如果连接被拒绝，说明没权限或该服务已经停止。
在本机查看该服务是否存活的命令是:ps -elf | grep <服务名字，也就是服务所在的文件夹名字>
用telnet命令成功连接上服务后，可以输入ls命令查看该服务的类或接口，
输入命令“ls <接口或类的完整限定名>”即可查看一个类的函数。
６、在每个服务文件夹下的conf/server.xml文件内可查看服务配置信息。
}
//---------
{
Qunar schedule的使用方法：
１、进入链接(http://qschedule.corp.qunar.com/jobs.do)。
２、从菜单项QSchedule内选择一项，dev、beta或prod，分别对应三种环境。
３、在任务名称一栏内输入具体的任务名称，搜索出该任务。
４、启动，立即执行，即可执行任务。
}
//-------
2017-09-07,
{
java注解,
}
{
静态代码检查器,(http://hao.jobbole.com/static_code_analysis_tool_list_opensource_lang/?utm_source=blog.jobbole.com&utm_medium=sidebar-resources):
１、Splint是一个辅助注释轻量级静态检查工具，检查C程序的安全漏洞和代码错误。作为一个更好的lint，使用Splint毫不费力。
如果投入额外的工作添加注释到程序中，Splint可以执行比任何标准lint能完成的更强的检查。
官网：http://www.splint.org/
GitHub：https://github.com/ravenexp/splint
//-----------
２、Checkstyle是一个开发工具，可以帮助程序员编写Java代码，并使其遵守编码标准。它自动执行检查Java代码的过程，使人们从这种无聊但是重要的任务中解放出来。
对于那些想要执行代码标准的项目，这是非常理想的。
Checkstyle是高配置的，几乎可以支持任何代码标准。
官网：http://checkstyle.sourceforge.net/
GitHub：https://github.com/checkstyle/checkstyle
//--------
３、KeY,
传统的说，Key过去是一个Java程序验证工具。虽然现在这仍然是它的主要应用之一，但是这些年来它已经成长为一个拥有各种领域应用的程序验证平台。当前最重要的应用是：
程序验证（独立的图形用户界面、Eclipse集成、KeYHoare）
调试（符号执行调试器）
信息流分析（安全）
测试用例产生（KeYTestGen）
我们一直致力于让Key框架更容易被其他程序访问。例如，在另一个工具的后台可以很容易的将Key当成一个符号执行引擎使用。正在进行的工作示例有Java编译器的建造，是一个基于Key创建的符号执行树。
官网：http://www.key-project.org/index.php
Key book：http://www.key-project.org/thebook2/
}
//----------
{
java序列化：
(https://www.tutorialspoint.com/java/java_serialization.htm),(java.io.Serializable源码);
Java provides a mechanism, called object serialization where an object can be represented as a sequence of bytes that includes the object's data 
as well as information about the object's type and the types of data stored in the object.
After a serialized object has been written into a file, it can be read from the file and deserialized that is, the type information and bytes 
that represent the object and its data can be used to recreate the object in memory.
Most impressive is that the entire process is JVM independent, meaning an object can be serialized on one platform and deserialized on an entirely different platform.
Classes ObjectInputStream and ObjectOutputStream are high-level streams that contain the methods for serializing and deserializing an object.
//----
Notice that for a class to be serialized successfully, two conditions must be met:
The class must implement the java.io.Serializable interface.
All of the fields in the class must be serializable. If a field is not serializable, it must be marked transient.
(the field is transient, this value was not sent to the output stream)
//-----
Serializability of a class is enabled by the class implementing the
 java.io.Serializable interface. Classes that do not implement this
interface will not have any of their state serialized or
deserialized.  All subtypes of a serializable class are themselves
serializable.  The serialization interface has no methods or fields
 and serves only to identify the semantics of being serializable. 
 //--------
The serialization runtime associates with each serializable class a version
number, called a serialVersionUID, which is used during deserialization to
verify that the sender and receiver of a serialized object have loaded
classes for that object that are compatible with respect to serialization.
If the receiver has loaded a class for the object that has a different
serialVersionUID than that of the corresponding sender's class, then
deserialization will result in an InvalidClassException.  A
serializable class can declare its own serialVersionUID explicitly by
declaring a field named "serialVersionUID" that must be static,
final, and of type long.
for example:
ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;
//-----------
transient用于修饰serializable类的非static数据成员，表示该成员不被序列化。
}
//---------
{
A daemon process output some message,syslog,syslogd;
进程组，一个或更多个进程构成的集合，一个进程组通常关联一个作业，每一个进程必属于某一个进程组，而且只能是一个；每一个进程组可以有一个leader进程，
leader进程的ID就是该进程组的ID；leader进程可以添加、删除组内进程。
一个进程组内只要有一个进程存在，该进程组就存在，与leader进程是否终止无关。 进程组的生命周期从被创建开始，到其内所有进程终止或离开该组。

shell可以同时运行一个前台作业和多个后台作业，每一个作业都可以由多个进程构成。

会话是进程组的集合，一个会话包含控制进程、一个前台进程组、任意个后台进程组。

(进程组就相当于一个班级，组长进程就像当于班长。会话就相当于是一个年级。一个年级有一个教务处。（控制终端）)

用户通过终端登录系统后得到一个Shell进程,这个终端称为Shell进程的控制终端。
建立与控制终端连接的会话首进程被称为控制进程。

作业与进程组的区别：如果作业中的某个进程又创建了子进程，则子进程不属于作业。一旦作业运行结束，
Shell就把自己提到前台，如果原来的前台进程还存在（如果这个子进程还没终止），它自动变为后台进程组。

同一会话中的进程通过该会话的领头进程和一个终端相连，该终端作为这个会话的控制终端。一个会话只能有一个控制终端，而一个控制终端只能控制一个会话。
用户通过控制终端，可以向该控制终端所控制的会话中的进程发送键盘信号。

同一会话中只能有一个前台进程组，属于前台进程组的进程可从控制终端获得输入，而其他进程均是后台进程，可能分属于不同的后台进程组。

当我们打开多个终端窗口时，实际上就创建了多个终端会话。每个会话都会有自己的前台工作和后台工作。
//--------
linux进程与会话linux进程与会话
}
{
《UNIX网络编程》,
//-----
recv(),send();
recvmsg(),sendmsg();
readv(),writev();
The readv and writev functions can be used with any descriptor, not just sockets. Also, writev is an atomic operation.

These two functions are the most general of all the I/O functions. Indeed, we could replace all
calls to read, readv, recv, and recvfrom with calls to recvmsg. Similarly all calls to the various
output functions could be replaced with calls to sendmsg.

Ancillary data can be sent and received using the msg_control and msg_controllen members of
the msghdr structure with the sendmsg and recvmsg functions. Another term for ancillary data is
control information.

Ancillary data consists of one or more ancillary data objects, each one beginning with a cmsghdr
structure, defined by including <sys/socket.h>.
struct cmsghdr {
socklen_t cmsg_len;
/* length in bytes, including this structure */
int
cmsg_level; /* originating protocol */
int
cmsg_type; /* protocol-specific type */
/* followed by unsigned char cmsg_data[] */
};
//----
How Much Data Is Queued?
fileno(),fdopen();
//---------
The problem here is the buffering performed automatically by the standard I/O library on the
server. There are three types of buffering performed by the standard I/O library:
1. Fully buffered means that I/O takes place only when the buffer is full, the process explicitly
calls fflush, or the process terminates by calling exit. A common size for the standard I/O
buffer is 8,192 bytes.
2. Line buffered means that I/O takes place when a newline is encountered, when the process
calls fflush, or when the process terminates by calling exit.
3. Unbuffered means that I/O takes place each time a standard I/O output function is called.
Most Unix implementations of the standard I/O library use the following rules:
Standard error is always unbuffered.
Standard input and standard output are fully buffered, unless they refer to a terminal
device, in which case, they are line buffered.
All other streams are fully buffered unless they refer to a terminal device, in which case,
they are line buffered.
//-------------
We can divide the socket calls that may block into four categories:
I/O,
Accepting incoming connections— This is the accept function.
Initiating outgoing connections— This is the connect function for TCP.
If the descriptor is readable or writable, we call getsockopt to fetch the socket's pending
error (SO_ERROR). If the connection completed successfully, this value will be 0. If the connection
encountered an error, this value is the errno value corresponding to the connection error (e.g.,
ECONNREFUSED, ETIMEDOUT, etc.).
//-------
Next is determining whether the connection completed successfully or not, if we cannot assume
that writability is the only way success is returned. Various solutions have been posted to Usenet.
These would replace our call to getsockopt in Figure 16.11.
1. Call getpeername instead of getsockopt. If this fails with ENOTCONN, the connection failed
and we must then call getsockopt with SO_ERROR to fetch the pending error for the socket.
2. Call read with a length of 0. If the read fails, the connect failed and the errno from read
indicates the reason for the connection failure. When a connection succeeds, read should
return 0.
3. Call connect again. It should fail, and if the error is EISCONN, the socket is already
connected and the first connection succeeded.
//---------
What happens if our call to connect on a normal blocking socket is interrupted, say, by a caught
signal, before TCP's three-way handshake completes? Assuming the connect is not automatically
restarted, it returns EINTR. But, we cannot call connect again to wait for the connection to
complete. Doing so will return EADDRINUSE.
What we must do in this scenario is call select, just as we have done in this section for a
nonblocking connect. select returns when the connection completes successfully (making the
socket writable) or when the connection fails (making the socket readable and writable).
//--------
getsockopt, setsockopt - get and set options on sockets
//---------
}
//----------
{
使用有道云笔记;
15236286736@163.com
15236286736wjt
17640048175
}
//----------
{
职责链模式：
1、处理者在运行时动态确定其实是我们在 Client 中组装的链所引起的，因为具体的职责逻辑就在链中一一对应起来；
2、因为不确定请求的具体处理者是谁，所以我们把所有可能的处理者组装成一条链，在遍历的过程中就相当于向每个处理者都提交了这个请求，等待其审查。
并且在审查过程中，即使不是最终处理者，也可以进行一些请求的“包装”操作（这种功能类似于装饰者模式），例如上面例子中的签名批准；
3、处理者集合的动态指定跟上面的第1、2点类似，即在 Client 类中创建了所有可能的处理者。
职责链模式对于请求的处理是不知道最终处理者是谁，所以是运行动态寻找并指定；而命令模式中对于命令的处理时在创建命令是已经显式或隐式绑定了接收者。
}
{
vim教程,
vim shiftwidth
:set shiftwidth=2
//----
绝对行位置
<n>G
相对行位置
+/-<n>
//-------
vim使用进阶教程,(http://easwy.com/blog/archives/advanced-vim-skills-catalog/);
//---------
从别的编辑器里粘贴到vim里的代码经常由于不正常的缩进变得格式混乱。在vim的官方FAQ （http://vimdoc.sourceforge.net/cgi-bin/vimfaq2html3.pl）找到的：
格式化全文(在普通模式下，不要输入冒号)： gg=G
自动缩进当前行： ==
这个是原文节选：
14.6. How do I format/indent an entire file?
You can format/indent an entire file using the gg=G command, where
     gg - Goto the beginning of the file
     =   - apply indentation
     G   - till end of file

For more information, read
     :help gg
     :help =
     :help G
     :help 'formatprg'
     :help C-indenting
//----------
如何更改vim默认的 “换行缩进值”
找到/etc/vimrc文件在文件，用vim将其打开，在此文件开头加上如下
1）设置（软）制表符宽度为4：
set tabstop=4
set softtabstop=4
2）设置缩进的空格数为4
set shiftwidth=4
3）设置自动缩进：即每行的缩进值与上一行相等；使用 noautoindent 取消设置：
set autoindent
4）设置使用 C/C++ 语言的自动缩进方式：
set cindent
5）设置C/C++语言的具体缩进方式（以我的windows风格为例）：
set cinoptions={0,1s,t0,n-2,p2s,(03s,=.5s,>1s,=1s,:1s
6）如果想在左侧显示文本的行号，可以用以下语句：
set nu
在此文件尾部加入如下信息：
最后，如果没有下列语句，就加上吧：
if &term=="xterm"
set t_Co=8
set t_Sb=^[[4%dm
set t_Sf=^[[3%dm
endif
还有中文显示问题,
可以添加：
let &termencoding=&encoding
set fileencodings=utf-8,gbk,ucs-bom,cp936
上面这两行命令即可。
}
//----------
{
深圳，爱康健口腔医院，(http://www.ckj100.com/yazhoubing/buya/2017/0218/12466.html);
}
//---------
{
HR热线，qunar商业保险；
北京口腔医学会，办公地点挂靠在首都医科大学附属北京口腔医院；
首都医科大学附属北京口腔医院预约挂号；
记得取消一个号,(http://www.bjguahao.gov.cn/u/index.htm);
}
//-------
{
对比两个文本内容是否相同的通常用MD5；
}
//------
{
调用gdbtui调试C/C++程序,(http://mingxinglai.com/cn/2013/07/gdbtui/),(https://ftp.gnu.org/old-gnu/Manuals/gdb-5.1.1/html_chapter/gdb_19.html#SEC200)，
#1. 打开TUI模式
方法一: 使用gdbtui or gdb-tui开始一个调试。
  gdbtui -q sample
友情提示：通过下面的方式调试一个正在运行的进程
  gdb  -p pid
如果出现如下错误，请参考这里。
  Could not attach to process.  If your uid matches the uid of the target
  process, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try
  again as the root user.  For more details, see /etc/sysctl.d/10-ptrace.conf
方法二: 直接使用gdb调试代码，在需要的时候使用切换键 ctrl+x a调出gdbtui。
#2. TUI模式下有4个窗口,
(cmd)command 命令窗口. 可以键入调试命令
(src)source 源代码窗口. 显示当前行,断点等信息
(asm)assembly 汇编代码窗口
(reg)register 寄存器窗口
最常用的也就是默认使用的方式，也可以通过layout命令来进行选择自己需要的窗口，可参见help layout.
}
//---------
{
跟开涛学springMVC,(http://jinnianshilongnian.iteye.com/category/231099);
//--------
SO JSON,(java学习网站),(http://www.sojson.com/blog/);
//--------
开源项目,(https://www.oschina.net/project);
//--------
redis源码剖析,(https://zhuanlan.zhihu.com/zeecoderRedis);
//-------
Nothing replaces hard work!,(http://mingxinglai.com/cn/);
//-------
MySQL,
(http://hedengcheng.com/),
(https://dev.mysql.com/doc/refman/5.5/en/),
(https://dev.mysql.com/doc/internals/en/);
//---------
中华数据库行业协会,(http://www.zhdba.com/);
//--------
mysqlops,(http://www.zhdba.com/mysqlops/2012/07/31/c%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/),
(http://www.zhdba.com/mysqlops/2012/06/08/c-%E5%90%8E%E5%8F%B0%E7%A8%8B%E5%BA%8F%E5%AE%9E%E6%97%B6%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/),
(http://www.zhdba.com/mysqlops/);
}
//----------
{
spring(Overview of Spring Framework),
(https://spring.io/guides),
(https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/overview.html#overview-modules);
To overcome such problems Maven supports the concept of a "bill of materials" (BOM) dependency. You can import the spring-framework-bom in your dependencyManagement section to ensure that all spring dependencies (both direct and transitive) are at the same version.

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-framework-bom</artifactId>
            <version>4.3.11.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
}
//-----------
{
CSDN资源下载,(http://download.csdn.net/search);
july算法总结;
tutorials point,(https://www.tutorialspoint.com/index.htm);
HTTP,(https://developer.mozilla.org/zh-CN/docs/Web/HTTP);
HTTP缓存控制,(http://www.10tiao.com/html/687/201607/2247483845/1.html);
HTTP详解,(http://www.bkjia.com/headlines/491799.html);
linux curl设置首部行,(https://linux.cn/article-4957-1.html);
//-------
java web技术博客,(http://blog.csdn.net/jack__frost?viewmode=contents);
果冻想，技术博客，(http://www.jellythink.com/archives/1414);
servlet技术博客,(http://blog.csdn.net/error/404.html?from=http%3a%2f%2fblog.csdn.net%2fpsyuhen%2farticle%2fdetails%2f7527814);
//---------
}
{
IT技术学习网站:
w3cschool,(https://www.w3cschool.cn/);
RUNOOB.COM,菜鸟教程,(http://www.runoob.com/);
易百教程,(http://www.yiibai.com/);
linuxprobe,(http://www.linuxprobe.com/);
//-----
plantuml,(http://plantuml.com/running);
//------
Markdown,(http://blog.csdn.net/column/details/markdown.html),(http://blog.csdn.net/whqet);
Linux 上 10 个最好的 Markdown 编辑器,(http://locez.com/translation/best-markdown-editors-for-linux/);
//---------
}
//--------
{
Qunar开发规范：只要调用dubbo服务，无论被调函数是否有异常声明，都应该用try...catch处理异常。
调用他人的服务亦是如此。
//--------
Qunar日志的diff功能代码实现,(http://gitlab.corp.qunar.com/scm/common/tree/master/scm-common-diff);
//-----
重视设计文档，一定要养成先写设计文档，再编码的习惯，设计文档应该清晰地体现出设计思路和方法。
}
//--------
{
linux curl命令常用选项：
 -#, --progress-bar
-b, --cookie <name=data>,(If  no  '=' symbol is used in the line, it is treated as a file‐
              name to use to read previously stored cookie lines  from,  which
              should  be used in this session if they match.
               If you start the data with the letter @, the rest  should  be  a
              file  name  to read the data from.);
 -c, --cookie-jar <file name>,( (HTTP)  Specify to which file you want curl to write all cookies
              after a completed operation. Curl writes all cookies  previously
              read  from a specified file as well as all cookies received from
              remote server(s).);
-d, --data <data>
              (HTTP) Sends the specified data in a POST request  to  the  HTTP
              server,  in  the  same  way  that a browser does when a user has
              filled in an HTML form and presses the submit button. This  will
              cause curl to pass the data to the server using the content-type
              application/x-www-form-urlencoded.  Compare to -F, --form.

       -F, --form <name=content>
              (HTTP) This lets curl emulate a filled-in form in which  a  user
              has  pressed  the  submit  button. This causes curl to POST data
              using the  Content-Type  multipart/form-data  according  to  RFC
              2388.  This  enables uploading of binary files etc. To force the
              'content' part to be a file, prefix the  file  name  with  an  @
              sign.  To just get the content part from a file, prefix the file
              name with the symbol <. The difference between @ and <  is  then
              that  @  makes a file get attached in the post as a file upload,
              while the < makes a text field and just  get  the  contents  for
              that text field from a file.
              
       --data-binary <data>
              (HTTP) This posts data exactly as specified with no  extra  pro‐
              cessing whatsoever.

              If  you  start  the data with the letter @, the rest should be a
              filename.
              
        -G, --get
              When  used,  this  option  will make all data specified with -d,
              --data, --data-binary or --data-urlencode to be used in an  HTTP
              GET  request instead of the POST request that otherwise would be
              used. The data will be appended to the URL with a '?' separator.

       (HTTP/FTP/FILE) Fetch the HTTP-header only! HTTP-servers feature
              the command HEAD which this uses to get nothing but  the  header
              of  a  document.

-o, --output <file>
              Write output to <file> instead of stdout. 

       -T, --upload-file <file> This  transfers  the  specified local file to the remote URL. If
              there is no file part in the specified URL, Curl will append the
              local file name. NOTE that you must use a trailing / on the last
              directory to really prove to Curl that there is no file name  or
              curl will think that your last directory name is the remote file
              name to use. 

 -u, --user <user:password;options>
              Specify  the  user  name, password and optional login options to
              use  for  server  authentication.
              
       --url <URL>
              Specify  a  URL  to  fetch. This option is mostly handy when you
              want to specify URL(s) in a config file.

       -H, --header <header>
              (HTTP)  Extra  header  to  use  when getting a web page. You may
              specify any number of extra headers. Note that if you should add
              a  custom  header  that has the same name as one of the internal
              ones curl would use, your externally set  header  will  be  used
              instead of the internal one. 

       -I, --head
              (HTTP/FTP/FILE) Fetch the HTTP-header only! HTTP-servers feature
              the command HEAD which this uses to get nothing but  the  header
              of  a  document.
              
}
//----------
{
curl命令上传的数据：
--data，存于request的报文实体；
--form，存于request的报文实体；
--header，存于request的首部行，用request.getHeader()读取；
查询url内的存于request的uri内，也就是在请求行，用request.getParameter()读取。
}
{
未登录的请求重定向到登录页面;
}
{
一个javaweb应用内，处理同一种uri模式，可以有多个filter，但是servlet只能有一个。
编码过滤器。
POST方式发送的数据在网络上，不在request对象内，对POST数据的读取要考虑网络状况。
servlet调用spring bean的方法，servlet初始化之后立即初始化spring容器，单例模式。可以用一个servlet实现初始化spring容器的工作，
该servlet只负责初始化spring容器，若收到其他请求就抛出异常，以保证功能的专一性。而且该servlet必须是第一个初始化。
后端生成验证码，并传给前端；后端可利用String变量保存验证码，用BufferedImage作图，将图片数据写入resp，传给前端即可。
}
//--------
2017-09-21,
{
学习笔记分为三部分：
txt文档只做总结和重点提示；
doc文档做详细解析；
项目文件和设计文档在idea。
都用github托管。
}
{
remarkable,(https://remarkableapp.github.io/linux.html);
//-------
Install python3-markdown
Installing python3-markdown package on Ubuntu 14.04 (Trusty Tahr) is as easy as running the following command on terminal:

sudo apt-get update
sudo apt-get install python3-markdown
//-------
Open the terminal and type :
wget https://remarkableapp.github.io/files/remarkable_1.62_all.deb
And :
sudo gdebi remarkable_1.62_all.deb
if you get error like gdebi: commande not found you can install it by typing :
sudo apt-get install gdebi-core
//--------
you just have to do :

wget https://remarkableapp.github.io/files/remarkable_1.62_all.deb
dpkg -i remarkable_1.62_all.deb
then (to add missing dependencies) :

apt-get upgrade -f
and the retry install :

dpkg -i remarkable_1.62_all.deb
//---------
下载安装包
http://remarkableapp.github.io/linux/download.html
安装之：
dpkg -i remarkable_1.62_all.deb
1
补上依赖项：
sudo apt-get install -f
1
运行：
remarkable &
//------
在Linux系统中，编辑markdown可以用retext工具：

# Debian/Ubuntu
sudo apt-get install retext
retext Release-Notes.md
//----------
}
//----------
{
git merge的工作原理：
在分支branchA上对文件A作了修改，在分支branchB上也对文件A作了修改，在分支branchA上执行git merge branchB命令这时就会得到冲突信息，需要手动解决冲突，再提交。
在分支branchA上对文件A作了修改，在分支branchB上未对文件A作了修改，在分支branchA上执行git merge branchB命令这时不会得到冲突信息。
}
{
vim toturial,(http://www.openvim.com/);
vim网络教程,(http://www.voidcn.com/tag/vim);
freebuf,(http://www.freebuf.com/?p=136571#);
酷壳,(COOLSHELL),(https://coolshell.cn/),(https://coolshell.cn/featured);
程序园,(http://www.voidcn.com/);
vi/vim使用进阶: 指随意动，移动如飞 ,(http://easwy.com/blog/archives/advanced-vim-skills-basic-move-method/);
//--------------
latency,
//--------
doxygen，文档生成工具；
//--------
vim代码补全，代码高亮；
//---------
}
//----------
{
vim,
//---
:q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。
:bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件）
//------
. → (小数点) 可以重复上一次的命令
N<command> → 重复某个命令N次
//--------
u → undo
<C-r> → redo
//-------
你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：

<start position><command><end position>

例如 0y$ 命令意味着：

0 → 先到行头
y → 从这里开始拷贝
$ → 拷贝到本行最后一个字符
你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。
你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。
//--------
vim +# :打开文件,并定位于第#行
vim +:打开文件,定位至最后一行
vim +/PATTERN : 打开文件,定位至第一次被PATTERN匹配到的行的行首
:next 切换至下一个文件
:prev 切换至前一个文件
:last 切换至最后一个文件
:first 切换至第一个文件
:q退出当前文件
:qa 全部退出
//--------
vim中，移动光标到下一个单词的词首，使用命令”w“，移动光标到上一个单词的词首，使用命令”b“；移动光标到下一个单词的结尾，用命令”e“，移动光标到上一个单词的结尾，使用命令”ge“。
//--------
行内查找，“f“命令移动到光标右边的指定字符上，例如，”fx“，会把移动到光标右边的第一个’x’字符上。”F“命令则反方向查找，也就是移动到光标左边的指定字符上。
“;“命令重复前一次输入的f, t, F, T命令，而”,“命令会反方向重复前一次输入的f, t, F, T命令。这两个命令前也可以使用数字来表示倍数。
//--------
}
{
vim功能总结：
1、文件打开、保存、退出、多文件切换；
vim <文件名>
vim +#  文件名:打开文件,并定位于第#行
vim + 文件名:打开文件,定位至最后一行
vim +/PATTERN  文件名: 打开文件,定位至第一次被PATTERN匹配到的行的行首

:e 文件名，打开新的文件。

vim 以空格分割的文件名列表，这时打开的多个文件在同一个会话内，不同文件之间可以复制数据。
:next 切换至下一个文件
:prev 切换至前一个文件
:last 切换至最后一个文件
:first 切换至第一个文件
:q退出当前文件
:qa 全部退出

:w [文件名]
:saveas 文件名

:n1,n2 w [filename]->将 n1行到n2行的内容储存成 filename 这个档案。

保存文件内的部分内容:
:m,nw 文件名， 将 m 行到 n 行部分的内容保存到文件中。
:m,nw >> 文件名， 将 m 行到 n 行的内容添加到文件的末尾。

ZZ，这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！
//----------
2、文件内光标移动；
NG → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）
gg → 到第一行。（陈皓注：相当于1G，或 :1）
G → 到最后一行。
0: 绝对行首
^: 行首的第一个非空白字符
$: 绝对行尾

按单词移动：
w: 移至下一个单词的词首
e: 跳至当前或下一个单词的词尾
b: 跳至当前或前一个单词的词首
<正整数> w/e/b;

如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量）
如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句）

<正整数> h/j/k/l。
 Vi/Vim 中操作单位有很多，按从小到大的顺序为（括号内为相应的操作命令）：字符（h、l）→ 单词 (w、W、b、B、e) → 行 (j、k、0、^、$、:n) → 句子（(、)）→ 段落（{、}）→ 屏 (H、M、L) → 页（Ctrl-f、Ctrl-b、Ctrl-u、Ctrl-d) → 文件（G、gg、:0、:$）。
//----------
3、文件屏滚动；
Ctrl + e :向下滚动一行
Ctrl + y :向上滚动一行
Ctrl+f: 向下翻一屏
Ctrl+b: 向上翻一屏
Ctrl+d: 向下翻半屏
Ctrl+u: 向上翻半屏
//----------
4、文件内查找字符或字符串；
/pattern: 从光标所在处向下搜索关键字pattern；
?pattern: 从光标所在处向上搜索关键字pattern；
n: 向下搜索，查找下一个匹配项；
N: 向上搜索，查找上一个匹配项；
*：对光标所在的单词，向下查找；
#: 对光标所在的单词，向上查找；
说明：一般情况下，/pattern和n、N配合完成查找，而?pattern用得较少。

同行内查找：
f字符;
F字符；
英文逗号表示向后查找，英文分号表示向前查找；
//----------
5、删除、修改、复制、粘贴、替换；
删除：
dl,dd,dw,de,db;
<正整数> <删除命令>;
x;
<正整数>x;

修改:
修改单个字符:r;
c命令详解：
C or c$
表示修改当前行上光标后面的部分. 进入编辑状态.
c0 or c^
表示从光标处到当前行行首的部分进行修改，^代表首个非空格处。
cc OR S
修改当前行. 进入编辑状态.
cw
从光标所在的位置开始到该单词结束进行修改. 进入编辑状态
cfx AND cFx
这里的 x 为一任意字符, cfx 表示修改从光标到下一个字符 x 之间的文本;
cFx 表示修改从光标到上一个字符 x 之间的文本.
cn|
修改从光标到当前行的第 n 个字符间的所有字符, n 正整数.
cnG and cG
这里的 n 为一任意自然数, cnG 表示修改当前行到第 n 行之间的所有行;
cG 表示修改当前行直至末行.
c 命令所删除的数据都存在缓冲区, 可以结合p/P命令构成剪切粘贴操作, 方法是:
先进行 c 命令, 再按 Esc 键返回命令模式, 最后才进行 p/P 命令.

复制：
yl,yy,yw,ye,yb;
<正整数><复制命令>;

粘贴：
p,P;

替换:
r，替换当前的一个字符;
<正整数>r;
r只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)
:n1,n2s/src/dest/g: 在n1行到n2行之间（包括n1行和n2行），查找src，并将所有的src替换成dest；
:1,$s/src/dest/g: 查查找范围为第一行到最后一行，将所有的src替换为dest，只是在替换时会有确认；
:.,$s/src/dest/g: 查找范围为当前行到最后一行，将所有的src替换为dest；(因为在命令模式下，.表示当前行)

//----------
6、操作的重复、撤销、重做；
ctrl+r;
u;正整数u;
.;正整数.;
//----------
7、寄存器保存操作以便于重复；
8、代码补全；
//--------
9、代码缩进；
:set shiftwidth=<正整数>
当前行向右缩进一次：操作 >> 或者输入命令 :>
当前行向左缩进一次：操作 << 或者输入命令 :<
从第m行起，到第n行止向右缩进一次： 输入命令 :m,n> 等价于命令 :m>(n-m+1)
从第m行起，到第n行止向左缩进一次： 输入命令 :m,n< 等价于命令 :m<(n-m+1)
从第m行起共n行向右缩进一次： 输入命令 :m>n 等价于命令 :m,m+n-1>
从第m行起共n行向左缩进一次： 输入命令 :m<n 等价于命令 :m,m+n-1<
//----
10、代码折叠；
//------
11、普通模式进入编辑模式；
从一般模式进入编辑模式的命令有：
i, I: i表示在光标所在字符之前插入，I表示在光标所在行的第一个非空字符前插入；
a, A: a表示在光标所在字符之后插入，A表示在光标所在行的最后一个非空字符后插入；
o, O: o表示在光标所在行的下一行插入，O表示在光标所在行的上一行插入。
//-------
12、配置文件vimrc；
/etc/vimrc，针对所有用户；
~/.vimrc，针对当前用户；
//--------
13、底部命令模式；
:sysntax on/off
:set nu/nonu
:set hlsearch
:set nohlsearch
:set ignorecase/noignorecase
:set autoindent/noautoindent
:set cindent/nocindent
:set tabstop=4
tabstop     一个tab键所占的列数，linux 内核代码建议每个tab占用8列
softtabstop 敲入tab键时实际占有的列数。
//--------
14、vim内执行shell命令；
:!<shell命令>

//--------
15、vim内强制执行命令；
:<vim命令>!
//-----
16、在当前文件内引入其他的文件数据：
:r 文件名
将另一文件内的数据附加到当前文件光标之后；
//-----------
17、录制宏；
q<a~z><vim命令>q，
正整数@<a~z>
vim命令都保存在寄存器内，录制和执行时寄存器要一致；
查看、编辑录制寄存器的方法是：
Esc,G,"<a~z>p;
//-----------
18、代码折叠：
set foldenable              " 开始折叠
set foldmethod=syntax       " 设置语法折叠
set foldcolumn=0            " 设置折叠区域的宽度
setlocal foldlevel=1        " 设置折叠层数为

zc 折叠
zC 对所在范围内所有嵌套的折叠点进行折叠
zo 展开折叠
zO 对所在范围内所有嵌套的折叠点展开
[z 到当前打开的折叠的开始处。
]z 到当前打开的折叠的末尾处。
zj 向下移动。到达下一个折叠的开始处。关闭的折叠也被计入。
zk 向上移动到前一折叠的结束处。关闭的折叠也被计入。
//-----------
17、改变大小写：
~,翻转光标下的字母的大小写;
gU，将光标下的字母改为大写;
gu，将光标下的字母改为小写;

U， 将可视模式下选择的字母全改成大写字母。
u，将可视模式下选择的字母全改成小写。
//-----------
18、ctags:
跳转
在SourceInsight中想要跳转到某个函数，只需要按住shift键，然后点击鼠标左键就可以了，在vim中同样很简单快速，直接按组合键ctrl_]就可以了，当然前提条件是已经生成了tags文件，并设置好了。查看详细的帮助：:help ^]。
跳转到函数、全局结构、全局变量等tag： 组合键 ctrl_]
从tag处返回跳转的位置：组合键 ctrl_t
跳转到全局变量处： 快捷键 gD
跳转到局部变量处： 快捷键 gd
返回到上一个操作位置（上一次光标位置）： 组合键 ctrl_o
返回到下一个操作位置（更新的光标位置）： 组合键 ctrl_i
//-----------
19、vim特殊用法示例；
ddp交换当前行和其下一行
xp交换当前字符和其后一个字符

J(shift + j)
删除两行之间的空行,实际上是合并两
行。

在行首加入#，
3,5 s/^/#/g 注释第3-5行
3,5 s/^#//g 解除3-5行的注释
1,$ s/^/#/g 注释整个文档。

对齐行
v 选定需要整齐的行，输入 = 进行归整

清除页面中所有行尾的空白符：
:%s//s/+$//

按下^V后即可进行矩形的选择了。
}
//-----------
{
值班表系统的权限管理,(http://pmo.corp.qunar.com/browse/DZS-18608);
今天上午在执行git命令时，报错，如图所示。
当时有点懵，不知所措，细细一想，终于明白，要解决问题还是应该从报错文字里找答案。3
根据提示可知，解决办法是：
remove with: ssh-keygen -f "/home/linux2014/.ssh/known_hosts" -R gitlab.corp.qunar.com
}

//-----------
{
IBM developers work,(https://www.ibm.com/developerworks/cn/opensource/);
慕课网,(http://www.imooc.com/),(http://www.imooc.com/video/12084);
SSM,(http://www.imooc.com/course/programdetail/pid/59);
杨英明的个人博客,(http://www.yangyingming.com/);
极客学院,java servlet,(http://wiki.jikexueyuan.com/project/servlet/);
java web优质教程,(http://www.java1234.com/a/javabook/javaweb/2016/1023/6907.html);
Java Web项目开发案例精粹视频与源码合集（免费）,(http://www.jianshu.com/p/565bb6d85d5b);
易百教程--maven,(http://www.yiibai.com/maven/maven_project_documents.html);
idea官网教程,(https://www.jetbrains.com/help/idea/discover-intellij-idea.html#Inspections);
迹忆,(http://www.onmpw.com/);
}
//-----------
{
本次 Live 主要包括以下内容

＊ 为什么面试官都喜欢考程序员基础算法？
＊ 如何高效、系统性地学习算法和数据结构？
＊ 为什么大家普遍觉得动态规划较难理解？
＊ 学算法是否有必要参加 OI / ACM 等算法编程竞赛？
＊ 如何平衡自己在算法、竞赛上和其它方面学习的精力投入？
＊ 学习传统算法对日后工作的帮助具体有多大？
＊ 学习传统算法对学习机器学习的帮助具体有多大？
＊ 最后分享一些趣题和面试考察的算法和数据结构侧重点

本次 Live 适用于：

＊ 备战 OI/ACM 等算法类竞赛的同学
＊ 立志不只编写增删改查等业务代码的同学
＊ 备战明年校招 or 跳槽时被考察算法的同学
＊ 对算法学习感到迷茫，不知道学了能干嘛的同学。
＊ 在通往人工智能的道路上被传统算法绊住脚的同学
＊ 非科班出生在被人安利了无数次《算法导论》后望而却步的同学

本次 Live 主要包括以下内容

＊ 怎么定义一个算法工程师？它与其它传统研发岗位的区别是什么？
＊ 算法工程师所需的内功和外功是什么？
＊ 算法工程师拥有怎样的不可替代性及成长性？
＊ 如何才能最快速度成长为一名合格的算法工程师？
＊ 如何才能通过国内大厂的算法岗面试？
}
{
As the first phase of a compiler, the main task of the lexical analyzer is to
read the input characters of the source program, group them into lexemes, and
produce as output a sequence of tokens for each lexeme in the source program.

When discussing lexical analysis, we use three related but distinct terms:
• A token is a pair consisting of a token name and an optional attribute
value. The token name is an abstract symbol representing a kind of
lexical unit, e.g., a particular keyword, or a sequence of input characters
denoting an identifier. The token names are the input symbols that the
parser processes. In what follows, we shall generally write the name of a
token in boldface. We will often refer to a token by its token name.
• A pattern is a description of the form that the lexemes of a token may take.
In the case of a keyword as a token, the pattern is just the sequence of
characters that form the keyword. For identifiers and some other tokens,
the pattern is a more complex structure that is matched by many strings.
• A lexeme is a sequence of characters in the source program that matches
the pattern for a token and is identified by the lexical analyzer as an
instance of that token.

We shall assume that tokens have at most one associated attribute, although
this attribute may have a structure that combines several pieces of information.

An alphabet is any finite set of symbols.
A string over an alphabet is a finite sequence of symbols drawn from that
alphabet. In language theory, the terms "sentence" and "word" are often used
as synonyms for "string."
The empty string, denoted t, is the string of length zero.
A language is any countable set of strings over some fixed alphabet. This
definition is very broad.

A language that can be defined by a regular expression is called a regular
set. If two regular expressions r and s denote the same regular set, we say they
are equivalent and write r = s.

}
{
SSO,一次登录，处处穿梭。
分类：同域；跨域。
关键点：存储cookie，查验cookie。

chrome查看cookie;
cookie.setPath();
cookie.setDomain();
ServletActionContext.getResponse();
HttpURLConnection
}
//-----------
{
NFA->DFA,
initial_state;
accepting_state;
Dtrans[T,a];
//-----
re->NFA;
basis;
induction;
}
//-----------
{
codeblocks,
下载地址：http://www.zhuantilan.com/xiazai/C/C++jichengkaifahuanjingCodeBlocks.html
教程地址：http://www.zhuantilan.com/zt/CodeBlocks/
user doc,(http://wiki.codeblocks.org/index.php/User_documentation);
官网,download,(http://www.codeblocks.org/downloads);
wxWidgets,(https://www.wxwidgets.org/downloads/);
(
To install Code::Blocks from this PPA, open a terminal and type:

sudo add-apt-repository ppa:damien-moore/codeblocks-stable
sudo apt-get update
sudo apt-get install codeblocks codeblocks-contrib
);
}
//-----------
{
学习内容：
linux命令的源码实现，例如grep、curl、wget；
《How tomcat works》、《构建web站点》、《Java web》；
《代码大全》；
《构建高性能Web站点（精选版)》；
}
//-----------
2017-09-27,
{
git@gitlab.corp.qunar.com:scm/permissions.git
permissions-api
java web应用的启动过程；
tomcat感知spring；
}
{
idea，浏览位置的回退和前进，快捷键(Alt+F,Alt+B)；
idea，根据类名查找一个类(ctrl+N)，根据文件名查找一个文件(ctrl+shift+N)，根据一个字符串查找其所在的文件(ctrl+shift+F)，快捷键；
《研发类面试真题及其解析》;
//-------
实例应用：
在项目permissions、ct项目内查看loginFilter的应用。
}
//-----------
{
近期任务：
家庭办公的联网方式。
ServletContextListener,FilterProxy的实现总结要写成CSDN技术博客。
学习javaweb的经典书籍、大量y练习项目。
}
{
酷派系列,
枭楚ZR旗舰版
}
{
黑客查询问题的方法：
Google Scholar
Scirus
}
//-----------














